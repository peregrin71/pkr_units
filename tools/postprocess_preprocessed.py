#!/usr/bin/env python3
"""Post-process a raw preprocessed C++ file to keep only content from project headers.

Usage:
  python tools/postprocess_preprocessed.py --input <raw_preprocessed.h> --output <ce/pkr_units.h> --project-root sdk/include/pkr_units

The script keeps only lines that originate from files under the given project root. It preserves
'#define' directives that come from project files and non-empty code lines. The output includes
an auto-generated header guard and a generation notice.
"""
from pathlib import Path
import argparse
import re
import sys

LINE_MARKER_RE = re.compile(r'^\s*#\s*(\d+)\s+"([^"]+)"')


def is_project_file(filename: str, project_root: str) -> bool:
    # Normalize and check substring; handles WSL paths (/mnt/c/...) and Windows paths
    def variants(p: str):
        p = p.replace('\\', '/').lower()
        vs = {p}
        m = re.match(r'^/mnt/([a-z])/(.*)', p)
        if m:
            vs.add(f"{m.group(1)}:/{m.group(2)}")
        m2 = re.match(r'^([a-z]):/(.*)', p)
        if m2:
            vs.add(f"/mnt/{m2.group(1)}/{m2.group(2)}")
        return vs

    fn_variants = variants(filename)
    pr_variants = variants(project_root)

    # If any variant of project_root is a substring of any variant of filename, it's a project file
    for pr in pr_variants:
        for fn in fn_variants:
            if pr in fn:
                return True
    return False


def postprocess(input_path: Path, output_path: Path, project_root: str):
    if not input_path.exists():
        raise SystemExit(f'Input file not found: {input_path}')

    project_root = str(Path(project_root).resolve())

    out_lines = []
    out_lines.append('// Auto-generated cleaned header for Compiler Explorer')
    out_lines.append('// Generated by tools/postprocess_preprocessed.py')
    out_lines.append('')
    out_lines.append('#ifndef PKR_UNITS_CE_SINGLE_HEADER_H')
    out_lines.append('#define PKR_UNITS_CE_SINGLE_HEADER_H')
    out_lines.append('')

    current_file = None
    include_block = False
    blank_pending = False
    collected_entries = []  # list of (filename, line) tuples for project-origin content

    with input_path.open('r', encoding='utf-8', errors='ignore') as f:
        for raw in f:
            line = raw.rstrip('\n')
            m = LINE_MARKER_RE.match(line)
            if m:
                current_file = m.group(2)
                include_block = is_project_file(current_file, project_root)
                continue

            if include_block:
                # Keep #define lines from project files
                if line.lstrip().startswith('#'):
                    if line.lstrip().startswith('#define') or line.lstrip().startswith('#pragma') or line.lstrip().startswith('#if') or line.lstrip().startswith('#endif'):
                        collected_entries.append((current_file, line))
                        blank_pending = False
                    # Ignore other preprocessor directives (e.g., #line) from project files
                    continue

                # Skip empty lines but collapse them (avoid many blank lines)
                if not line.strip():
                    if not blank_pending:
                        collected_entries.append((current_file, ''))
                        blank_pending = True
                    continue

                # Normal code line — include
                collected_entries.append((current_file, line))
                blank_pending = False
            else:
                # Not a project file — ignore
                continue

    # Now we have per-line filename info in collected_entries. We'll perform two fixes:
    # 1) Deduplicate user-defined literal operator definitions (keep one per suffix),
    #    preferring definitions that originate from a '/units/' header when possible.
    # 2) Deduplicate inline constexpr variable definitions (e.g., dimension constants).

    # Helper to identify operator literal lines
    udl_def_re = re.compile(r"^\s*(?:constexpr\s+)?([\w:\<\> ,]+?)\s+operator\"\"_(\w+)\s*\(([^)]*)\)")
    inline_const_re = re.compile(r"^\s*inline\s+constexpr\s+[\w:<> ,]+\s+(\w+)\s*\{")

    seen_udls = {}
    seen_inlines = set()
    kept_entries = []

    for fname, line in collected_entries:
        udl_m = udl_def_re.match(line)
        if udl_m:
            ret_type = udl_m.group(1).strip()
            suffix = udl_m.group(2)
            params = udl_m.group(3).strip()
            sig = (suffix, params)
            # If not seen, keep; if seen, decide based on preference
            if sig not in seen_udls:
                seen_udls[sig] = (fname, line)
                kept_entries.append((fname, line))
            else:
                # Prefer the one coming from a '/units/' header path
                prev_fname, prev_line = seen_udls[sig]
                def prefer(f):
                    return ('/units/' in f.replace('\\', '/').lower())
                if prefer(fname) and not prefer(prev_fname):
                    # replace previous with this one
                    seen_udls[sig] = (fname, line)
                    # remove previous kept entry and append current
                    # (fallback: rebuild kept_entries without prev)
                    kept_entries = [e for e in kept_entries if e != (prev_fname, prev_line)]
                    kept_entries.append((fname, line))
                else:
                    # keep previous, skip this one
                    continue
            continue

        inline_m = inline_const_re.match(line)
        if inline_m:
            name = inline_m.group(1)
            if name in seen_inlines:
                # skip duplicate inline constexpr definition
                continue
            seen_inlines.add(name)
            kept_entries.append((fname, line))
            continue

        # otherwise keep line
        kept_entries.append((fname, line))

    # Reconstruct collected_lines from kept_entries
    collected_lines = [l for f, l in kept_entries]

    # Detect usage of common std identifiers to add necessary includes
    # Ordered list so headers appear deterministic and only once
    std_candidates = [
        (r'\bbitset\b', '<bitset>'),
        (r'\bchrono\b', '<chrono>'),
        (r'\bcomplex\b', '<complex>'),
        (r'\bcos\b', '<cmath>'),
        (r'\bformat\b', '<format>'),
        (r'\bllround\b', '<cmath>'),
        (r'\boptional\b', '<optional>'),
        (r'\bratio\b', '<ratio>'),
        (r'\bround\b', '<cmath>'),
        (r'\bsin\b', '<cmath>'),
        (r'\bspan\b', '<span>'),
        (r'\bsqrt\b', '<cmath>'),
        (r'\bstd::bitset\b', '<bitset>'),
        (r'\bstd::chrono\b', '<chrono>'),
        (r'\bstd::complex\b', '<complex>'),
        (r'\bstd::cos\b', '<cmath>'),
        (r'\bstd::format\b', '<format>'),
        (r'\bstd::llround\b', '<cmath>'),
        (r'\bstd::optional\b', '<optional>'),
        (r'\bstd::ratio\b', '<ratio>'),
        (r'\bstd::round\b', '<cmath>'),
        (r'\bstd::sin\b', '<cmath>'),
        (r'\bstd::span\b', '<span>'),
        (r'\bstd::sqrt\b', '<cmath>'),
        (r'\bstd::string_view\b', '<string_view>'),
        (r'\bstd::string\b', '<string>'),
        (r'\bstd::tan\b', '<cmath>'),
        (r'\bstring_view\b', '<string_view>'),
        (r'\bstring\b', '<string>'),
        (r'\btan\b', '<cmath>'),
    ]

    found_headers = []
    collected_text = '\n'.join(collected_lines)

    # Fix up usage of class-template names used as return types in user-defined literal
    # operators. Some compilers reject bare template names as function return types
    # and CTAD sometimes fails for the constructor expression. We'll:
    #  - change the operator return type to 'auto' when it's a bare template name
    #  - ensure constructor expressions explicitly instantiate with <double>
    templated_types = set(re.findall(r'template\s*<[^>]+>\s*struct\s+(\w+)', '\n'.join(collected_lines)))

    if templated_types:
        text = '\n'.join(collected_lines)
        # replace bare return-type templates on operator definitions with 'auto'
        for tname in templated_types:
            pat_return = re.compile(r"\b" + re.escape(tname) + r"\b(?!\s*<)(?=\s+operator\"\"_)")
            text = pat_return.sub('auto', text)
            # replace constructor uses like 'T{static_cast<double>(value)}' with 'T<double>{...}'
            pat_ctor = re.compile(r"\b" + re.escape(tname) + r"\s*\{\s*static_cast<double>\(value\)\s*\}")
            text = pat_ctor.sub(tname + '<double>{static_cast<double>(value)}', text)
        collected_lines = text.splitlines()

    for patt, header in std_candidates:
        try:
            if re.search(patt, collected_text):
                if header not in found_headers:
                    found_headers.append(header)
        except re.error:
            # skip invalid regex
            pass

    # split modified collected_text back into lines so the 'auto' substitutions are included
    collected_lines = collected_text.splitlines()

    # place detected std headers immediately after the header guard (top of file)
    if found_headers:
        for h in found_headers:
            out_lines.append(f'#include {h}')
        out_lines.append('')

    # append collected lines
    out_lines.extend(collected_lines)

    out_lines.append('')
    out_lines.append('#endif // PKR_UNITS_CE_SINGLE_HEADER_H')

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text('\n'.join(out_lines) + '\n', encoding='utf-8')
    print(f'Wrote cleaned header to {output_path}')


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Postprocess preprocessed header to project-only content')
    parser.add_argument('--input', type=Path, required=True, help='Raw preprocessed input file')
    parser.add_argument('--output', type=Path, required=True, help='Output cleaned header file')
    parser.add_argument('--project-root', required=True, help='Project header root (e.g. sdk/include/pkr_units)')
    args = parser.parse_args()
    postprocess(args.input, args.output, args.project_root)
