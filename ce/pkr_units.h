// Auto-generated cleaned header for Compiler Explorer
// Generated by tools/postprocess_preprocessed.py

#ifndef PKR_UNITS_CE_SINGLE_HEADER_H
#define PKR_UNITS_CE_SINGLE_HEADER_H

#include <format>
#include <chrono>
#include <string_view>
#include <string>
#include <ratio>
#include <cmath>


namespace pkr::units::impl
{

template <typename CharT>
struct char_traits_dispatch;

template <>
struct char_traits_dispatch<char>
{
    static constexpr std::string_view plus_minus()
    {
        return " +/- ";
    }

    static constexpr std::string_view superscript_minus()
    {
        return "⁻";
    }

    static constexpr std::string_view superscript_caret()
    {
        return "^";
    }

    static constexpr std::string_view separator()
    {
        return "·";
    }
};

template <>
struct char_traits_dispatch<char8_t>
{
    static constexpr std::u8string_view plus_minus()
    {
        return u8" \u00B1 ";
    }

    static constexpr std::u8string_view superscript_minus()
    {
        return u8"⁻";
    }

    static constexpr std::u8string_view superscript_caret()
    {
        return u8"^";
    }

    static constexpr std::u8string_view separator()
    {
        return u8"·";
    }
};

template <>
struct char_traits_dispatch<wchar_t>
{
    static constexpr std::wstring_view plus_minus()
    {
        return L" \u00B1 ";
    }

    static constexpr std::wstring_view superscript_minus()
    {
        return L"⁻";
    }

    static constexpr std::wstring_view superscript_caret()
    {
        return L"^";
    }

    static constexpr std::wstring_view separator()
    {
        return L"·";
    }
};

template <typename CharT>
constexpr std::basic_string_view<CharT> superscript_digit_lookup(int digit);

template <>
constexpr std::basic_string_view<char> superscript_digit_lookup<char>(int digit)
{
    switch (digit)
    {
        case 0:
            return "⁰";
        case 1:
            return "¹";
        case 2:
            return "²";
        case 3:
            return "³";
        case 4:
            return "⁴";
        case 5:
            return "⁵";
        case 6:
            return "⁶";
        case 7:
            return "⁷";
        case 8:
            return "⁸";
        case 9:
            return "⁹";
        default:
            return "";
    }
}

template <>
constexpr std::basic_string_view<char8_t> superscript_digit_lookup<char8_t>(int digit)
{
    switch (digit)
    {
        case 0:
            return u8"⁰";
        case 1:
            return u8"¹";
        case 2:
            return u8"²";
        case 3:
            return u8"³";
        case 4:
            return u8"⁴";
        case 5:
            return u8"⁵";
        case 6:
            return u8"⁶";
        case 7:
            return u8"⁷";
        case 8:
            return u8"⁸";
        case 9:
            return u8"⁹";
        default:
            return u8"";
    }
}

template <>
constexpr std::basic_string_view<wchar_t> superscript_digit_lookup<wchar_t>(int digit)
{
    switch (digit)
    {
        case 0:
            return L"⁰";
        case 1:
            return L"¹";
        case 2:
            return L"²";
        case 3:
            return L"³";
        case 4:
            return L"⁴";
        case 5:
            return L"⁵";
        case 6:
            return L"⁶";
        case 7:
            return L"⁷";
        case 8:
            return L"⁸";
        case 9:
            return L"⁹";
        default:
            return L"";
    }
}

}

namespace pkr::units
{
struct dimension_t
{
    int length = 0;
    int mass = 0;
    int time = 0;
    int current = 0;
    int temperature = 0;
    int amount = 0;
    int intensity = 0;
    int angle = 0;
    int star_angle = 0;

    constexpr bool operator==(const dimension_t&) const = default;
};

inline constexpr dimension_t scalar_dimension{0, 0, 0, 0, 0, 0, 0, 0, 0};

template <typename CharT>
inline constexpr std::basic_string_view<CharT> base_unit_symbols[] = {
    std::basic_string_view<CharT>{},
    std::basic_string_view<CharT>{},
    std::basic_string_view<CharT>{},
    std::basic_string_view<CharT>{},
    std::basic_string_view<CharT>{},
    std::basic_string_view<CharT>{},
    std::basic_string_view<CharT>{},
    std::basic_string_view<CharT>{},
    std::basic_string_view<CharT>{}
};

template <>
inline constexpr std::basic_string_view<char> base_unit_symbols<char>[] = {"kg", "m", "s", "A", "K", "mol", "cd", "rad", "sr"};

template <>
inline constexpr std::basic_string_view<wchar_t> base_unit_symbols<wchar_t>[] = {L"kg", L"m", L"s", L"A", L"K", L"mol", L"cd", L"rad", L"sr"};

template <>
inline constexpr std::basic_string_view<char8_t> base_unit_symbols<char8_t>[] = {u8"kg", u8"m", u8"s", u8"A", u8"K", u8"mol", u8"cd", u8"rad", u8"sr"};

template <typename CharT>
std::basic_string<CharT> superscript_exponent(int exp)
{
    if (exp == 0)
        return std::basic_string<CharT>{};

    bool negative = exp < 0;
    int abs_exp = negative ? -exp : exp;
    std::basic_string<CharT> s;

    if (negative)
        s += impl::char_traits_dispatch<CharT>::superscript_minus();
    else
        s += impl::char_traits_dispatch<CharT>::superscript_caret();

    std::string digit_str = std::to_string(abs_exp);
    for (char c : digit_str)
    {
        int digit_idx = c - '0';
        s += impl::superscript_digit_lookup<CharT>(digit_idx);
    }

    return s;
}

template <typename CharT>
std::basic_string<CharT> build_dimension_symbol(const dimension_t& dim)
{
    std::basic_string<CharT> result;

    const int dims[] = {dim.mass, dim.length, dim.time, dim.current, dim.temperature, dim.amount, dim.intensity, dim.angle, dim.star_angle};
    const auto& symbols = base_unit_symbols<CharT>;

    for (int i = 0; i < 9; ++i)
    {
        if (dims[i] != 0)
        {
            if (!result.empty())
                result += impl::char_traits_dispatch<CharT>::separator();

            result += symbols[i];
            if (dims[i] != 1)
                result += superscript_exponent<CharT>(dims[i]);
        }
    }

    if (result.empty())
        return std::basic_string<CharT>{};

    return result;
}

}

namespace pkr::units
{

template <typename type_t>
concept is_unit_value_type_c = (std::is_integral_v<type_t> && !std::same_as<type_t, bool> && std::is_signed_v<type_t>) || std::is_floating_point_v<type_t> ||

                               std::same_as<type_t, __float128> ||

                               std::same_as<type_t, std::complex<float>> || std::same_as<type_t, std::complex<double>>;

static_assert(is_unit_value_type_c<float>);
static_assert(is_unit_value_type_c<double>);
static_assert(is_unit_value_type_c<std::complex<double>>);
static_assert(is_unit_value_type_c<int>);
static_assert(is_unit_value_type_c<long long>);
static_assert(!is_unit_value_type_c<bool>);

namespace details
{

template <pkr::units::is_unit_value_type_c type_t, typename ratio_t, pkr::units::dimension_t dim_v>
struct derived_unit_type_t;

template <typename type_t, typename ratio_from, typename ratio_to>
constexpr type_t convert_ratio_to(type_t value) noexcept
{
    using conversion = std::ratio_divide<ratio_from, ratio_to>;
    return (value / static_cast<type_t>(conversion::den)) * static_cast<type_t>(conversion::num);
}

template <typename type_t>
constexpr type_t multiply_values(type_t val1, type_t val2) noexcept
{
    return val1 * val2;
}

template <typename type_t>
constexpr type_t divide_values(type_t val1, type_t val2) noexcept
{
    return val1 / val2;
}

template <pkr::units::is_unit_value_type_c type_t, typename ratio_t, pkr::units::dimension_t dim_v>
class unit_t
{
public:
    using value_type = type_t;
    using ratio_type = ratio_t;
    using dimension_type = std::integral_constant<pkr::units::dimension_t, dim_v>;

    struct dimension
    {
        static constexpr pkr::units::dimension_t value = dim_v;
    };

    explicit constexpr unit_t(type_t value) noexcept
        : m_value(value)
    {
    }

    template <typename other_ratio_t>
    constexpr unit_t(const unit_t<type_t, other_ratio_t, dim_v>& other) noexcept
        : m_value(convert_ratio_to<type_t, other_ratio_t, ratio_t>(other.value()))
    {
    }

    constexpr unit_t(const unit_t&) noexcept = default;
    constexpr unit_t(unit_t&&) noexcept = default;
    constexpr unit_t& operator=(const unit_t&) noexcept = default;
    constexpr unit_t& operator=(unit_t&&) noexcept = default;

    template <typename ratio_u, dimension_t dim_u>
    constexpr auto operator*(const details::unit_t<type_t, ratio_u, dim_u>& other) const noexcept
    {

        using combined_ratio = std::ratio_multiply<ratio_t, ratio_u>;

        constexpr dimension_t combined_dim_v{
            .length = dim_v.length + dim_u.length,
            .mass = dim_v.mass + dim_u.mass,
            .time = dim_v.time + dim_u.time,
            .current = dim_v.current + dim_u.current,
            .temperature = dim_v.temperature + dim_u.temperature,
            .amount = dim_v.amount + dim_u.amount,
            .intensity = dim_v.intensity + dim_u.intensity,
            .angle = dim_v.angle + dim_u.angle};

        type_t result_value = m_value * other.value();
        return typename details::derived_unit_type_t<type_t, combined_ratio, combined_dim_v>::type{result_value};
    }

    template <typename ratio_u, dimension_t dim_u>
    constexpr auto operator/(const details::unit_t<type_t, ratio_u, dim_u>& other) const
    {

        if (!std::is_constant_evaluated())
        {
            if ((other.value() < static_cast<type_t>(0) ? -other.value() : other.value()) == static_cast<type_t>(0))
            {
                throw std::invalid_argument("Division by zero in si_unit::operator/");
            }
        }

        using combined_ratio = std::ratio_divide<ratio_t, ratio_u>;

        constexpr dimension_t combined_dim_v{
            dim_v.length - dim_u.length,
            dim_v.mass - dim_u.mass,
            dim_v.time - dim_u.time,
            dim_v.current - dim_u.current,
            dim_v.temperature - dim_u.temperature,
            dim_v.amount - dim_u.amount,
            dim_v.intensity - dim_u.intensity,
            dim_v.angle - dim_u.angle};

        type_t result_value = m_value / other.value();
        return typename details::derived_unit_type_t<type_t, combined_ratio, combined_dim_v>::type{result_value};
    }

    constexpr auto operator*(std::same_as<type_t> auto scalar) const noexcept
    {
        using result_type = typename derived_unit_type_t<type_t, ratio_t, dim_v>::type;
        return result_type{m_value * scalar};
    }

    constexpr auto operator/(std::same_as<type_t> auto scalar) const noexcept
    {
        using result_type = typename derived_unit_type_t<type_t, ratio_t, dim_v>::type;
        return result_type{m_value / scalar};
    }

    constexpr unit_t& operator+=(const unit_t& other) noexcept
    {
        m_value += other.m_value;
        return *this;
    }

    constexpr unit_t& operator-=(const unit_t& other) noexcept
    {
        m_value -= other.m_value;
        return *this;
    }

    constexpr unit_t& operator*=(std::same_as<type_t> auto scalar) noexcept
    {
        m_value *= scalar;
        return *this;
    }

    constexpr unit_t& operator/=(std::same_as<type_t> auto scalar) noexcept
    {
        m_value /= scalar;
        return *this;
    }

    constexpr type_t value() const noexcept
    {
        return m_value;
    }

    constexpr type_t operator*() const noexcept
    {
        return m_value;
    }

    constexpr auto to_si() const noexcept
    {

        type_t canonical_value = convert_ratio_to<type_t, ratio_t, std::ratio<1, 1>>(m_value);

        using canonical_unit = typename derived_unit_type_t<type_t, std::ratio<1, 1>, dim_v>::type;
        return canonical_unit{canonical_value};
    }

    constexpr auto in_base_si_units() const noexcept
    {

        type_t canonical_value = convert_ratio_to<type_t, ratio_t, std::ratio<1, 1>>(m_value);

        return details::unit_t<type_t, std::ratio<1, 1>, dim_v>{canonical_value};
    }

private:
    type_t m_value;
};

template <pkr::units::is_unit_value_type_c type_t, typename ratio_t, pkr::units::dimension_t dim_v>
struct derived_unit_type_t
{
    using type = details::unit_t<type_t, ratio_t, dim_v>;
};
template <typename T>
struct is_pkr_unit : std::false_type
{
};

template <typename type_t, typename ratio_t, dimension_t dim_v>
struct is_pkr_unit<details::unit_t<type_t, ratio_t, dim_v>> : std::true_type
{
    static constexpr bool value = true;
    using value_type = type_t;
    using ratio_type = ratio_t;
    using most_derived_type = details::unit_t<type_t, ratio_t, dim_v>;
    static constexpr dimension_t value_dimension = dim_v;
};

template <typename T>
    requires std::is_base_of_v<typename T::_base, T>

struct is_pkr_unit<T> : std::true_type
{
    static constexpr bool value = true;
    using value_type = typename T::_base::value_type;
    using ratio_type = typename T::_base::ratio_type;
    using most_derived_type = T;

    static constexpr dimension_t value_dimension = T::_base::dimension::value;
};

template <typename T>
struct is_pkr_unit<const T&> : is_pkr_unit<T>
{
};

template <typename T>
struct is_pkr_unit<T&> : is_pkr_unit<T>
{
};

template <typename T>
struct is_pkr_unit<const T> : is_pkr_unit<T>
{
};

}

}

namespace pkr::units
{

template <typename UnitT>
concept is_angle_unit_c = requires { typename UnitT::dimension; } && UnitT::dimension::value.angle == 1 && UnitT::dimension::value.length == 0 &&
                          UnitT::dimension::value.mass == 0 && UnitT::dimension::value.time == 0 && UnitT::dimension::value.current == 0 &&
                          UnitT::dimension::value.temperature == 0 && UnitT::dimension::value.amount == 0 && UnitT::dimension::value.intensity == 0;

template <typename ScalarT>
concept scalar_value_c = std::same_as<std::remove_cvref_t<ScalarT>, float> || std::same_as<std::remove_cvref_t<ScalarT>, double>;

static_assert(scalar_value_c<float>);
static_assert(scalar_value_c<double>);
static_assert(!scalar_value_c<bool>);

template <typename T>
concept is_base_unit_t_c = std::same_as<
    T,
    details::unit_t<typename details::is_pkr_unit<T>::value_type, typename details::is_pkr_unit<T>::ratio_type, details::is_pkr_unit<T>::value_dimension>>;

template <typename T>
concept is_derived_pkr_unit_c = requires { typename T::_base; } && std::is_base_of_v<typename T::_base, T>;

template <typename T>
concept is_base_pkr_unit_c = details::is_pkr_unit<T>::value && !is_derived_pkr_unit_c<T>;

template <typename T>
concept is_pkr_unit_c = is_base_pkr_unit_c<T> || is_derived_pkr_unit_c<T>;

template <dimension_t Dim>
concept pkr_unit_can_take_square_root_c = Dim.length >= 0 && Dim.length % 2 == 0 && Dim.mass >= 0 && Dim.mass % 2 == 0 && Dim.time >= 0 && Dim.time % 2 == 0 &&
                                          Dim.current >= 0 && Dim.current % 2 == 0 && Dim.temperature >= 0 && Dim.temperature % 2 == 0 && Dim.amount >= 0 &&
                                          Dim.amount % 2 == 0 && Dim.intensity >= 0 && Dim.intensity % 2 == 0 && Dim.angle >= 0 && Dim.angle % 2 == 0;

}

namespace pkr::units
{

template <typename T1, typename T2>
concept same_dimensions_c = details::is_pkr_unit<T1>::value_dimension.length == details::is_pkr_unit<T2>::value_dimension.length &&
                            details::is_pkr_unit<T1>::value_dimension.mass == details::is_pkr_unit<T2>::value_dimension.mass &&
                            details::is_pkr_unit<T1>::value_dimension.time == details::is_pkr_unit<T2>::value_dimension.time &&
                            details::is_pkr_unit<T1>::value_dimension.current == details::is_pkr_unit<T2>::value_dimension.current &&
                            details::is_pkr_unit<T1>::value_dimension.temperature == details::is_pkr_unit<T2>::value_dimension.temperature &&
                            details::is_pkr_unit<T1>::value_dimension.amount == details::is_pkr_unit<T2>::value_dimension.amount &&
                            details::is_pkr_unit<T1>::value_dimension.intensity == details::is_pkr_unit<T2>::value_dimension.intensity &&
                            details::is_pkr_unit<T1>::value_dimension.angle == details::is_pkr_unit<T2>::value_dimension.angle;

template <typename type_t, typename ratio_t, dimension_t dim_v>
constexpr details::unit_t<type_t, ratio_t, dim_v>
    operator+(const details::unit_t<type_t, ratio_t, dim_v>& lhs, const details::unit_t<type_t, ratio_t, dim_v>& rhs) noexcept
{
    return details::unit_t<type_t, ratio_t, dim_v>{lhs.value() + rhs.value()};
}

template <typename type_t, typename ratio_t1, typename ratio_t2, dimension_t dim_v>
    requires(!std::is_same_v<ratio_t1, ratio_t2>)
constexpr details::unit_t<type_t, ratio_t1, dim_v>
    operator+(const details::unit_t<type_t, ratio_t1, dim_v>& lhs, const details::unit_t<type_t, ratio_t2, dim_v>& rhs) noexcept
{
    type_t converted_rhs = details::convert_ratio_to<type_t, ratio_t2, ratio_t1>(rhs.value());
    return details::unit_t<type_t, ratio_t1, dim_v>{lhs.value() + converted_rhs};
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires(same_dimensions_c<T1, T2>)
constexpr auto operator+(const T1& lhs, const T2& rhs) noexcept
{

    if constexpr (is_derived_pkr_unit_c<T1> && is_derived_pkr_unit_c<T2>)
    {

        auto base_result = (static_cast<const typename T1::_base&>(lhs) + static_cast<const typename T2::_base&>(rhs));
        return T1{base_result.value()};
    }
    else if constexpr (is_derived_pkr_unit_c<T1> && !is_derived_pkr_unit_c<T2>)
    {

        auto base_result = (static_cast<const typename T1::_base&>(lhs) + rhs);
        return T1{base_result.value()};
    }
    else if constexpr (!is_derived_pkr_unit_c<T1> && is_derived_pkr_unit_c<T2>)
    {

        auto base_result = (lhs + static_cast<const typename T2::_base&>(rhs));
        return T2{base_result.value()};
    }
    else
    {

        if constexpr (std::is_same_v<T1, T2>)
        {
            return T1{lhs.value() + rhs.value()};
        }
        else
        {

            using value_type = typename details::is_pkr_unit<T1>::value_type;
            using lhs_ratio = typename details::is_pkr_unit<T1>::ratio_type;
            using rhs_ratio = typename details::is_pkr_unit<T2>::ratio_type;

            if constexpr (std::is_same_v<lhs_ratio, rhs_ratio>)
            {
                return T1{lhs.value() + rhs.value()};
            }
            else
            {
                value_type converted_rhs = details::convert_ratio_to<value_type, rhs_ratio, lhs_ratio>(rhs.value());
                return T1{lhs.value() + converted_rhs};
            }
        }
    }
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires(same_dimensions_c<T1, T2>)
constexpr auto operator-(const T1& lhs, const T2& rhs) noexcept
{
    if constexpr (is_derived_pkr_unit_c<T1> && is_derived_pkr_unit_c<T2>)
    {
        auto base_result = (static_cast<const typename T1::_base&>(lhs) - static_cast<const typename T2::_base&>(rhs));
        return T1{base_result.value()};
    }
    else if constexpr (is_derived_pkr_unit_c<T1> && !is_derived_pkr_unit_c<T2>)
    {
        auto base_result = (static_cast<const typename T1::_base&>(lhs) - rhs);
        return T1{base_result.value()};
    }
    else if constexpr (!is_derived_pkr_unit_c<T1> && is_derived_pkr_unit_c<T2>)
    {
        auto base_result = (lhs - static_cast<const typename T2::_base&>(rhs));
        return T2{base_result.value()};
    }
    else
    {
        if constexpr (std::is_same_v<T1, T2>)
        {
            return T1{lhs.value() - rhs.value()};
        }
        else
        {
            using value_type = typename details::is_pkr_unit<T1>::value_type;
            using lhs_ratio = typename details::is_pkr_unit<T1>::ratio_type;
            using rhs_ratio = typename details::is_pkr_unit<T2>::ratio_type;

            if constexpr (std::is_same_v<lhs_ratio, rhs_ratio>)
            {
                return T1{lhs.value() - rhs.value()};
            }
            else
            {
                value_type converted_rhs = details::convert_ratio_to<value_type, rhs_ratio, lhs_ratio>(rhs.value());
                return T1{lhs.value() - converted_rhs};
            }
        }
    }
}

template <is_pkr_unit_c T>
constexpr T operator-(const T& a) noexcept
{
    return T{-a.value()};
}

template <is_base_pkr_unit_c T1, is_base_pkr_unit_c T2>
constexpr auto operator*(const T1& lhs, const T2& rhs) noexcept
{

    using value_type = typename details::is_pkr_unit<T1>::value_type;
    using lhs_ratio = typename details::is_pkr_unit<T1>::ratio_type;
    using rhs_ratio = typename details::is_pkr_unit<T2>::ratio_type;
    constexpr auto dim1 = details::is_pkr_unit<T1>::value_dimension;
    constexpr auto dim2 = details::is_pkr_unit<T2>::value_dimension;

    constexpr dimension_t combined_dim{
        .length = dim1.length + dim2.length,
        .mass = dim1.mass + dim2.mass,
        .time = dim1.time + dim2.time,
        .current = dim1.current + dim2.current,
        .temperature = dim1.temperature + dim2.temperature,
        .amount = dim1.amount + dim2.amount,
        .intensity = dim1.intensity + dim2.intensity,
        .angle = dim1.angle + dim2.angle};

    using result_ratio = std::ratio_multiply<lhs_ratio, rhs_ratio>;
    using result_type = typename details::derived_unit_type_t<value_type, result_ratio, combined_dim>::type;
    return result_type{details::multiply_values(lhs.value(), rhs.value())};
}

template <is_base_pkr_unit_c T1, is_base_pkr_unit_c T2>
constexpr auto operator/(const T1& lhs, const T2& rhs) noexcept
{

    using value_type = typename details::is_pkr_unit<T1>::value_type;
    using lhs_ratio = typename details::is_pkr_unit<T1>::ratio_type;
    using rhs_ratio = typename details::is_pkr_unit<T2>::ratio_type;
    constexpr auto dim1 = details::is_pkr_unit<T1>::value_dimension;
    constexpr auto dim2 = details::is_pkr_unit<T2>::value_dimension;

    constexpr dimension_t combined_dim{
        .length = dim1.length - dim2.length,
        .mass = dim1.mass - dim2.mass,
        .time = dim1.time - dim2.time,
        .current = dim1.current - dim2.current,
        .temperature = dim1.temperature - dim2.temperature,
        .amount = dim1.amount - dim2.amount,
        .intensity = dim1.intensity - dim2.intensity,
        .angle = dim1.angle - dim2.angle};

    using result_ratio = std::ratio_divide<lhs_ratio, rhs_ratio>;
    using result_type = typename details::derived_unit_type_t<value_type, result_ratio, combined_dim>::type;
    return result_type{details::divide_values(lhs.value(), rhs.value())};
}

template <is_base_pkr_unit_c T, is_base_pkr_unit_c S>
    requires(details::is_pkr_unit<S>::value_dimension == scalar_dimension && details::is_pkr_unit<T>::value_dimension != scalar_dimension)
constexpr auto operator*(const T& lhs, const S& rhs) noexcept
{
    using value_type = typename details::is_pkr_unit<T>::value_type;
    using lhs_ratio = typename details::is_pkr_unit<T>::ratio_type;
    using rhs_ratio = typename details::is_pkr_unit<S>::ratio_type;
    constexpr auto dim1 = details::is_pkr_unit<T>::value_dimension;
    constexpr auto dim2 = details::is_pkr_unit<S>::value_dimension;

    constexpr dimension_t combined_dim{
        .length = dim1.length + dim2.length,
        .mass = dim1.mass + dim2.mass,
        .time = dim1.time + dim2.time,
        .current = dim1.current + dim2.current,
        .temperature = dim1.temperature + dim2.temperature,
        .amount = dim1.amount + dim2.amount,
        .intensity = dim1.intensity + dim2.intensity,
        .angle = dim1.angle + dim2.angle};

    value_type rhs_converted = details::convert_ratio_to<value_type, rhs_ratio, lhs_ratio>(rhs.value());
    using result_type = typename details::derived_unit_type_t<value_type, lhs_ratio, combined_dim>::type;
    return result_type{details::multiply_values(lhs.value(), rhs_converted)};
}

template <is_base_pkr_unit_c S, is_base_pkr_unit_c T>
    requires(details::is_pkr_unit<S>::value_dimension == scalar_dimension && details::is_pkr_unit<T>::value_dimension != scalar_dimension)
constexpr auto operator*(const S& lhs, const T& rhs) noexcept
{
    using value_type = typename details::is_pkr_unit<T>::value_type;
    using lhs_ratio = typename details::is_pkr_unit<S>::ratio_type;
    using rhs_ratio = typename details::is_pkr_unit<T>::ratio_type;
    constexpr auto dim1 = details::is_pkr_unit<S>::value_dimension;
    constexpr auto dim2 = details::is_pkr_unit<T>::value_dimension;

    constexpr dimension_t combined_dim{
        .length = dim1.length + dim2.length,
        .mass = dim1.mass + dim2.mass,
        .time = dim1.time + dim2.time,
        .current = dim1.current + dim2.current,
        .temperature = dim1.temperature + dim2.temperature,
        .amount = dim1.amount + dim2.amount,
        .intensity = dim1.intensity + dim2.intensity,
        .angle = dim1.angle + dim2.angle};

    value_type lhs_converted = details::convert_ratio_to<value_type, lhs_ratio, rhs_ratio>(lhs.value());
    using result_type = typename details::derived_unit_type_t<value_type, rhs_ratio, combined_dim>::type;
    return result_type{details::multiply_values(lhs_converted, rhs.value())};
}

template <is_base_pkr_unit_c T, is_base_pkr_unit_c S>
    requires(details::is_pkr_unit<S>::value_dimension == scalar_dimension && details::is_pkr_unit<T>::value_dimension != scalar_dimension)
constexpr auto operator/(const T& lhs, const S& rhs) noexcept
{
    using value_type = typename details::is_pkr_unit<T>::value_type;
    using lhs_ratio = typename details::is_pkr_unit<T>::ratio_type;
    using rhs_ratio = typename details::is_pkr_unit<S>::ratio_type;
    constexpr auto dim1 = details::is_pkr_unit<T>::value_dimension;
    constexpr auto dim2 = details::is_pkr_unit<S>::value_dimension;

    constexpr dimension_t result_dim{
        .length = dim1.length - dim2.length,
        .mass = dim1.mass - dim2.mass,
        .time = dim1.time - dim2.time,
        .current = dim1.current - dim2.current,
        .temperature = dim1.temperature - dim2.temperature,
        .amount = dim1.amount - dim2.amount,
        .intensity = dim1.intensity - dim2.intensity,
        .angle = dim1.angle - dim2.angle};

    value_type rhs_converted = details::convert_ratio_to<value_type, rhs_ratio, lhs_ratio>(rhs.value());
    using result_type = typename details::derived_unit_type_t<value_type, lhs_ratio, result_dim>::type;
    return result_type{details::divide_values(lhs.value(), rhs_converted)};
}

template <is_base_pkr_unit_c S, is_base_pkr_unit_c T>
    requires(details::is_pkr_unit<S>::value_dimension == scalar_dimension && details::is_pkr_unit<T>::value_dimension != scalar_dimension)
constexpr auto operator/(const S& lhs, const T& rhs) noexcept
{
    using value_type = typename details::is_pkr_unit<S>::value_type;
    using rhs_ratio = typename details::is_pkr_unit<T>::ratio_type;
    constexpr auto dim1 = details::is_pkr_unit<S>::value_dimension;
    constexpr auto dim2 = details::is_pkr_unit<T>::value_dimension;

    using inv_ratio = std::ratio_divide<std::ratio<1, 1>, rhs_ratio>;
    constexpr dimension_t inv_dim{
        .length = -dim2.length,
        .mass = -dim2.mass,
        .time = -dim2.time,
        .current = -dim2.current,
        .temperature = -dim2.temperature,
        .amount = -dim2.amount,
        .intensity = -dim2.intensity,
        .angle = -dim2.angle};

    using result_type = typename details::derived_unit_type_t<value_type, inv_ratio, inv_dim>::type;

    value_type rhs_canonical = details::convert_ratio_to<value_type, rhs_ratio, std::ratio<1, 1>>(rhs.value());
    return result_type{details::divide_values(lhs.value(), rhs_canonical)};
}

template <typename T, typename ScalarType>
    requires(is_base_pkr_unit_c<T> && scalar_value_c<ScalarType>)
constexpr auto operator/(const T& unit, const ScalarType& scalar) noexcept
{
    using value_type = typename details::is_pkr_unit<T>::value_type;
    using ratio_type = typename details::is_pkr_unit<T>::ratio_type;
    constexpr auto dim = details::is_pkr_unit<T>::value_dimension;

    using result_type = typename details::derived_unit_type_t<value_type, ratio_type, dim>::type;

    return result_type(details::divide_values<value_type>(unit.value(), static_cast<value_type>(scalar)));
}

template <typename ScalarType, typename T>

    requires(is_base_pkr_unit_c<T> && scalar_value_c<ScalarType>)
constexpr auto operator*(const ScalarType& scalar, const T& unit) noexcept
{
    using value_type = typename details::is_pkr_unit<T>::value_type;
    using ratio_type = typename details::is_pkr_unit<T>::ratio_type;
    constexpr auto dim = details::is_pkr_unit<T>::value_dimension;

    using result_type = typename details::derived_unit_type_t<value_type, ratio_type, dim>::type;

    return result_type(details::multiply_values<value_type>(static_cast<value_type>(scalar), unit.value()));
}

template <typename ScalarType, typename T>

    requires(is_base_pkr_unit_c<T> && scalar_value_c<ScalarType>)
constexpr auto operator/(const ScalarType& scalar, const T& unit)
{
    using value_type = typename details::is_pkr_unit<T>::value_type;
    using ratio_type = typename details::is_pkr_unit<T>::ratio_type;
    constexpr auto dim = details::is_pkr_unit<T>::value_dimension;

    constexpr dimension_t inverted_dim{
        .length = -dim.length,
        .mass = -dim.mass,
        .time = -dim.time,
        .current = -dim.current,
        .temperature = -dim.temperature,
        .amount = -dim.amount,
        .intensity = -dim.intensity,
        .angle = -dim.angle};

    using inverted_ratio = std::ratio_divide<std::ratio<1, 1>, ratio_type>;

    using result_type = typename details::derived_unit_type_t<value_type, inverted_ratio, inverted_dim>::type;

    return result_type(details::divide_values<value_type>(static_cast<value_type>(scalar), unit.value()));
}

template <typename ScalarType, typename T>
    requires(is_derived_pkr_unit_c<T> && scalar_value_c<ScalarType>)
constexpr auto operator*(const ScalarType& scalar, const T& unit) noexcept
{
    using base_type = typename T::_base;

    auto base_result = scalar * static_cast<const base_type&>(unit);
    return T{base_result.value()};
}

template <typename T, typename ScalarType>
    requires(is_derived_pkr_unit_c<T> && scalar_value_c<ScalarType>)
constexpr auto operator*(const T& unit, const ScalarType& scalar) noexcept
{
    return scalar * unit;
}

template <typename ScalarType, typename T>
    requires(is_derived_pkr_unit_c<T> && scalar_value_c<ScalarType>)
constexpr auto operator/(const ScalarType& scalar, const T& unit) noexcept
{
    using base_type = typename T::_base;

    auto base_result = scalar / static_cast<const base_type&>(unit);

    return base_result;
}

template <typename T, typename ScalarType>
    requires(is_derived_pkr_unit_c<T> && scalar_value_c<ScalarType>)
constexpr auto operator/(const T& unit, const ScalarType& scalar) noexcept
{
    using value_type = typename details::is_pkr_unit<T>::value_type;
    using ratio_type = typename details::is_pkr_unit<T>::ratio_type;
    constexpr auto dim = details::is_pkr_unit<T>::value_dimension;

    using result_type = typename details::derived_unit_type_t<value_type, ratio_type, dim>::type;
    return result_type(details::divide_values<value_type>(unit.value(), static_cast<value_type>(scalar)));
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>

constexpr bool operator==(const T1& lhs, const T2& rhs) noexcept
{
    auto to_canonical = [](const auto& unit)
    {
        using unit_type = std::remove_cvref_t<decltype(unit)>;
        using actual_type = std::conditional_t<is_derived_pkr_unit_c<unit_type>, typename unit_type::_base, unit_type>;
        using ratio_type = typename details::is_pkr_unit<actual_type>::ratio_type;

        if constexpr (is_derived_pkr_unit_c<unit_type>)
        {
            const auto& base_unit = static_cast<const actual_type&>(unit);
            return static_cast<double>(base_unit.value()) * (static_cast<double>(ratio_type::num) / static_cast<double>(ratio_type::den));
        }
        else
        {
            return static_cast<double>(unit.value()) * (static_cast<double>(ratio_type::num) / static_cast<double>(ratio_type::den));
        }
    };
    return to_canonical(lhs) == to_canonical(rhs);
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>

constexpr bool operator!=(const T1& lhs, const T2& rhs) noexcept
{
    return !(lhs == rhs);
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>

constexpr bool operator<(const T1& lhs, const T2& rhs) noexcept
{
    auto to_canonical = [](const auto& unit)
    {
        using unit_type = std::remove_cvref_t<decltype(unit)>;
        using actual_type = std::conditional_t<is_derived_pkr_unit_c<unit_type>, typename unit_type::_base, unit_type>;
        using ratio_type = typename details::is_pkr_unit<actual_type>::ratio_type;

        if constexpr (is_derived_pkr_unit_c<unit_type>)
        {
            const auto& base_unit = static_cast<const actual_type&>(unit);
            return static_cast<double>(base_unit.value()) * (static_cast<double>(ratio_type::num) / static_cast<double>(ratio_type::den));
        }
        else
        {
            return static_cast<double>(unit.value()) * (static_cast<double>(ratio_type::num) / static_cast<double>(ratio_type::den));
        }
    };
    return to_canonical(lhs) < to_canonical(rhs);
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>

constexpr bool operator<=(const T1& lhs, const T2& rhs) noexcept
{
    return lhs < rhs || lhs == rhs;
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>

constexpr bool operator>(const T1& lhs, const T2& rhs) noexcept
{
    return !(lhs <= rhs);
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>

constexpr bool operator>=(const T1& lhs, const T2& rhs) noexcept
{
    return !(lhs < rhs);
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>

constexpr auto operator<=>(const T1& lhs, const T2& rhs) noexcept
{
    auto to_canonical = [](const auto& unit)
    {
        using unit_type = std::remove_cvref_t<decltype(unit)>;
        using actual_type = std::conditional_t<is_derived_pkr_unit_c<unit_type>, typename unit_type::_base, unit_type>;
        using ratio_type = typename details::is_pkr_unit<actual_type>::ratio_type;

        if constexpr (is_derived_pkr_unit_c<unit_type>)
        {
            const auto& base_unit = static_cast<const actual_type&>(unit);
            return static_cast<double>(base_unit.value()) * (static_cast<double>(ratio_type::num) / static_cast<double>(ratio_type::den));
        }
        else
        {
            return static_cast<double>(unit.value()) * (static_cast<double>(ratio_type::num) / static_cast<double>(ratio_type::den));
        }
    };
    return to_canonical(lhs) <=> to_canonical(rhs);
}
}

namespace pkr::units
{
inline constexpr dimension_t angle_dimension{0, 0, 0, 0, 0, 0, 0, 1};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using angle_unit_t = details::unit_t<type_t, ratio_t, angle_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct hms_archour_t final : public details::unit_t<T, std::ratio<26179935, 100000000>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<26179935, 100000000>, angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hms_archour"};
    [[maybe_unused]] static constexpr std::string_view symbol{"h"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ʰ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"h"};
};

template <is_unit_value_type_c T>
hms_archour_t(T) -> hms_archour_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
hms_archour_t(const U&) -> hms_archour_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hms_arcminute_t final : public details::unit_t<T, std::ratio<26179935, 6000000000>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<26179935, 6000000000>, angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hms_arcminute"};
    [[maybe_unused]] static constexpr std::string_view symbol{"m"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ᵐ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ᵐ"};
};

template <is_unit_value_type_c T>
hms_arcminute_t(T) -> hms_arcminute_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
hms_arcminute_t(const U&) -> hms_arcminute_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hms_arcsecond_t final : public details::unit_t<T, std::ratio<26179935, 360000000000>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<26179935, 360000000000>, angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hms_arcsecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ˢ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ˢ"};
};

template <is_unit_value_type_c T>
hms_arcsecond_t(T) -> hms_arcsecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
hms_arcsecond_t(const U&) -> hms_arcsecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct dms_degree_t final : public details::unit_t<T, std::ratio<1745329, 100000000>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<1745329, 100000000>, angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"dms_degree"};
    [[maybe_unused]] static constexpr std::string_view symbol{"deg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"°"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"deg"};
};

template <is_unit_value_type_c T>
dms_degree_t(T) -> dms_degree_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
dms_degree_t(const U&) -> dms_degree_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct dms_arcminute_t final : public details::unit_t<T, std::ratio<1745329, 6000000000>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<1745329, 6000000000>, angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"dms_arcminute"};
    [[maybe_unused]] static constexpr std::string_view symbol{"m"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ᵐ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ᵐ"};
};

template <is_unit_value_type_c T>
dms_arcminute_t(T) -> dms_arcminute_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
dms_arcminute_t(const U&) -> dms_arcminute_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct dms_arcsecond_t final : public details::unit_t<T, std::ratio<1745329, 360000000000>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<1745329, 360000000000>, angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"dms_arcsecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ˢ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ˢ"};
};

template <is_unit_value_type_c T>
dms_arcsecond_t(T) -> dms_arcsecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
dms_arcsecond_t(const U&) -> dms_arcsecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hms_angle_t final : public details::unit_t<T, std::ratio<1, 1>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, angle_dimension>;
    using _base::_base;
};

template <is_unit_value_type_c T>
hms_angle_t(T) -> hms_angle_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
hms_angle_t(const U&) -> hms_angle_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct dms_angle_t final : public details::unit_t<T, std::ratio<1, 1>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, angle_dimension>;
    using _base::_base;
};

template <is_unit_value_type_c T>
dms_angle_t(T) -> dms_angle_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
dms_angle_t(const U&) -> dms_angle_t<typename details::is_pkr_unit<U>::value_type>;

}

namespace pkr::units
{

inline constexpr dimension_t length_dimension{1, 0, 0, 0, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using length_unit_t = details::unit_t<type_t, ratio_t, length_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct micron_t final : public details::unit_t<T, std::micro, length_dimension>
{
    using _base = details::unit_t<T, std::micro, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"micron"};
    [[maybe_unused]] static constexpr std::string_view symbol{"um"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5m"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5m"};
};

template <is_unit_value_type_c T>
micron_t(T) -> micron_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
micron_t(const U&) -> micron_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct angstrom_t final : public details::unit_t<T, std::ratio<1, 10000000000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 10000000000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"angstrom"};
    [[maybe_unused]] static constexpr std::string_view symbol{"A"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00C5"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00C5"};
};

template <is_unit_value_type_c T>
angstrom_t(T) -> angstrom_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
angstrom_t(const U&) -> angstrom_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct au_t final : public details::unit_t<T, std::ratio<149597870700, 1>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<149597870700, 1>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"astronomical_unit"};
    [[maybe_unused]] static constexpr std::string_view symbol{"au"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"au"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"au"};
};

template <is_unit_value_type_c T>
au_t(T) -> au_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
au_t(const U&) -> au_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct light_year_t final : public details::unit_t<T, std::ratio<94607304725808000, 1>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<94607304725808000, 1>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"light_year"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ly"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ly"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ly"};
};

template <is_unit_value_type_c T>
light_year_t(T) -> light_year_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
light_year_t(const U&) -> light_year_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct parsec_t final : public details::unit_t<T, std::ratio<30856775814913673, 1>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<30856775814913673, 1>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"parsec"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pc"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pc"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pc"};
};

template <is_unit_value_type_c T>
parsec_t(T) -> parsec_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
parsec_t(const U&) -> parsec_t<typename details::is_pkr_unit<U>::value_type>;
}

namespace pkr::units
{

namespace details
{

template <typename type_t>
constexpr type_t compute_conversion_factor(long long source_num, long long source_den, long long target_num, long long target_den) noexcept
{
    return (static_cast<type_t>(source_num) * static_cast<type_t>(target_den)) / (static_cast<type_t>(source_den) * static_cast<type_t>(target_num));
}

template <typename target_ratio_t, typename type_t, typename source_ratio_t, dimension_t dim_v>
constexpr details::unit_t<type_t, target_ratio_t, dim_v> unit_cast_impl(const details::unit_t<type_t, source_ratio_t, dim_v>& source) noexcept
{
    if constexpr (std::is_same_v<source_ratio_t, target_ratio_t>)
    {

        return source;
    }
    else
    {

        constexpr type_t conversion_factor =
            compute_conversion_factor<type_t>(source_ratio_t::num, source_ratio_t::den, target_ratio_t::num, target_ratio_t::den);
        type_t converted_value = source.value() * conversion_factor;
        return details::unit_t<type_t, target_ratio_t, dim_v>(converted_value);
    }
}

template <typename Target, typename Source>
concept same_dimension_si_units = details::is_pkr_unit<Target>::value_dimension == details::is_pkr_unit<Source>::value_dimension;
}

template <typename target_type_t, typename target_ratio_t, dimension_t target_dim_v, typename source_type_t, typename source_ratio_t, dimension_t source_dim_v>
    requires(target_dim_v == source_dim_v)
constexpr details::unit_t<target_type_t, target_ratio_t, target_dim_v>
    unit_cast(const details::unit_t<source_type_t, source_ratio_t, source_dim_v>& source) noexcept
{
    return details::unit_cast_impl<target_ratio_t>(source);
}

template <typename target_unit_t, typename source_unit_t>
    requires std::is_base_of_v<typename target_unit_t::_base, target_unit_t> && std::is_base_of_v<typename source_unit_t::_base, source_unit_t> &&
             (details::is_pkr_unit<target_unit_t>::value_dimension == details::is_pkr_unit<source_unit_t>::value_dimension)
constexpr target_unit_t unit_cast(const source_unit_t& source) noexcept
{
    using target_ratio = typename details::is_pkr_unit<target_unit_t>::ratio_type;

    auto converted = details::unit_cast_impl<target_ratio>(source);
    return target_unit_t(converted.value());
}

}

namespace std
{
template <typename UnitT, typename CharT>
struct hms_component_formatter
{
    std::formatter<typename UnitT::value_type, CharT> value_formatter;

    template <typename ParseContext>
    constexpr auto parse(ParseContext& ctx)
    {
        return value_formatter.parse(ctx);
    }

    template <typename FormatContext>
    auto format(const UnitT& value, FormatContext& ctx) const
    {
        auto out = ctx.out();
        out = value_formatter.format(value.value(), ctx);
        if constexpr (std::is_same_v<CharT, char>)
        {
            return std::copy(UnitT::symbol.begin(), UnitT::symbol.end(), out);
        }
        else if constexpr (std::is_same_v<CharT, wchar_t>)
        {
            return std::copy(UnitT::w_symbol.begin(), UnitT::w_symbol.end(), out);
        }
        else
        {
            static_assert(std::is_same_v<CharT, char> || std::is_same_v<CharT, wchar_t>, "UTF-8 formatting is not supported for astronomical angle units");
            return out;
        }
    }
};

template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::hms_archour_t<T>, CharT> : hms_component_formatter<pkr::units::hms_archour_t<T>, CharT>
{
};

template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::hms_arcminute_t<T>, CharT> : hms_component_formatter<pkr::units::hms_arcminute_t<T>, CharT>
{
};

template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::hms_arcsecond_t<T>, CharT> : hms_component_formatter<pkr::units::hms_arcsecond_t<T>, CharT>
{
};

template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::dms_degree_t<T>, CharT> : hms_component_formatter<pkr::units::dms_degree_t<T>, CharT>
{
};

template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::dms_arcminute_t<T>, CharT> : hms_component_formatter<pkr::units::dms_arcminute_t<T>, CharT>
{
};

template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::dms_arcsecond_t<T>, CharT> : hms_component_formatter<pkr::units::dms_arcsecond_t<T>, CharT>
{
};

template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::hms_angle_t<T>, CharT>
{
    template <typename ParseContext>
    constexpr auto parse(ParseContext& ctx)
    {
        auto it = ctx.begin();
        auto end = ctx.end();
        while (it != end && *it != static_cast<CharT>('}'))
        {
            ++it;
        }
        return it;
    }

    template <typename FormatContext>
    auto format(const pkr::units::hms_angle_t<T>& value, FormatContext& ctx) const
    {
        using archour_ratio = typename pkr::units::details::is_pkr_unit<pkr::units::hms_archour_t<T>>::ratio_type;
        T hours_value = pkr::units::details::convert_ratio_to<double, std::ratio<1, 1>, archour_ratio>(value.value());
        bool negative = hours_value < 0.0;
        T total_seconds = std::abs(hours_value) * T{3600.0};
        int hours = static_cast<int>(total_seconds / T{3600.0});
        T remainder = total_seconds - static_cast<T>(hours) * T{3600.0};
        int minutes = static_cast<int>(remainder / T{60.0});
        T seconds = remainder - static_cast<T>(minutes) * T{60.0};
        long long seconds_rounded = std::llround(seconds);
        if (seconds_rounded >= 60)
        {
            seconds_rounded = 0;
            ++minutes;
            if (minutes >= 60)
            {
                minutes = 0;
                ++hours;
            }
        }
        auto out = ctx.out();
        if (negative)
        {
            *out++ = static_cast<CharT>('-');
        }
        if constexpr (std::is_same_v<CharT, char>)
        {
            out = std::format_to(out, "{}", pkr::units::hms_archour_t<T>{static_cast<T>(hours)});
            *out++ = ' ';
            out = std::format_to(out, "{}", pkr::units::hms_arcminute_t<T>{static_cast<T>(minutes)});
            *out++ = ' ';
        }
        else if constexpr (std::is_same_v<CharT, wchar_t>)
        {
            out = std::format_to(out, L"{}", pkr::units::hms_archour_t<T>{static_cast<T>(hours)});
            out = std::format_to(out, L"{}", pkr::units::hms_arcminute_t<T>{static_cast<T>(minutes)});
        }
        else
        {
            static_assert(std::is_same_v<CharT, char> || std::is_same_v<CharT, wchar_t>, "UTF-8 formatting is not supported for astronomical angle units");
        }
        if constexpr (std::is_same_v<CharT, char>)
        {
            return std::format_to(out, "{}", pkr::units::hms_arcsecond_t<T>{static_cast<T>(seconds_rounded)});
        }
        else if constexpr (std::is_same_v<CharT, wchar_t>)
        {
            return std::format_to(out, L"{}", pkr::units::hms_arcsecond_t<T>{static_cast<T>(seconds_rounded)});
        }
        else
        {
            return out;
        }
    }
};

template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::dms_angle_t<T>, CharT>
{
    template <typename ParseContext>
    constexpr auto parse(ParseContext& ctx)
    {
        auto it = ctx.begin();
        auto end = ctx.end();
        while (it != end && *it != static_cast<CharT>('}'))
        {
            ++it;
        }
        return it;
    }

    template <typename FormatContext>
    auto format(const pkr::units::dms_angle_t<T>& value, FormatContext& ctx) const
    {
        using degree_ratio = typename pkr::units::details::is_pkr_unit<pkr::units::dms_degree_t<T>>::ratio_type;
        double degrees_value = pkr::units::details::convert_ratio_to<T, std::ratio<1, 1>, degree_ratio>(value.value());
        bool negative = degrees_value < T{0.0};
        double total_seconds = std::abs(degrees_value) * T{3600.0};
        int degrees = static_cast<int>(total_seconds / T{3600.0});
        double remainder = total_seconds - static_cast<T>(degrees) * T{3600.0};
        int minutes = static_cast<int>(remainder / T{60.0});
        double seconds = remainder - static_cast<T>(minutes) * T{60.0};
        long long seconds_rounded = std::llround(seconds);
        if (seconds_rounded >= 60)
        {
            seconds_rounded = 0;
            ++minutes;
            if (minutes >= 60)
            {
                minutes = 0;
                ++degrees;
            }
        }
        auto out = ctx.out();
        if (negative)
        {
            *out++ = static_cast<CharT>('-');
        }
        if constexpr (std::is_same_v<CharT, char>)
        {
            out = std::format_to(out, "{}", pkr::units::dms_degree_t<T>{static_cast<T>(degrees)});
            *out++ = ' ';
            out = std::format_to(out, "{}", pkr::units::dms_arcminute_t<T>{static_cast<T>(minutes)});
            *out++ = ' ';
        }
        else if constexpr (std::is_same_v<CharT, wchar_t>)
        {
            out = std::format_to(out, L"{}", pkr::units::dms_degree_t<T>{static_cast<T>(degrees)});
            out = std::format_to(out, L"{}", pkr::units::dms_arcminute_t<T>{static_cast<T>(minutes)});
        }
        else
        {
            static_assert(std::is_same_v<CharT, char> || std::is_same_v<CharT, wchar_t>, "UTF-8 formatting is not supported for astronomical angle units");
        }
        if constexpr (std::is_same_v<CharT, char>)
        {
            return std::format_to(out, "{}", pkr::units::dms_arcsecond_t<T>{static_cast<T>(seconds_rounded)});
        }
        else if constexpr (std::is_same_v<CharT, wchar_t>)
        {
            return std::format_to(out, L"{}", pkr::units::dms_arcsecond_t<T>{static_cast<T>(seconds_rounded)});
        }
        else
        {
            return out;
        }
    }
};
}

namespace pkr::units
{

inline constexpr dimension_t acceleration_v{1, 0, -2, 0, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using acceleration_unit_t = details::unit_t<type_t, ratio_t, acceleration_v>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct gal_t final : public details::unit_t<T, std::ratio<1, 100>, acceleration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 100>, acceleration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gal"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Gal"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Gal"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Gal"};
};

template <is_unit_value_type_c T>
gal_t(T) -> gal_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == acceleration_v)
gal_t(const U&) -> gal_t<typename details::is_pkr_unit<U>::value_type>;
}

namespace pkr::units
{

inline constexpr dimension_t dynamic_viscosity_dimension{-1, 1, -1, 0, 0, 0, 0, 0};

inline constexpr dimension_t kinematic_viscosity_dimension{2, 0, -1, 0, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using dynamic_viscosity_unit_t = details::unit_t<type_t, ratio_t, dynamic_viscosity_dimension>;

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using kinematic_viscosity_unit_t = details::unit_t<type_t, ratio_t, kinematic_viscosity_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct poise_t final : public details::unit_t<T, std::ratio<1, 10>, dynamic_viscosity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 10>, dynamic_viscosity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"poise"};
    [[maybe_unused]] static constexpr std::string_view symbol{"P"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"P"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"P"};
};

template <is_unit_value_type_c T>
poise_t(T) -> poise_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == dynamic_viscosity_dimension)
poise_t(const U&) -> poise_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct stokes_t final : public details::unit_t<T, std::ratio<1, 10000>, kinematic_viscosity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 10000>, kinematic_viscosity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"stokes"};
    [[maybe_unused]] static constexpr std::string_view symbol{"St"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"St"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"St"};
};

template <is_unit_value_type_c T>
stokes_t(T) -> stokes_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == kinematic_viscosity_dimension)
stokes_t(const U&) -> stokes_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 10>, dynamic_viscosity_dimension>
{
    using type = poise_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 10000>, kinematic_viscosity_dimension>
{
    using type = stokes_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t electric_charge_dimension{0, 0, 1, 1, 0, 0, 0, 0};

template <is_unit_value_type_c T>
struct coulomb_t final : public details::unit_t<T, std::ratio<1, 1>, electric_charge_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, electric_charge_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"coulomb"};
    [[maybe_unused]] static constexpr std::string_view symbol{"C"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"C"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"C"};
};

template <is_unit_value_type_c T>
coulomb_t(T) -> coulomb_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_charge_dimension)
coulomb_t(const U&) -> coulomb_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilocoulomb_t final : public details::unit_t<T, std::ratio<1000, 1>, electric_charge_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, electric_charge_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilocoulomb"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kC"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kC"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kC"};
};

template <is_unit_value_type_c T>
kilocoulomb_t(T) -> kilocoulomb_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_charge_dimension)
kilocoulomb_t(const U&) -> kilocoulomb_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millicoulomb_t final : public details::unit_t<T, std::ratio<1, 1000>, electric_charge_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, electric_charge_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millicoulomb"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mC"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mC"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mC"};
};

template <is_unit_value_type_c T>
millicoulomb_t(T) -> millicoulomb_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_charge_dimension)
millicoulomb_t(const U&) -> millicoulomb_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microcoulomb_t final : public details::unit_t<T, std::ratio<1, 1000000>, electric_charge_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, electric_charge_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microcoulomb"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uC"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5C"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5C"};
};

template <is_unit_value_type_c T>
microcoulomb_t(T) -> microcoulomb_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_charge_dimension)
microcoulomb_t(const U&) -> microcoulomb_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanocoulomb_t final : public details::unit_t<T, std::ratio<1, 1000000000>, electric_charge_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, electric_charge_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanocoulomb"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nC"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nC"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nC"};
};

template <is_unit_value_type_c T>
nanocoulomb_t(T) -> nanocoulomb_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_charge_dimension)
nanocoulomb_t(const U&) -> nanocoulomb_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct picocoulomb_t final : public details::unit_t<T, std::ratio<1, 1000000000000>, electric_charge_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000000>, electric_charge_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picocoulomb"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pC"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pC"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pC"};
};

template <is_unit_value_type_c T>
picocoulomb_t(T) -> picocoulomb_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_charge_dimension)
picocoulomb_t(const U&) -> picocoulomb_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, electric_charge_dimension>
{
    using type = coulomb_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, electric_charge_dimension>
{
    using type = kilocoulomb_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, electric_charge_dimension>
{
    using type = millicoulomb_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, electric_charge_dimension>
{
    using type = microcoulomb_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000>, electric_charge_dimension>
{
    using type = nanocoulomb_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000000>, electric_charge_dimension>
{
    using type = picocoulomb_t<T>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct statcoulomb_t final : public details::unit_t<T, std::ratio<1, 2997924580>, electric_charge_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 2997924580>, electric_charge_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"statcoulomb"};
    [[maybe_unused]] static constexpr std::string_view symbol{"statC"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"statC"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"statC"};
};

template <is_unit_value_type_c T>
statcoulomb_t(T) -> statcoulomb_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_charge_dimension)
statcoulomb_t(const U&) -> statcoulomb_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 2997924580>, electric_charge_dimension>
{
    using type = statcoulomb_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t force_dimension{1, 1, -2, 0, 0, 0, 0, 0};

using namespace_force_units_detail = int;

template <is_unit_value_type_c T>
struct newton_t final : public details::unit_t<T, std::ratio<1, 1>, force_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, force_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"newton"};
    [[maybe_unused]] static constexpr std::string_view symbol{"N"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"N"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"N"};
};

template <is_unit_value_type_c T>
newton_t(T) -> newton_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == force_dimension)
newton_t(const U&) -> newton_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilonewton_t final : public details::unit_t<T, std::ratio<1000, 1>, force_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, force_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilonewton"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kN"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kN"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kN"};
};

template <is_unit_value_type_c T>
kilonewton_t(T) -> kilonewton_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == force_dimension)
kilonewton_t(const U&) -> kilonewton_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct meganewton_t final : public details::unit_t<T, std::ratio<1000000, 1>, force_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, force_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"meganewton"};
    [[maybe_unused]] static constexpr std::string_view symbol{"MN"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"MN"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"MN"};
};

template <is_unit_value_type_c T>
meganewton_t(T) -> meganewton_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == force_dimension)
meganewton_t(const U&) -> meganewton_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct micronewton_t final : public details::unit_t<T, std::ratio<1, 1000000>, force_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, force_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"micronewton"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uN"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5N"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5N"};
};

template <is_unit_value_type_c T>
micronewton_t(T) -> micronewton_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == force_dimension)
micronewton_t(const U&) -> micronewton_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millinewton_t final : public details::unit_t<T, std::ratio<1, 1000>, force_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, force_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millinewton"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mN"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mN"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mN"};
};

template <is_unit_value_type_c T>
millinewton_t(T) -> millinewton_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == force_dimension)
millinewton_t(const U&) -> millinewton_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanonewton_t final : public details::unit_t<T, std::ratio<1, 1000000000>, force_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, force_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanonewton"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nN"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nN"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nN"};
};

template <is_unit_value_type_c T>
nanonewton_t(T) -> nanonewton_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == force_dimension)
nanonewton_t(const U&) -> nanonewton_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, force_dimension>
{
    using type = newton_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, force_dimension>
{
    using type = kilonewton_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 1>, force_dimension>
{
    using type = meganewton_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, force_dimension>
{
    using type = micronewton_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, force_dimension>
{
    using type = millinewton_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000>, force_dimension>
{
    using type = nanonewton_t<T>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct dyne_t final : public details::unit_t<T, std::ratio<1, 100000>, force_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 100000>, force_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"dyne"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dyn"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dyn"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dyn"};
};

template <is_unit_value_type_c T>
dyne_t(T) -> dyne_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == force_dimension)
dyne_t(const U&) -> dyne_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 100000>, force_dimension>
{
    using type = dyne_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t energy_dimension{2, 1, -2, 0, 0, 0, 0, 0};

template <is_unit_value_type_c T>
struct joule_t final : public details::unit_t<T, std::ratio<1, 1>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"joule"};
    [[maybe_unused]] static constexpr std::string_view symbol{"J"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"J"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"J"};
};

template <is_unit_value_type_c T>
joule_t(T) -> joule_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
joule_t(const U&) -> joule_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilojoule_t final : public details::unit_t<T, std::ratio<1000, 1>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilojoule"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kJ"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kJ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kJ"};
};

template <is_unit_value_type_c T>
kilojoule_t(T) -> kilojoule_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
kilojoule_t(const U&) -> kilojoule_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megajoule_t final : public details::unit_t<T, std::ratio<1000000, 1>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megajoule"};
    [[maybe_unused]] static constexpr std::string_view symbol{"MJ"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"MJ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"MJ"};
};

template <is_unit_value_type_c T>
megajoule_t(T) -> megajoule_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
megajoule_t(const U&) -> megajoule_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gigajoule_t final : public details::unit_t<T, std::ratio<1000000000, 1>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000000, 1>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigajoule"};
    [[maybe_unused]] static constexpr std::string_view symbol{"GJ"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"GJ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"GJ"};
};

template <is_unit_value_type_c T>
gigajoule_t(T) -> gigajoule_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
gigajoule_t(const U&) -> gigajoule_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microjoule_t final : public details::unit_t<T, std::ratio<1, 1000000>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microjoule"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uJ"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5J"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5J"};
};

template <is_unit_value_type_c T>
microjoule_t(T) -> microjoule_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
microjoule_t(const U&) -> microjoule_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millijoule_t final : public details::unit_t<T, std::ratio<1, 1000>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millijoule"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mJ"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mJ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mJ"};
};

template <is_unit_value_type_c T>
millijoule_t(T) -> millijoule_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
millijoule_t(const U&) -> millijoule_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanojoule_t final : public details::unit_t<T, std::ratio<1, 1000000000>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanojoule"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nJ"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nJ"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nJ"};
};

template <is_unit_value_type_c T>
nanojoule_t(T) -> nanojoule_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
nanojoule_t(const U&) -> nanojoule_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct calorie_t final : public details::unit_t<T, std::ratio<4184, 1000>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<4184, 1000>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"calorie"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cal"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cal"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cal"};
};

template <is_unit_value_type_c T>
calorie_t(T) -> calorie_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
calorie_t(const U&) -> calorie_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilocalorie_t final : public details::unit_t<T, std::ratio<4184, 1>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<4184, 1>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilocalorie"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kcal"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kcal"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kcal"};
};

template <is_unit_value_type_c T>
kilocalorie_t(T) -> kilocalorie_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
kilocalorie_t(const U&) -> kilocalorie_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct watt_hour_t final : public details::unit_t<T, std::ratio<3600, 1>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<3600, 1>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"watt_hour"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Wh"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Wh"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Wh"};
};

template <is_unit_value_type_c T>
watt_hour_t(T) -> watt_hour_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
watt_hour_t(const U&) -> watt_hour_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilowatt_hour_t final : public details::unit_t<T, std::ratio<3600000, 1>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<3600000, 1>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilowatt_hour"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kWh"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kWh"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kWh"};
};

template <is_unit_value_type_c T>
kilowatt_hour_t(T) -> kilowatt_hour_t<T>;

template <is_unit_value_type_c T>
struct electronvolt_t final : public details::unit_t<T, std::ratio<1, 6241509074460762607>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 6241509074460762607>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"electronvolt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"eV"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"eV"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"eV"};
};

template <is_unit_value_type_c T>
electronvolt_t(T) -> electronvolt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
electronvolt_t(const U&) -> electronvolt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kiloelectronvolt_t final : public details::unit_t<T, std::ratio<1000, 6241509074460762607>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 6241509074460762607>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kiloelectronvolt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"keV"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"keV"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"keV"};
};

template <is_unit_value_type_c T>
kiloelectronvolt_t(T) -> kiloelectronvolt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
kiloelectronvolt_t(const U&) -> kiloelectronvolt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megaelectronvolt_t final : public details::unit_t<T, std::ratio<1000000, 6241509074460762607>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 6241509074460762607>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megaelectronvolt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"MeV"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"MeV"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"MeV"};
};

template <is_unit_value_type_c T>
megaelectronvolt_t(T) -> megaelectronvolt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
megaelectronvolt_t(const U&) -> megaelectronvolt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gigaelectronvolt_t final : public details::unit_t<T, std::ratio<1000000000, 6241509074460762607>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000000, 6241509074460762607>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigaelectronvolt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"GeV"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"GeV"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"GeV"};
};

template <is_unit_value_type_c T>
gigaelectronvolt_t(T) -> gigaelectronvolt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
gigaelectronvolt_t(const U&) -> gigaelectronvolt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, energy_dimension>
{
    using type = joule_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, energy_dimension>
{
    using type = kilojoule_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 1>, energy_dimension>
{
    using type = megajoule_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000000, 1>, energy_dimension>
{
    using type = gigajoule_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, energy_dimension>
{
    using type = microjoule_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, energy_dimension>
{
    using type = millijoule_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000>, energy_dimension>
{
    using type = nanojoule_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<4184, 1000>, energy_dimension>
{
    using type = calorie_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<4184, 1>, energy_dimension>
{
    using type = kilocalorie_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<3600, 1>, energy_dimension>
{
    using type = watt_hour_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<3600000, 1>, energy_dimension>
{
    using type = kilowatt_hour_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 6241509074460762607>, energy_dimension>
{
    using type = electronvolt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 6241509074460762607>, energy_dimension>
{
    using type = kiloelectronvolt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 6241509074460762607>, energy_dimension>
{
    using type = megaelectronvolt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000000, 6241509074460762607>, energy_dimension>
{
    using type = gigaelectronvolt_t<T>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct erg_t final : public details::unit_t<T, std::ratio<1, 10000000>, energy_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 10000000>, energy_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"erg"};
    [[maybe_unused]] static constexpr std::string_view symbol{"erg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"erg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"erg"};
};

template <is_unit_value_type_c T>
erg_t(T) -> erg_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == energy_dimension)
erg_t(const U&) -> erg_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 10000000>, energy_dimension>
{
    using type = erg_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t pressure_dimension{-1, 1, -2, 0, 0, 0, 0, 0};

template <is_unit_value_type_c T>
struct pascal_t final : public details::unit_t<T, std::ratio<1, 1>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"pascal"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Pa"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Pa"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Pa"};
};

template <is_unit_value_type_c T>
pascal_t(T) -> pascal_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
pascal_t(const U&) -> pascal_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilopascal_t final : public details::unit_t<T, std::ratio<1000, 1>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilopascal"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kPa"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kPa"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kPa"};
};

template <is_unit_value_type_c T>
kilopascal_t(T) -> kilopascal_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
kilopascal_t(const U&) -> kilopascal_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hectopascal_t final : public details::unit_t<T, std::ratio<100, 1>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<100, 1>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hectopascal"};
    [[maybe_unused]] static constexpr std::string_view symbol{"hPa"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"hPa"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"hPa"};
};

template <is_unit_value_type_c T>
hectopascal_t(T) -> hectopascal_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
hectopascal_t(const U&) -> hectopascal_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megapascal_t final : public details::unit_t<T, std::ratio<1000000, 1>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megapascal"};
    [[maybe_unused]] static constexpr std::string_view symbol{"MPa"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"MPa"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"MPa"};
};

template <is_unit_value_type_c T>
megapascal_t(T) -> megapascal_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
megapascal_t(const U&) -> megapascal_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct micropascal_t final : public details::unit_t<T, std::ratio<1, 1000000>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"micropascal"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uPa"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5Pa"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5Pa"};
};

template <is_unit_value_type_c T>
micropascal_t(T) -> micropascal_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
micropascal_t(const U&) -> micropascal_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millipascal_t final : public details::unit_t<T, std::ratio<1, 1000>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millipascal"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mPa"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mPa"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mPa"};
};

template <is_unit_value_type_c T>
millipascal_t(T) -> millipascal_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
millipascal_t(const U&) -> millipascal_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanopascal_t final : public details::unit_t<T, std::ratio<1, 1000000000>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanopascal"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nPa"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nPa"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nPa"};
};

template <is_unit_value_type_c T>
nanopascal_t(T) -> nanopascal_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
nanopascal_t(const U&) -> nanopascal_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct bar_t final : public details::unit_t<T, std::ratio<100000, 1>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<100000, 1>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"bar"};
    [[maybe_unused]] static constexpr std::string_view symbol{"bar"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"bar"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"bar"};
};

template <is_unit_value_type_c T>
bar_t(T) -> bar_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
bar_t(const U&) -> bar_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct atmosphere_t final : public details::unit_t<T, std::ratio<101325, 1>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<101325, 1>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"atmosphere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"atm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"atm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"atm"};
};

template <is_unit_value_type_c T>
atmosphere_t(T) -> atmosphere_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, pressure_dimension>
{
    using type = pascal_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, pressure_dimension>
{
    using type = kilopascal_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<100, 1>, pressure_dimension>
{
    using type = hectopascal_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 1>, pressure_dimension>
{
    using type = megapascal_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, pressure_dimension>
{
    using type = micropascal_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, pressure_dimension>
{
    using type = millipascal_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000>, pressure_dimension>
{
    using type = nanopascal_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<100000, 1>, pressure_dimension>
{
    using type = bar_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<101325, 1>, pressure_dimension>
{
    using type = atmosphere_t<T>;
};

}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct barye_t final : public details::unit_t<T, std::ratio<1, 10>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 10>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"barye"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Ba"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Ba"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Ba"};
};

template <is_unit_value_type_c T>
barye_t(T) -> barye_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
barye_t(const U&) -> barye_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 10>, pressure_dimension>
{
    using type = barye_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t magnetic_flux_dimension{2, 1, -2, -1, 0, 0, 0, 0};

inline constexpr dimension_t magnetic_flux_density_dimension{0, 1, -2, -1, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using magnetic_flux = details::unit_t<type_t, ratio_t, magnetic_flux_dimension>;

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using magnetic_flux_density = details::unit_t<type_t, ratio_t, magnetic_flux_density_dimension>;

template <is_unit_value_type_c T>
struct weber_t final : public details::unit_t<T, std::ratio<1, 1>, magnetic_flux_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, magnetic_flux_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"weber"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Wb"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Wb"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Wb"};
};

template <is_unit_value_type_c T>
weber_t(T) -> weber_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_dimension)
weber_t(const U&) -> weber_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct milliweber_t final : public details::unit_t<T, std::ratio<1, 1000>, magnetic_flux_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, magnetic_flux_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"milliweber"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mWb"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mWb"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mWb"};
};

template <is_unit_value_type_c T>
milliweber_t(T) -> milliweber_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_dimension)
milliweber_t(const U&) -> milliweber_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microweber_t final : public details::unit_t<T, std::ratio<1, 1000000>, magnetic_flux_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, magnetic_flux_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microweber"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uWb"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5Wb"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5Wb"};
};

template <is_unit_value_type_c T>
microweber_t(T) -> microweber_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_dimension)
microweber_t(const U&) -> microweber_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanoweber_t final : public details::unit_t<T, std::ratio<1, 1000000000>, magnetic_flux_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, magnetic_flux_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanoweber"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nWb"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nWb"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nWb"};
};

template <is_unit_value_type_c T>
nanoweber_t(T) -> nanoweber_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_dimension)
nanoweber_t(const U&) -> nanoweber_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kiloweber_t final : public details::unit_t<T, std::ratio<1000, 1>, magnetic_flux_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, magnetic_flux_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kiloweber"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kWb"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kWb"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kWb"};
};

template <is_unit_value_type_c T>
kiloweber_t(T) -> kiloweber_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_dimension)
kiloweber_t(const U&) -> kiloweber_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct tesla_t final : public details::unit_t<T, std::ratio<1, 1>, magnetic_flux_density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, magnetic_flux_density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"tesla"};
    [[maybe_unused]] static constexpr std::string_view symbol{"T"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"T"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"T"};
};

template <is_unit_value_type_c T>
tesla_t(T) -> tesla_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_density_dimension)
tesla_t(const U&) -> tesla_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millitesla_t final : public details::unit_t<T, std::ratio<1, 1000>, magnetic_flux_density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, magnetic_flux_density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millitesla"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mT"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mT"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mT"};
};

template <is_unit_value_type_c T>
millitesla_t(T) -> millitesla_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_density_dimension)
millitesla_t(const U&) -> millitesla_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microtesla_t final : public details::unit_t<T, std::ratio<1, 1000000>, magnetic_flux_density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, magnetic_flux_density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microtesla"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uT"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5T"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5T"};
};

template <is_unit_value_type_c T>
microtesla_t(T) -> microtesla_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_density_dimension)
microtesla_t(const U&) -> microtesla_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanotesla_t final : public details::unit_t<T, std::ratio<1, 1000000000>, magnetic_flux_density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, magnetic_flux_density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanotesla"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nT"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nT"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nT"};
};

template <is_unit_value_type_c T>
nanotesla_t(T) -> nanotesla_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_density_dimension)
nanotesla_t(const U&) -> nanotesla_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilotesla_t final : public details::unit_t<T, std::ratio<1000, 1>, magnetic_flux_density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, magnetic_flux_density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilotesla"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kT"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kT"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kT"};
};

template <is_unit_value_type_c T>
kilotesla_t(T) -> kilotesla_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_density_dimension)
kilotesla_t(const U&) -> kilotesla_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megatesla_t final : public details::unit_t<T, std::ratio<1000000, 1>, magnetic_flux_density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, magnetic_flux_density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megatesla"};
    [[maybe_unused]] static constexpr std::string_view symbol{"MT"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"MT"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"MT"};
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, magnetic_flux_dimension>
{
    using type = weber_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, magnetic_flux_dimension>
{
    using type = milliweber_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, magnetic_flux_dimension>
{
    using type = microweber_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000>, magnetic_flux_dimension>
{
    using type = nanoweber_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, magnetic_flux_dimension>
{
    using type = kiloweber_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, magnetic_flux_density_dimension>
{
    using type = tesla_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, magnetic_flux_density_dimension>
{
    using type = millitesla_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, magnetic_flux_density_dimension>
{
    using type = microtesla_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000>, magnetic_flux_density_dimension>
{
    using type = nanotesla_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, magnetic_flux_density_dimension>
{
    using type = kilotesla_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 1>, magnetic_flux_density_dimension>
{
    using type = megatesla_t<T>;
};

}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct gauss_t final : public details::unit_t<T, std::ratio<1, 10000>, magnetic_flux_density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 10000>, magnetic_flux_density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gauss"};
    [[maybe_unused]] static constexpr std::string_view symbol{"G"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"G"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"G"};
};

template <is_unit_value_type_c T>
gauss_t(T) -> gauss_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_density_dimension)
gauss_t(const U&) -> gauss_t<typename details::is_pkr_unit<U>::value_type>;
}

namespace pkr::units
{

inline constexpr dimension_t magnetic_field_strength_dimension{-1, 0, 0, 1, 0, 0, 0, 0};

template <is_unit_value_type_c T>
struct oersted_t final : public details::unit_t<T, std::ratio<795774715459477, 10000000000000>, magnetic_field_strength_dimension>
{
    using _base = details::unit_t<T, std::ratio<795774715459477, 10000000000000>, magnetic_field_strength_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"oersted"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Oe"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Oe"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Oe"};
};

template <is_unit_value_type_c T>
oersted_t(T) -> oersted_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_field_strength_dimension)
oersted_t(const U&) -> oersted_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<795774715459477, 10000000000000>, magnetic_field_strength_dimension>
{
    using type = oersted_t<T>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct maxwell_t final : public details::unit_t<T, std::ratio<1, 100000000>, magnetic_flux_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 100000000>, magnetic_flux_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"maxwell"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Mx"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Mx"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Mx"};
};

template <is_unit_value_type_c T>
maxwell_t(T) -> maxwell_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == magnetic_flux_dimension)
maxwell_t(const U&) -> maxwell_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 100000000>, magnetic_flux_dimension>
{
    using type = maxwell_t<T>;
};
}

namespace std
{

template <pkr::units::is_unit_value_type_c type_t, typename ratio_t, pkr::units::dimension_t dim_v, typename CharT>
struct formatter<pkr::units::details::unit_t<type_t, ratio_t, dim_v>, CharT>
{
    std::formatter<type_t, CharT> value_formatter;

    template <typename ParseContext>
    constexpr auto parse(ParseContext& ctx)
    {
        return value_formatter.parse(ctx);
    }

    template <typename FormatContext>
    auto format(const pkr::units::details::unit_t<type_t, ratio_t, dim_v>& unit, FormatContext& ctx) const
    {
        auto out = ctx.out();
        out = value_formatter.format(unit.value(), ctx);

        static std::basic_string<CharT> built = pkr::units::build_dimension_symbol<CharT>(dim_v);
        std::basic_string_view<CharT> sym = built;

        *out++ = static_cast<CharT>(' ');
        return std::copy(sym.begin(), sym.end(), out);
    }
};

template <typename T, typename CharT>
    requires pkr::units::is_derived_pkr_unit_c<T>
struct formatter<T, CharT>
{
    std::formatter<typename pkr::units::details::is_pkr_unit<T>::value_type, CharT> value_formatter;

    template <typename ParseContext>
    constexpr auto parse(ParseContext& ctx)
    {
        return value_formatter.parse(ctx);
    }

    template <typename FormatContext>
    auto format(const T& unit, FormatContext& ctx) const
    {
        auto out = ctx.out();
        out = value_formatter.format(unit.value(), ctx);

        std::basic_string_view<CharT> sym;
        if constexpr (std::is_same_v<CharT, char>)
            sym = T::symbol;
        else if constexpr (std::is_same_v<CharT, char8_t>)
            sym = T::u8_symbol;
        else if constexpr (std::is_same_v<CharT, wchar_t>)
            sym = T::w_symbol;
        else
            sym = T::symbol;

        *out++ = static_cast<CharT>(' ');
        return std::copy(sym.begin(), sym.end(), out);
    }
};

}

namespace pkr::units
{

inline constexpr dimension_t time_dimension{0, 0, 1, 0, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using time_unit_t = details::unit_t<type_t, ratio_t, time_dimension>;
}

namespace pkr::units
{

namespace details
{

template <typename type_t, typename ratio_t>
struct derived_unit_type_t<type_t, ratio_t, time_dimension>
{
    using type = time_unit_t<type_t, ratio_t>;
};
}

template <typename target_unit_t, typename Rep, typename Period>

    requires std::is_base_of_v<typename target_unit_t::_base, target_unit_t> && (details::is_pkr_unit<target_unit_t>::value_dimension == time_dimension)
constexpr target_unit_t unit_cast(std::chrono::duration<Rep, Period> d) noexcept
{

    using target_ratio = typename details::is_pkr_unit<target_unit_t>::ratio_type;
    using target_type_t = typename details::is_pkr_unit<target_unit_t>::value_type;

    constexpr target_type_t conversion_factor = details::compute_conversion_factor<target_type_t>(
        Period::num, Period::den, target_ratio::num, target_ratio::den);

    target_type_t value = static_cast<target_type_t>(d.count()) * conversion_factor;

    return target_unit_t(value);
}

template <typename Duration, typename source_unit_t>

    requires std::is_base_of_v<typename source_unit_t::_base, source_unit_t> && (details::is_pkr_unit<source_unit_t>::value_dimension == time_dimension)
constexpr Duration unit_cast(const source_unit_t& source) noexcept
{
    using source_ratio = typename details::is_pkr_unit<source_unit_t>::ratio_type;
    using source_type_t = typename details::is_pkr_unit<source_unit_t>::value_type;

    constexpr source_type_t conversion_factor = details::compute_conversion_factor<source_type_t>(
        source_ratio::num, source_ratio::den, Duration::period::num, Duration::period::den);

    source_type_t count = source.value() * conversion_factor;

    return Duration(static_cast<typename Duration::rep>(count));
}

}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct second_t final : public details::unit_t<T, std::ratio<1, 1>, time_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"second"};
    [[maybe_unused]] static constexpr std::string_view symbol{"s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"s"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"s"};
};

template <is_unit_value_type_c T>
second_t(T) -> second_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
second_t(const U&) -> second_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct attosecond_t final : public details::unit_t<T, std::atto, time_dimension>
{
    using _base = details::unit_t<T, std::atto, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"attosecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"as"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"as"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"as"};
};

template <is_unit_value_type_c T>
attosecond_t(T) -> attosecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
attosecond_t(const U&) -> attosecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct femtosecond_t final : public details::unit_t<T, std::femto, time_dimension>
{
    using _base = details::unit_t<T, std::femto, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"femtosecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"fs"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"fs"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"fs"};
};

template <is_unit_value_type_c T>
femtosecond_t(T) -> femtosecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
femtosecond_t(const U&) -> femtosecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct picosecond_t final : public details::unit_t<T, std::pico, time_dimension>
{
    using _base = details::unit_t<T, std::pico, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picosecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ps"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ps"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ps"};
};

template <is_unit_value_type_c T>
picosecond_t(T) -> picosecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
picosecond_t(const U&) -> picosecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanosecond_t final : public details::unit_t<T, std::nano, time_dimension>
{
    using _base = details::unit_t<T, std::nano, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanosecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ns"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ns"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ns"};
};

template <is_unit_value_type_c T>
nanosecond_t(T) -> nanosecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
nanosecond_t(const U&) -> nanosecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microsecond_t final : public details::unit_t<T, std::micro, time_dimension>
{
    using _base = details::unit_t<T, std::micro, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microsecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"us"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5s"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5s"};
};

template <is_unit_value_type_c T>
microsecond_t(T) -> microsecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
microsecond_t(const U&) -> microsecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millisecond_t final : public details::unit_t<T, std::milli, time_dimension>
{
    using _base = details::unit_t<T, std::milli, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millisecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ms"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ms"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ms"};
};

template <is_unit_value_type_c T>
millisecond_t(T) -> millisecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
millisecond_t(const U&) -> millisecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct centisecond_t final : public details::unit_t<T, std::centi, time_dimension>
{
    using _base = details::unit_t<T, std::centi, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"centisecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cs"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cs"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cs"};
};

template <is_unit_value_type_c T>
centisecond_t(T) -> centisecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
centisecond_t(const U&) -> centisecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decisecond_t final : public details::unit_t<T, std::deci, time_dimension>
{
    using _base = details::unit_t<T, std::deci, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decisecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ds"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ds"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ds"};
};

template <is_unit_value_type_c T>
decisecond_t(T) -> decisecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
decisecond_t(const U&) -> decisecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decasecond_t final : public details::unit_t<T, std::deca, time_dimension>
{
    using _base = details::unit_t<T, std::deca, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decasecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"das"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"das"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"das"};
};

template <is_unit_value_type_c T>
decasecond_t(T) -> decasecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
decasecond_t(const U&) -> decasecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hectosecond_t final : public details::unit_t<T, std::hecto, time_dimension>
{
    using _base = details::unit_t<T, std::hecto, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hectosecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"hs"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"hs"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"hs"};
};

template <is_unit_value_type_c T>
hectosecond_t(T) -> hectosecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
hectosecond_t(const U&) -> hectosecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilosecond_t final : public details::unit_t<T, std::kilo, time_dimension>
{
    using _base = details::unit_t<T, std::kilo, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilosecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ks"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ks"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ks"};
};

template <is_unit_value_type_c T>
kilosecond_t(T) -> kilosecond_t<T>;

template <is_unit_value_type_c T>
struct megasecond_t final : public details::unit_t<T, std::mega, time_dimension>
{
    using _base = details::unit_t<T, std::mega, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megasecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Ms"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Ms"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Ms"};
};

template <is_unit_value_type_c T>
megasecond_t(T) -> megasecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
megasecond_t(const U&) -> megasecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gigasecond_t final : public details::unit_t<T, std::giga, time_dimension>
{
    using _base = details::unit_t<T, std::giga, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigasecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Gs"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Gs"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Gs"};
};

template <is_unit_value_type_c T>
gigasecond_t(T) -> gigasecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
gigasecond_t(const U&) -> gigasecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct terasecond_t final : public details::unit_t<T, std::tera, time_dimension>
{
    using _base = details::unit_t<T, std::tera, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"terasecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Ts"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Ts"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Ts"};
};

template <is_unit_value_type_c T>
terasecond_t(T) -> terasecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
terasecond_t(const U&) -> terasecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct petasecond_t final : public details::unit_t<T, std::peta, time_dimension>
{
    using _base = details::unit_t<T, std::peta, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"petasecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Ps"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Ps"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Ps"};
};

template <is_unit_value_type_c T>
petasecond_t(T) -> petasecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
petasecond_t(const U&) -> petasecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct exasecond_t final : public details::unit_t<T, std::exa, time_dimension>
{
    using _base = details::unit_t<T, std::exa, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"exasecond"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Es"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Es"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Es"};
};

template <is_unit_value_type_c T>
exasecond_t(T) -> exasecond_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
exasecond_t(const U&) -> exasecond_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct minute_t final : public details::unit_t<T, std::ratio<60, 1>, time_dimension>
{
    using _base = details::unit_t<T, std::ratio<60, 1>, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"minute"};
    [[maybe_unused]] static constexpr std::string_view symbol{"min"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"min"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"min"};
};

template <is_unit_value_type_c T>
minute_t(T) -> minute_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
minute_t(const U&) -> minute_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hour_t final : public details::unit_t<T, std::ratio<3600, 1>, time_dimension>
{
    using _base = details::unit_t<T, std::ratio<3600, 1>, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hour"};
    [[maybe_unused]] static constexpr std::string_view symbol{"h"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"h"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"h"};
};

template <is_unit_value_type_c T>
hour_t(T) -> hour_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
hour_t(const U&) -> hour_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct day_t final : public details::unit_t<T, std::ratio<86400, 1>, time_dimension>
{
    using _base = details::unit_t<T, std::ratio<86400, 1>, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"day"};
    [[maybe_unused]] static constexpr std::string_view symbol{"d"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"d"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"d"};
};

template <is_unit_value_type_c T>
day_t(T) -> day_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
day_t(const U&) -> day_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct week_t final : public details::unit_t<T, std::ratio<604800, 1>, time_dimension>
{
    using _base = details::unit_t<T, std::ratio<604800, 1>, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"week"};
    [[maybe_unused]] static constexpr std::string_view symbol{"wk"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"wk"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"wk"};
};

template <is_unit_value_type_c T>
week_t(T) -> week_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
week_t(const U&) -> week_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct month_t final : public details::unit_t<T, std::ratio<2629800, 1>, time_dimension>
{
    using _base = details::unit_t<T, std::ratio<2629800, 1>, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"month"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mo"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mo"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mo"};
};

template <is_unit_value_type_c T>
month_t(T) -> month_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == time_dimension)
month_t(const U&) -> month_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct year_t final : public details::unit_t<T, std::ratio<31557600, 1>, time_dimension>
{
    using _base = details::unit_t<T, std::ratio<31557600, 1>, time_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"year"};
    [[maybe_unused]] static constexpr std::string_view symbol{"yr"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"yr"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"yr"};
};

template <is_unit_value_type_c T>
year_t(T) -> year_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, time_dimension>
{
    using type = second_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::atto, time_dimension>
{
    using type = attosecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::femto, time_dimension>
{
    using type = femtosecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::pico, time_dimension>
{
    using type = picosecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::nano, time_dimension>
{
    using type = nanosecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::micro, time_dimension>
{
    using type = microsecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::milli, time_dimension>
{
    using type = millisecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::centi, time_dimension>
{
    using type = centisecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deci, time_dimension>
{
    using type = decisecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deca, time_dimension>
{
    using type = decasecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::hecto, time_dimension>
{
    using type = hectosecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::kilo, time_dimension>
{
    using type = kilosecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::mega, time_dimension>
{
    using type = megasecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::giga, time_dimension>
{
    using type = gigasecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::tera, time_dimension>
{
    using type = terasecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::peta, time_dimension>
{
    using type = petasecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::exa, time_dimension>
{
    using type = exasecond_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<60, 1>, time_dimension>
{
    using type = minute_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<3600, 1>, time_dimension>
{
    using type = hour_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<86400, 1>, time_dimension>
{
    using type = day_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<604800, 1>, time_dimension>
{
    using type = week_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<2629800, 1>, time_dimension>
{
    using type = month_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<31557600, 1>, time_dimension>
{
    using type = year_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t mass_dimension{0, 1, 0, 0, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using mass_unit_t = details::unit_t<type_t, ratio_t, mass_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct kilogram_t final : public details::unit_t<T, std::ratio<1, 1>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilogram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kg"};
};

template <is_unit_value_type_c T>
kilogram_t(T) -> kilogram_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
kilogram_t(const U&) -> kilogram_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct picogram_t final : public details::unit_t<T, std::femto, mass_dimension>
{
    using _base = details::unit_t<T, std::femto, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picogram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pg"};
};

template <is_unit_value_type_c T>
picogram_t(T) -> picogram_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
picogram_t(const U&) -> picogram_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanogram_t final : public details::unit_t<T, std::pico, mass_dimension>
{
    using _base = details::unit_t<T, std::pico, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanogram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ng"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ng"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ng"};
};

template <is_unit_value_type_c T>
nanogram_t(T) -> nanogram_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
nanogram_t(const U&) -> nanogram_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microgram_t final : public details::unit_t<T, std::nano, mass_dimension>
{
    using _base = details::unit_t<T, std::nano, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microgram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ug"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5g"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5g"};
};

template <is_unit_value_type_c T>
microgram_t(T) -> microgram_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
microgram_t(const U&) -> microgram_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct milligram_t final : public details::unit_t<T, std::micro, mass_dimension>
{
    using _base = details::unit_t<T, std::micro, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"milligram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mg"};
};

template <is_unit_value_type_c T>
milligram_t(T) -> milligram_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
milligram_t(const U&) -> milligram_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct centigram_t final : public details::unit_t<T, std::ratio<1, 100000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 100000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"centigram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cg"};
};

template <is_unit_value_type_c T>
centigram_t(T) -> centigram_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
centigram_t(const U&) -> centigram_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decigram_t final : public details::unit_t<T, std::ratio<1, 10000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 10000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decigram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dg"};
};

template <is_unit_value_type_c T>
decigram_t(T) -> decigram_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
decigram_t(const U&) -> decigram_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gram_t final : public details::unit_t<T, std::milli, mass_dimension>
{
    using _base = details::unit_t<T, std::milli, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"g"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"g"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"g"};
};

template <is_unit_value_type_c T>
gram_t(T) -> gram_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
gram_t(const U&) -> gram_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decagram_t final : public details::unit_t<T, std::centi, mass_dimension>
{
    using _base = details::unit_t<T, std::centi, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decagram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dag"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dag"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dag"};
};

template <is_unit_value_type_c T>
decagram_t(T) -> decagram_t<T>;

template <is_unit_value_type_c T>
struct hectogram_t final : public details::unit_t<T, std::deci, mass_dimension>
{
    using _base = details::unit_t<T, std::deci, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hectogram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"hg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"hg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"hg"};
};

template <is_unit_value_type_c T>
hectogram_t(T) -> hectogram_t<T>;

template <is_unit_value_type_c T>
struct gigagram_t final : public details::unit_t<T, std::mega, mass_dimension>
{
    using _base = details::unit_t<T, std::mega, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigagram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Gg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Gg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Gg"};
};

template <is_unit_value_type_c T>
gigagram_t(T) -> gigagram_t<T>;

template <is_unit_value_type_c T>
struct teragram_t final : public details::unit_t<T, std::giga, mass_dimension>
{
    using _base = details::unit_t<T, std::giga, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"teragram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Tg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Tg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Tg"};
};

template <is_unit_value_type_c T>
teragram_t(T) -> teragram_t<T>;

template <is_unit_value_type_c T>
struct petagram_t final : public details::unit_t<T, std::tera, mass_dimension>
{
    using _base = details::unit_t<T, std::tera, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"petagram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Pg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Pg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Pg"};
};

template <is_unit_value_type_c T>
petagram_t(T) -> petagram_t<T>;

template <is_unit_value_type_c T>
struct exagram_t final : public details::unit_t<T, std::peta, mass_dimension>
{
    using _base = details::unit_t<T, std::peta, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"exagram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Eg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Eg"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Eg"};
};

template <is_unit_value_type_c T>
exagram_t(T) -> exagram_t<T>;

template <is_unit_value_type_c T>
struct metric_ton_t final : public details::unit_t<T, std::kilo, mass_dimension>
{
    using _base = details::unit_t<T, std::kilo, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"metric ton"};
    [[maybe_unused]] static constexpr std::string_view symbol{"t"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"t"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"t"};
};

template <is_unit_value_type_c T>
metric_ton_t(T) -> metric_ton_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, mass_dimension>
{
    using type = kilogram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::femto, mass_dimension>
{
    using type = picogram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::pico, mass_dimension>
{
    using type = nanogram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::nano, mass_dimension>
{
    using type = microgram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::micro, mass_dimension>
{
    using type = milligram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 100000>, mass_dimension>
{
    using type = centigram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 10000>, mass_dimension>
{
    using type = decigram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::milli, mass_dimension>
{
    using type = gram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::centi, mass_dimension>
{
    using type = decagram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deci, mass_dimension>
{
    using type = hectogram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::kilo, mass_dimension>
{
    using type = metric_ton_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::mega, mass_dimension>
{
    using type = gigagram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::giga, mass_dimension>
{
    using type = teragram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::tera, mass_dimension>
{
    using type = petagram_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::peta, mass_dimension>
{
    using type = exagram_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t velocity_dimension{.length = 1, .mass = 0, .time = -1, .current = 0, .temperature = 0, .amount = 0, .intensity = 0, .angle = 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using velocity_unit_t = details::unit_t<type_t, ratio_t, velocity_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct meter_per_second_t final : public details::unit_t<T, std::ratio<1, 1>, velocity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, velocity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"meter per second"};
    [[maybe_unused]] static constexpr std::string_view symbol{"m/s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"m\u00B7s\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"m\u00B7s\u207B\u00B9"};
};

template <is_unit_value_type_c T>
meter_per_second_t(T) -> meter_per_second_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == velocity_dimension)
meter_per_second_t(const U&) -> meter_per_second_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilometer_per_hour_t final : public details::unit_t<T, std::ratio<5, 18>, velocity_dimension>
{
    using _base = details::unit_t<T, std::ratio<5, 18>, velocity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilometer per hour"};
    [[maybe_unused]] static constexpr std::string_view symbol{"km/h"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"km\u00B7h\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"km\u00B7h\u207B\u00B9"};
};

template <is_unit_value_type_c T>
kilometer_per_hour_t(T) -> kilometer_per_hour_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == velocity_dimension)
kilometer_per_hour_t(const U&) -> kilometer_per_hour_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct centimeter_per_second_t final : public details::unit_t<T, std::ratio<1, 100>, velocity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 100>, velocity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"centimeter per second"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cm/s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cm\u00B7s\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cm\u00B7s\u207B\u00B9"};
};

template <is_unit_value_type_c T>
centimeter_per_second_t(T) -> centimeter_per_second_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == velocity_dimension)
centimeter_per_second_t(const U&) -> centimeter_per_second_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millimeter_per_second_t final : public details::unit_t<T, std::ratio<1, 1000>, velocity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, velocity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millimeter per second"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mm/s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mm\u00B7s\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mm\u00B7s\u207B\u00B9"};
};

template <is_unit_value_type_c T>
millimeter_per_second_t(T) -> millimeter_per_second_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == velocity_dimension)
millimeter_per_second_t(const U&) -> millimeter_per_second_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilometer_per_second_t final : public details::unit_t<T, std::ratio<1000, 1>, velocity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, velocity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilometer per second"};
    [[maybe_unused]] static constexpr std::string_view symbol{"km/s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"km\u00B7s\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"km\u00B7s\u207B\u00B9"};
};

template <is_unit_value_type_c T>
kilometer_per_second_t(T) -> kilometer_per_second_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == velocity_dimension)
kilometer_per_second_t(const U&) -> kilometer_per_second_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, velocity_dimension>
{
    using type = meter_per_second_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<5, 18>, velocity_dimension>
{
    using type = kilometer_per_hour_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 100>, velocity_dimension>
{
    using type = centimeter_per_second_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, velocity_dimension>
{
    using type = millimeter_per_second_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, velocity_dimension>
{
    using type = kilometer_per_second_t<T>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct meter_per_second_squared_t final : public details::unit_t<T, std::ratio<1, 1>, acceleration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, acceleration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"meter per second squared"};
    [[maybe_unused]] static constexpr std::string_view symbol{"m/s²"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"m\u00B7s\u207B\u00B2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"m\u00B7s\u207B\u00B2"};
};

template <is_unit_value_type_c T>
meter_per_second_squared_t(T) -> meter_per_second_squared_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == acceleration_v)
meter_per_second_squared_t(const U&) -> meter_per_second_squared_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct centimeter_per_second_squared_t final : public details::unit_t<T, std::ratio<1, 100>, acceleration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 100>, acceleration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"centimeter per second squared"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cm/s²"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cm\u00B7s\u207B\u00B2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cm\u00B7s\u207B\u00B2"};
};

template <is_unit_value_type_c T>
centimeter_per_second_squared_t(T) -> centimeter_per_second_squared_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == acceleration_v)
centimeter_per_second_squared_t(const U&) -> centimeter_per_second_squared_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millimeter_per_second_squared_t final : public details::unit_t<T, std::ratio<1, 1000>, acceleration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, acceleration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millimeter per second squared"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mm/s²"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mm\u00B7s\u207B\u00B2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mm\u00B7s\u207B\u00B2"};
};

template <is_unit_value_type_c T>
millimeter_per_second_squared_t(T) -> millimeter_per_second_squared_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == acceleration_v)
millimeter_per_second_squared_t(const U&) -> millimeter_per_second_squared_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilometer_per_second_squared_t final : public details::unit_t<T, std::ratio<1000, 1>, acceleration_v>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, acceleration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilometer per second squared"};
    [[maybe_unused]] static constexpr std::string_view symbol{"km/s²"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"km\u00B7s\u207B\u00B2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"km\u00B7s\u207B\u00B2"};
};

template <is_unit_value_type_c T>
kilometer_per_second_squared_t(T) -> kilometer_per_second_squared_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == acceleration_v)
kilometer_per_second_squared_t(const U&) -> kilometer_per_second_squared_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct standard_gravity_t final : public details::unit_t<T, std::ratio<980665, 100000>, acceleration_v>
{
    using _base = details::unit_t<T, std::ratio<980665, 100000>, acceleration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"standard gravity"};
    [[maybe_unused]] static constexpr std::string_view symbol{"g"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"g"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"g"};
};

template <is_unit_value_type_c T>
standard_gravity_t(T) -> standard_gravity_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == acceleration_v)
standard_gravity_t(const U&) -> standard_gravity_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, acceleration_v>
{
    using type = meter_per_second_squared_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 100>, acceleration_v>
{
    using type = centimeter_per_second_squared_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, acceleration_v>
{
    using type = millimeter_per_second_squared_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, acceleration_v>
{
    using type = kilometer_per_second_squared_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<980665, 100000>, acceleration_v>
{
    using type = standard_gravity_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t electric_potential_dimension{2, 1, -3, -1, 0, 0, 0};

template <is_unit_value_type_c T>
struct volt_t final : public details::unit_t<T, std::ratio<1, 1>, electric_potential_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, electric_potential_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"volt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"V"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"V"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"V"};
};

template <is_unit_value_type_c T>
volt_t(T) -> volt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_potential_dimension)
volt_t(const U&) -> volt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilovolt_t final : public details::unit_t<T, std::ratio<1000, 1>, electric_potential_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, electric_potential_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilovolt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kV"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kV"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kV"};
};

template <is_unit_value_type_c T>
kilovolt_t(T) -> kilovolt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_potential_dimension)
kilovolt_t(const U&) -> kilovolt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megavolt_t final : public details::unit_t<T, std::ratio<1000000, 1>, electric_potential_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, electric_potential_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megavolt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"MV"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"MV"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"MV"};
};

template <is_unit_value_type_c T>
megavolt_t(T) -> megavolt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_potential_dimension)
megavolt_t(const U&) -> megavolt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millivolt_t final : public details::unit_t<T, std::ratio<1, 1000>, electric_potential_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, electric_potential_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millivolt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mV"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mV"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mV"};
};

template <is_unit_value_type_c T>
millivolt_t(T) -> millivolt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_potential_dimension)
millivolt_t(const U&) -> millivolt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microvolt_t final : public details::unit_t<T, std::ratio<1, 1000000>, electric_potential_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, electric_potential_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microvolt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uV"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5V"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5V"};
};

template <is_unit_value_type_c T>
microvolt_t(T) -> microvolt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_potential_dimension)
microvolt_t(const U&) -> microvolt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, electric_potential_dimension>
{
    using type = volt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, electric_potential_dimension>
{
    using type = kilovolt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 1>, electric_potential_dimension>
{
    using type = megavolt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, electric_potential_dimension>
{
    using type = millivolt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, electric_potential_dimension>
{
    using type = microvolt_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t electric_resistance_dimension{2, 1, -3, -2, 0, 0, 0};

template <is_unit_value_type_c T>
struct ohm_t final : public details::unit_t<T, std::ratio<1, 1>, electric_resistance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, electric_resistance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"ohm"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ohm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u03a9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u03a9"};
};

template <is_unit_value_type_c T>
ohm_t(T) -> ohm_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_resistance_dimension)
ohm_t(const U&) -> ohm_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kiloohm_t final : public details::unit_t<T, std::ratio<1000, 1>, electric_resistance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, electric_resistance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kiloohm"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kohm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"k\u03a9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"k\u03a9"};
};

template <is_unit_value_type_c T>
kiloohm_t(T) -> kiloohm_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_resistance_dimension)
kiloohm_t(const U&) -> kiloohm_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megaohm_t final : public details::unit_t<T, std::ratio<1000000, 1>, electric_resistance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, electric_resistance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megaohm"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Mohm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"M\u03a9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"M\u03a9"};
};

template <is_unit_value_type_c T>
megaohm_t(T) -> megaohm_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_resistance_dimension)
megaohm_t(const U&) -> megaohm_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gigaohm_t final : public details::unit_t<T, std::ratio<1000000000, 1>, electric_resistance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000000, 1>, electric_resistance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigaohm"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Gohm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"G\u03a9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"G\u03a9"};
};

template <is_unit_value_type_c T>
gigaohm_t(T) -> gigaohm_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_resistance_dimension)
gigaohm_t(const U&) -> gigaohm_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct milliohm_t final : public details::unit_t<T, std::ratio<1, 1000>, electric_resistance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, electric_resistance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"milliohm"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mohm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"m\u03a9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"m\u03a9"};
};

template <is_unit_value_type_c T>
milliohm_t(T) -> milliohm_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_resistance_dimension)
milliohm_t(const U&) -> milliohm_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microohm_t final : public details::unit_t<T, std::ratio<1, 1000000>, electric_resistance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, electric_resistance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microohm"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uohm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5\u03a9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5\u03a9"};
};

template <is_unit_value_type_c T>
microohm_t(T) -> microohm_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == electric_resistance_dimension)
microohm_t(const U&) -> microohm_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, electric_resistance_dimension>
{
    using type = ohm_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, electric_resistance_dimension>
{
    using type = kiloohm_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 1>, electric_resistance_dimension>
{
    using type = megaohm_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000000, 1>, electric_resistance_dimension>
{
    using type = gigaohm_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, electric_resistance_dimension>
{
    using type = milliohm_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, electric_resistance_dimension>
{
    using type = microohm_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t capacitance_v{-2, -1, 4, 2, 0, 0, 0, 0};

template <is_unit_value_type_c T>
struct farad_t final : public details::unit_t<T, std::ratio<1, 1>, capacitance_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, capacitance_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"farad"};
    [[maybe_unused]] static constexpr std::string_view symbol{"F"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"F"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"F"};
};

template <is_unit_value_type_c T>
farad_t(T) -> farad_t<T>;

template <is_unit_value_type_c T>
struct millifarad_t final : public details::unit_t<T, std::ratio<1, 1000>, capacitance_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, capacitance_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millifarad"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mF"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mF"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mF"};
};

template <is_unit_value_type_c T>
millifarad_t(T) -> millifarad_t<T>;

template <is_unit_value_type_c T>
struct microfarad_t final : public details::unit_t<T, std::ratio<1, 1000000>, capacitance_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, capacitance_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microfarad"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uF"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5F"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5F"};
};

template <is_unit_value_type_c T>
microfarad_t(T) -> microfarad_t<T>;

template <is_unit_value_type_c T>
struct nanofarad_t final : public details::unit_t<T, std::ratio<1, 1000000000>, capacitance_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, capacitance_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanofarad"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nF"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nF"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nF"};
};

template <is_unit_value_type_c T>
nanofarad_t(T) -> nanofarad_t<T>;

template <is_unit_value_type_c T>
struct picofarad_t final : public details::unit_t<T, std::ratio<1, 1000000000000>, capacitance_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000000>, capacitance_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picofarad"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pF"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pF"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pF"};
};

template <is_unit_value_type_c T>
picofarad_t(T) -> picofarad_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, capacitance_v>
{
    using type = farad_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, capacitance_v>
{
    using type = millifarad_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, capacitance_v>
{
    using type = microfarad_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000>, capacitance_v>
{
    using type = nanofarad_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000000>, capacitance_v>
{
    using type = picofarad_t<T>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1>, capacitance_v>
{
    using type = farad_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1000>, capacitance_v>
{
    using type = millifarad_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1000000>, capacitance_v>
{
    using type = microfarad_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1000000000>, capacitance_v>
{
    using type = nanofarad_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1000000000000>, capacitance_v>
{
    using type = picofarad_t<double>;
};
}

namespace pkr::units
{

inline constexpr dimension_t inductance_dimension{2, 1, -2, -2, 0, 0, 0};

template <is_unit_value_type_c T>
struct henry_t final : public details::unit_t<T, std::ratio<1, 1>, inductance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, inductance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"henry"};
    [[maybe_unused]] static constexpr std::string_view symbol{"H"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"H"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"H"};
};

template <is_unit_value_type_c T>
henry_t(T) -> henry_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == inductance_dimension)
henry_t(const U&) -> henry_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millihenry_t final : public details::unit_t<T, std::ratio<1, 1000>, inductance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, inductance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millihenry"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mH"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mH"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mH"};
};

template <is_unit_value_type_c T>
millihenry_t(T) -> millihenry_t<T>;

template <is_unit_value_type_c T>
struct microhenry_t final : public details::unit_t<T, std::ratio<1, 1000000>, inductance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, inductance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microhenry"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uH"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5H"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5H"};
};

template <is_unit_value_type_c T>
microhenry_t(T) -> microhenry_t<T>;

template <is_unit_value_type_c T>
struct nanohenry_t final : public details::unit_t<T, std::ratio<1, 1000000000>, inductance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, inductance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanohenry"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nH"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nH"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nH"};
};

template <is_unit_value_type_c T>
nanohenry_t(T) -> nanohenry_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, inductance_dimension>
{
    using type = henry_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, inductance_dimension>
{
    using type = millihenry_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, inductance_dimension>
{
    using type = microhenry_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000>, inductance_dimension>
{
    using type = nanohenry_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t conductance_dimension{-2, -1, 3, 2, 0, 0, 0, 0};

template <is_unit_value_type_c T>
struct siemens_t final : public details::unit_t<T, std::ratio<1, 1>, conductance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, conductance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"siemens"};
    [[maybe_unused]] static constexpr std::string_view symbol{"S"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"S"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"S"};
};

template <is_unit_value_type_c T>
siemens_t(T) -> siemens_t<T>;

template <is_unit_value_type_c T>
struct millisiemens_t final : public details::unit_t<T, std::ratio<1, 1000>, conductance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, conductance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millisiemens"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mS"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mS"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mS"};
};

template <is_unit_value_type_c T>
millisiemens_t(T) -> millisiemens_t<T>;

template <is_unit_value_type_c T>
struct microsiemens_t final : public details::unit_t<T, std::ratio<1, 1000000>, conductance_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, conductance_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microsiemens"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uS"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5S"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5S"};
};

template <is_unit_value_type_c T>
microsiemens_t(T) -> microsiemens_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, conductance_dimension>
{
    using type = siemens_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, conductance_dimension>
{
    using type = millisiemens_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, conductance_dimension>
{
    using type = microsiemens_t<T>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1>, conductance_dimension>
{
    using type = siemens_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1000>, conductance_dimension>
{
    using type = millisiemens_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1000000>, conductance_dimension>
{
    using type = microsiemens_t<double>;
};
}

namespace pkr::units
{
namespace details
{
template <typename T>
constexpr T atomic_mass_unit()
{
    return static_cast<T>(1.66053906892e-27);
}

template <typename T>
constexpr T avogadro()
{
    return static_cast<T>(6.02214076e23);
}

template <typename T>
constexpr T bohr_magneton()
{
    return static_cast<T>(9.2740100657e-24);
}

template <typename T>
constexpr T boltzmann_constant()
{
    return static_cast<T>(1.380649e-23);
}

template <typename T>
constexpr T electron_mass()
{
    return static_cast<T>(9.1093837139e-31);
}

template <typename T>
constexpr T elementary_charge()
{
    return static_cast<T>(1.602176634e-19);
}

template <typename T>
constexpr T faraday_constant()
{
    return static_cast<T>(96485.33212);
}

template <typename T>
constexpr T fine_structure_constant()
{
    return static_cast<T>(7.2973525643e-3);
}

template <typename T>
constexpr T gravitational_constant()
{
    return static_cast<T>(6.67430e-11);
}

template <typename T>
constexpr T molar_gas_constant()
{
    return static_cast<T>(8.314462618);
}

template <typename T>
constexpr T neutron_mass()
{
    return static_cast<T>(1.67492750056e-27);
}

template <typename T>
constexpr T nuclear_magneton()
{
    return static_cast<T>(5.0507837393e-27);
}

template <typename T>
constexpr T planck_constant()
{
    return static_cast<T>(6.62607015e-34);
}

template <typename T>
constexpr T proton_mass()
{
    return static_cast<T>(1.67262192595e-27);
}

template <typename T>
constexpr T reduced_planck_constant()
{
    return static_cast<T>(1.054571817e-34);
}

template <typename T>
constexpr T speed_of_light()
{
    return static_cast<T>(299792458.0);
}

template <typename T>
constexpr T standard_gravity()
{
    return static_cast<T>(9.80665);
}

template <typename T>
constexpr T stefan_boltzmann()
{
    return static_cast<T>(5.670374419e-8);
}

template <typename T>
constexpr T vacuum_permeability()
{
    return static_cast<T>(1.25663706127e-6);
}

template <typename T>
constexpr T vacuum_permittivity()
{
    return static_cast<T>(8.8541878188e-12);
}

}
constexpr kilogram_t atomic_mass_unit{details::atomic_mass_unit<double>()};
constexpr kilogram_t electron_mass{details::electron_mass<double>()};
constexpr kilogram_t neutron_mass{details::neutron_mass<double>()};
constexpr kilogram_t proton_mass{details::proton_mass<double>()};

constexpr meter_per_second_t speed_of_light{details::speed_of_light<double>()};
constexpr meter_per_second_squared_t standard_gravity{details::standard_gravity<double>()};

constexpr auto avogadro = details::avogadro<double>();
constexpr auto bohr_magneton = details::bohr_magneton<double>();
constexpr auto boltzmann_constant = details::boltzmann_constant<double>();
constexpr auto elementary_charge = details::elementary_charge<double>();
constexpr auto faraday_constant = details::faraday_constant<double>();
constexpr auto fine_structure_constant = details::fine_structure_constant<double>();
constexpr auto gravitational_constant = details::gravitational_constant<double>();
constexpr auto molar_gas_constant = details::molar_gas_constant<double>();
constexpr auto nuclear_magneton = details::nuclear_magneton<double>();
constexpr auto planck_constant = details::planck_constant<double>();
constexpr auto reduced_planck_constant = details::reduced_planck_constant<double>();
constexpr auto stefan_boltzmann = details::stefan_boltzmann<double>();
constexpr auto vacuum_permeability = details::vacuum_permeability<double>();
constexpr auto vacuum_permittivity = details::vacuum_permittivity<double>();

}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct meter_t final : public details::unit_t<T, std::ratio<1, 1>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"meter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"m"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"m"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"m"};
};

template <is_unit_value_type_c T>
meter_t(T) -> meter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
meter_t(const U&) -> meter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct attometer_t final : public details::unit_t<T, std::atto, length_dimension>
{
    using _base = details::unit_t<T, std::atto, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"attometer"};
    [[maybe_unused]] static constexpr std::string_view symbol{"am"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"am"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"am"};
};

template <is_unit_value_type_c T>
attometer_t(T) -> attometer_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
attometer_t(const U&) -> attometer_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct femtometer_t final : public details::unit_t<T, std::femto, length_dimension>
{
    using _base = details::unit_t<T, std::femto, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"femtometer"};
    [[maybe_unused]] static constexpr std::string_view symbol{"fm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"fm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"fm"};
};

template <is_unit_value_type_c T>
femtometer_t(T) -> femtometer_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
femtometer_t(const U&) -> femtometer_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct picometer_t final : public details::unit_t<T, std::pico, length_dimension>
{
    using _base = details::unit_t<T, std::pico, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picometer"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pm"};
};

template <is_unit_value_type_c T>
picometer_t(T) -> picometer_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
picometer_t(const U&) -> picometer_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanometer_t final : public details::unit_t<T, std::nano, length_dimension>
{
    using _base = details::unit_t<T, std::nano, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanometer"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nm"};
};

template <is_unit_value_type_c T>
nanometer_t(T) -> nanometer_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
nanometer_t(const U&) -> nanometer_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct micrometer_t final : public details::unit_t<T, std::micro, length_dimension>
{
    using _base = details::unit_t<T, std::micro, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"micrometer"};
    [[maybe_unused]] static constexpr std::string_view symbol{"um"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5m"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5m"};
};

template <is_unit_value_type_c T>
micrometer_t(T) -> micrometer_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
micrometer_t(const U&) -> micrometer_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millimeter_t final : public details::unit_t<T, std::milli, length_dimension>
{
    using _base = details::unit_t<T, std::milli, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millimeter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mm"};
};

template <is_unit_value_type_c T>
millimeter_t(T) -> millimeter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
millimeter_t(const U&) -> millimeter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct centimeter_t final : public details::unit_t<T, std::centi, length_dimension>
{
    using _base = details::unit_t<T, std::centi, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"centimeter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cm"};
};

template <is_unit_value_type_c T>
centimeter_t(T) -> centimeter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
centimeter_t(const U&) -> centimeter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decimeter_t final : public details::unit_t<T, std::deci, length_dimension>
{
    using _base = details::unit_t<T, std::deci, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decimeter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dm"};
};

template <is_unit_value_type_c T>
decimeter_t(T) -> decimeter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
decimeter_t(const U&) -> decimeter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decameter_t final : public details::unit_t<T, std::deca, length_dimension>
{
    using _base = details::unit_t<T, std::deca, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decameter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dam"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dam"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dam"};
};

template <is_unit_value_type_c T>
decameter_t(T) -> decameter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
decameter_t(const U&) -> decameter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hectometer_t final : public details::unit_t<T, std::hecto, length_dimension>
{
    using _base = details::unit_t<T, std::hecto, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hectometer"};
    [[maybe_unused]] static constexpr std::string_view symbol{"hm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"hm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"hm"};
};

template <is_unit_value_type_c T>
hectometer_t(T) -> hectometer_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
hectometer_t(const U&) -> hectometer_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilometer_t final : public details::unit_t<T, std::kilo, length_dimension>
{
    using _base = details::unit_t<T, std::kilo, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilometer"};
    [[maybe_unused]] static constexpr std::string_view symbol{"km"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"km"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"km"};
};

template <is_unit_value_type_c T>
kilometer_t(T) -> kilometer_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
kilometer_t(const U&) -> kilometer_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megameter_t final : public details::unit_t<T, std::mega, length_dimension>
{
    using _base = details::unit_t<T, std::mega, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megameter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Mm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Mm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Mm"};
};

template <is_unit_value_type_c T>
megameter_t(T) -> megameter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
megameter_t(const U&) -> megameter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gigameter_t final : public details::unit_t<T, std::giga, length_dimension>
{
    using _base = details::unit_t<T, std::giga, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigameter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Gm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Gm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Gm"};
};

template <is_unit_value_type_c T>
gigameter_t(T) -> gigameter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
gigameter_t(const U&) -> gigameter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct terameter_t final : public details::unit_t<T, std::tera, length_dimension>
{
    using _base = details::unit_t<T, std::tera, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"terameter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Tm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Tm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Tm"};
};

template <is_unit_value_type_c T>
terameter_t(T) -> terameter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
terameter_t(const U&) -> terameter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct petameter_t final : public details::unit_t<T, std::peta, length_dimension>
{
    using _base = details::unit_t<T, std::peta, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"petameter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Pm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Pm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Pm"};
};

template <is_unit_value_type_c T>
petameter_t(T) -> petameter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
petameter_t(const U&) -> petameter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct exameter_t final : public details::unit_t<T, std::exa, length_dimension>
{
    using _base = details::unit_t<T, std::exa, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"exameter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Em"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Em"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Em"};
};

template <is_unit_value_type_c T>
exameter_t(T) -> exameter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
exameter_t(const U&) -> exameter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, length_dimension>
{
    using type = meter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::atto, length_dimension>
{
    using type = attometer_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::femto, length_dimension>
{
    using type = femtometer_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::pico, length_dimension>
{
    using type = picometer_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::nano, length_dimension>
{
    using type = nanometer_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::micro, length_dimension>
{
    using type = micrometer_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::milli, length_dimension>
{
    using type = millimeter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::centi, length_dimension>
{
    using type = centimeter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deci, length_dimension>
{
    using type = decimeter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deca, length_dimension>
{
    using type = decameter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::hecto, length_dimension>
{
    using type = hectometer_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::kilo, length_dimension>
{
    using type = kilometer_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::mega, length_dimension>
{
    using type = megameter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::giga, length_dimension>
{
    using type = gigameter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::tera, length_dimension>
{
    using type = terameter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::peta, length_dimension>
{
    using type = petameter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::exa, length_dimension>
{
    using type = exameter_t<T>;
};

}

namespace pkr::units
{

inline constexpr dimension_t current_dimension{0, 0, 0, 1, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using current_unit_t = details::unit_t<type_t, ratio_t, current_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct ampere_t final : public details::unit_t<T, std::ratio<1, 1>, current_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"ampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"A"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"A"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"A"};
};

template <is_unit_value_type_c T>
ampere_t(T) -> ampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
ampere_t(const U&) -> ampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct attoampere_t final : public details::unit_t<T, std::atto, current_dimension>
{
    using _base = details::unit_t<T, std::atto, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"attoampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"aA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"aA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"aA"};
};

template <is_unit_value_type_c T>
attoampere_t(T) -> attoampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
attoampere_t(const U&) -> attoampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct femtoampere_t final : public details::unit_t<T, std::femto, current_dimension>
{
    using _base = details::unit_t<T, std::femto, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"femtoampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"fA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"fA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"fA"};
};

template <is_unit_value_type_c T>
femtoampere_t(T) -> femtoampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
femtoampere_t(const U&) -> femtoampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct deciampere_t final : public details::unit_t<T, std::deci, current_dimension>
{
    using _base = details::unit_t<T, std::deci, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"deciampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dA"};
};

template <is_unit_value_type_c T>
deciampere_t(T) -> deciampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
deciampere_t(const U&) -> deciampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decaampere_t final : public details::unit_t<T, std::deca, current_dimension>
{
    using _base = details::unit_t<T, std::deca, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decaampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"daA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"daA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"daA"};
};

template <is_unit_value_type_c T>
decaampere_t(T) -> decaampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
decaampere_t(const U&) -> decaampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hectoampere_t final : public details::unit_t<T, std::hecto, current_dimension>
{
    using _base = details::unit_t<T, std::hecto, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hectoampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"hA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"hA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"hA"};
};

template <is_unit_value_type_c T>
hectoampere_t(T) -> hectoampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
hectoampere_t(const U&) -> hectoampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kiloampere_t final : public details::unit_t<T, std::kilo, current_dimension>
{
    using _base = details::unit_t<T, std::kilo, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kiloampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kA"};
};

template <is_unit_value_type_c T>
kiloampere_t(T) -> kiloampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
kiloampere_t(const U&) -> kiloampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megaampere_t final : public details::unit_t<T, std::mega, current_dimension>
{
    using _base = details::unit_t<T, std::mega, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megaampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"MA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"MA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"MA"};
};

template <is_unit_value_type_c T>
megaampere_t(T) -> megaampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
megaampere_t(const U&) -> megaampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gigaampere_t final : public details::unit_t<T, std::giga, current_dimension>
{
    using _base = details::unit_t<T, std::giga, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigaampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"GA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"GA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"GA"};
};

template <is_unit_value_type_c T>
gigaampere_t(T) -> gigaampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
gigaampere_t(const U&) -> gigaampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct teraampere_t final : public details::unit_t<T, std::tera, current_dimension>
{
    using _base = details::unit_t<T, std::tera, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"teraampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"TA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"TA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"TA"};
};

template <is_unit_value_type_c T>
teraampere_t(T) -> teraampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
teraampere_t(const U&) -> teraampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct petaampere_t final : public details::unit_t<T, std::peta, current_dimension>
{
    using _base = details::unit_t<T, std::peta, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"petaampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"PA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"PA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"PA"};
};

template <is_unit_value_type_c T>
petaampere_t(T) -> petaampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
petaampere_t(const U&) -> petaampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct exaampere_t final : public details::unit_t<T, std::exa, current_dimension>
{
    using _base = details::unit_t<T, std::exa, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"exaampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"EA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"EA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"EA"};
};

template <is_unit_value_type_c T>
exaampere_t(T) -> exaampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
exaampere_t(const U&) -> exaampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct picoampere_t final : public details::unit_t<T, std::pico, current_dimension>
{
    using _base = details::unit_t<T, std::pico, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picoampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pA"};
};

template <is_unit_value_type_c T>
picoampere_t(T) -> picoampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
picoampere_t(const U&) -> picoampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanoampere_t final : public details::unit_t<T, std::nano, current_dimension>
{
    using _base = details::unit_t<T, std::nano, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanoampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nA"};
};

template <is_unit_value_type_c T>
nanoampere_t(T) -> nanoampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
nanoampere_t(const U&) -> nanoampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microampere_t final : public details::unit_t<T, std::micro, current_dimension>
{
    using _base = details::unit_t<T, std::micro, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5A"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5A"};
};

template <is_unit_value_type_c T>
microampere_t(T) -> microampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
microampere_t(const U&) -> microampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct milliampere_t final : public details::unit_t<T, std::milli, current_dimension>
{
    using _base = details::unit_t<T, std::milli, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"milliampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mA"};
};

template <is_unit_value_type_c T>
milliampere_t(T) -> milliampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
milliampere_t(const U&) -> milliampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct centiampere_t final : public details::unit_t<T, std::centi, current_dimension>
{
    using _base = details::unit_t<T, std::centi, current_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"centiampere"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cA"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cA"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cA"};
};

template <is_unit_value_type_c T>
centiampere_t(T) -> centiampere_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == current_dimension)
centiampere_t(const U&) -> centiampere_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, current_dimension>
{
    using type = ampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::atto, current_dimension>
{
    using type = attoampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::femto, current_dimension>
{
    using type = femtoampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::pico, current_dimension>
{
    using type = picoampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::nano, current_dimension>
{
    using type = nanoampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::micro, current_dimension>
{
    using type = microampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::milli, current_dimension>
{
    using type = milliampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::centi, current_dimension>
{
    using type = centiampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deci, current_dimension>
{
    using type = deciampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deca, current_dimension>
{
    using type = decaampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::hecto, current_dimension>
{
    using type = hectoampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::kilo, current_dimension>
{
    using type = kiloampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::mega, current_dimension>
{
    using type = megaampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::giga, current_dimension>
{
    using type = gigaampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::tera, current_dimension>
{
    using type = teraampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::peta, current_dimension>
{
    using type = petaampere_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::exa, current_dimension>
{
    using type = exaampere_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t temperature_dimension{0, 0, 0, 0, 1, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using temperature_unit_t = details::unit_t<type_t, ratio_t, temperature_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct kelvin_t final : public details::unit_t<T, std::ratio<1, 1>, temperature_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"K"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"K"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"K"};
};

template <is_unit_value_type_c T>
kelvin_t(T) -> kelvin_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == temperature_dimension)
kelvin_t(const U&) -> kelvin_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct attokelvin_t final : public details::unit_t<T, std::atto, temperature_dimension>
{
    using _base = details::unit_t<T, std::atto, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"attokelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"aK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"aK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"aK"};
};

template <is_unit_value_type_c T>
attokelvin_t(T) -> attokelvin_t<T>;

template <is_unit_value_type_c T>
struct femtokelvin_t final : public details::unit_t<T, std::femto, temperature_dimension>
{
    using _base = details::unit_t<T, std::femto, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"femtokelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"fK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"fK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"fK"};
};

template <is_unit_value_type_c T>
femtokelvin_t(T) -> femtokelvin_t<T>;

template <is_unit_value_type_c T>
struct picokelvin_t final : public details::unit_t<T, std::pico, temperature_dimension>
{
    using _base = details::unit_t<T, std::pico, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picokelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pK"};
};

template <is_unit_value_type_c T>
picokelvin_t(T) -> picokelvin_t<T>;

template <is_unit_value_type_c T>
struct nanokelvin_t final : public details::unit_t<T, std::nano, temperature_dimension>
{
    using _base = details::unit_t<T, std::nano, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanokelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nK"};
};

template <is_unit_value_type_c T>
nanokelvin_t(T) -> nanokelvin_t<T>;

template <is_unit_value_type_c T>
struct microkelvin_t final : public details::unit_t<T, std::micro, temperature_dimension>
{
    using _base = details::unit_t<T, std::micro, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microkelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5K"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5K"};
};

template <is_unit_value_type_c T>
microkelvin_t(T) -> microkelvin_t<T>;

template <is_unit_value_type_c T>
struct millikelvin_t final : public details::unit_t<T, std::milli, temperature_dimension>
{
    using _base = details::unit_t<T, std::milli, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millikelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mK"};
};

template <is_unit_value_type_c T>
millikelvin_t(T) -> millikelvin_t<T>;

template <is_unit_value_type_c T>
struct centikelvin_t final : public details::unit_t<T, std::centi, temperature_dimension>
{
    using _base = details::unit_t<T, std::centi, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"centikelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cK"};
};

template <is_unit_value_type_c T>
centikelvin_t(T) -> centikelvin_t<T>;

template <is_unit_value_type_c T>
struct decikelvin_t final : public details::unit_t<T, std::deci, temperature_dimension>
{
    using _base = details::unit_t<T, std::deci, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decikelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dK"};
};

template <is_unit_value_type_c T>
decikelvin_t(T) -> decikelvin_t<T>;

template <is_unit_value_type_c T>
struct decakelvin_t final : public details::unit_t<T, std::deca, temperature_dimension>
{
    using _base = details::unit_t<T, std::deca, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decakelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"daK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"daK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"daK"};
};

template <is_unit_value_type_c T>
decakelvin_t(T) -> decakelvin_t<T>;

template <is_unit_value_type_c T>
struct hectokelvin_t final : public details::unit_t<T, std::hecto, temperature_dimension>
{
    using _base = details::unit_t<T, std::hecto, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hectokelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"hK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"hK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"hK"};
};

template <is_unit_value_type_c T>
hectokelvin_t(T) -> hectokelvin_t<T>;

template <is_unit_value_type_c T>
struct kilokelvin_t final : public details::unit_t<T, std::kilo, temperature_dimension>
{
    using _base = details::unit_t<T, std::kilo, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilokelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kK"};
};

template <is_unit_value_type_c T>
kilokelvin_t(T) -> kilokelvin_t<T>;

template <is_unit_value_type_c T>
struct megakelvin_t final : public details::unit_t<T, std::mega, temperature_dimension>
{
    using _base = details::unit_t<T, std::mega, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megakelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"MK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"MK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"MK"};
};

template <is_unit_value_type_c T>
megakelvin_t(T) -> megakelvin_t<T>;

template <is_unit_value_type_c T>
struct gigakelvin_t final : public details::unit_t<T, std::giga, temperature_dimension>
{
    using _base = details::unit_t<T, std::giga, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigakelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"GK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"GK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"GK"};
};

template <is_unit_value_type_c T>
gigakelvin_t(T) -> gigakelvin_t<T>;

template <is_unit_value_type_c T>
struct terakelvin_t final : public details::unit_t<T, std::tera, temperature_dimension>
{
    using _base = details::unit_t<T, std::tera, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"terakelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"TK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"TK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"TK"};
};

template <is_unit_value_type_c T>
terakelvin_t(T) -> terakelvin_t<T>;

template <is_unit_value_type_c T>
struct petakelvin_t final : public details::unit_t<T, std::peta, temperature_dimension>
{
    using _base = details::unit_t<T, std::peta, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"petakelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"PK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"PK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"PK"};
};

template <is_unit_value_type_c T>
petakelvin_t(T) -> petakelvin_t<T>;

template <is_unit_value_type_c T>
struct exakelvin_t final : public details::unit_t<T, std::exa, temperature_dimension>
{
    using _base = details::unit_t<T, std::exa, temperature_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"exakelvin"};
    [[maybe_unused]] static constexpr std::string_view symbol{"EK"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"EK"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"EK"};
};

template <is_unit_value_type_c T>
exakelvin_t(T) -> exakelvin_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, temperature_dimension>
{
    using type = kelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::atto, temperature_dimension>
{
    using type = attokelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::femto, temperature_dimension>
{
    using type = femtokelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::pico, temperature_dimension>
{
    using type = picokelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::nano, temperature_dimension>
{
    using type = nanokelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::micro, temperature_dimension>
{
    using type = microkelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::milli, temperature_dimension>
{
    using type = millikelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::centi, temperature_dimension>
{
    using type = centikelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deci, temperature_dimension>
{
    using type = decikelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deca, temperature_dimension>
{
    using type = decakelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::hecto, temperature_dimension>
{
    using type = hectokelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::kilo, temperature_dimension>
{
    using type = kilokelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::mega, temperature_dimension>
{
    using type = megakelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::giga, temperature_dimension>
{
    using type = gigakelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::tera, temperature_dimension>
{
    using type = terakelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::peta, temperature_dimension>
{
    using type = petakelvin_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::exa, temperature_dimension>
{
    using type = exakelvin_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t amount_dimension{0, 0, 0, 0, 0, 1, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using amount_unit_t = details::unit_t<type_t, ratio_t, amount_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct mole_t final : public details::unit_t<T, std::ratio<1, 1>, amount_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"mole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mol"};
};

template <is_unit_value_type_c T>
mole_t(T) -> mole_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == amount_dimension)
mole_t(const U&) -> mole_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct attomole_t final : public details::unit_t<T, std::atto, amount_dimension>
{
    using _base = details::unit_t<T, std::atto, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"attomole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"amol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"amol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"amol"};
};

template <is_unit_value_type_c T>
attomole_t(T) -> attomole_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == amount_dimension)
attomole_t(const U&) -> attomole_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct femtomole_t final : public details::unit_t<T, std::femto, amount_dimension>
{
    using _base = details::unit_t<T, std::femto, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"femtomole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"fmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"fmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"fmol"};
};

template <is_unit_value_type_c T>
femtomole_t(T) -> femtomole_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == amount_dimension)
femtomole_t(const U&) -> femtomole_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct picomole_t final : public details::unit_t<T, std::pico, amount_dimension>
{
    using _base = details::unit_t<T, std::pico, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picomole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pmol"};
};

template <is_unit_value_type_c T>
picomole_t(T) -> picomole_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == amount_dimension)
picomole_t(const U&) -> picomole_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanomole_t final : public details::unit_t<T, std::nano, amount_dimension>
{
    using _base = details::unit_t<T, std::nano, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanomole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nmol"};
};

template <is_unit_value_type_c T>
nanomole_t(T) -> nanomole_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == amount_dimension)
nanomole_t(const U&) -> nanomole_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct micromole_t final : public details::unit_t<T, std::micro, amount_dimension>
{
    using _base = details::unit_t<T, std::micro, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"micromole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"umol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5mol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5mol"};
};

template <is_unit_value_type_c T>
micromole_t(T) -> micromole_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == amount_dimension)
micromole_t(const U&) -> micromole_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millimole_t final : public details::unit_t<T, std::milli, amount_dimension>
{
    using _base = details::unit_t<T, std::milli, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millimole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mmol"};
};

template <is_unit_value_type_c T>
millimole_t(T) -> millimole_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == amount_dimension)
millimole_t(const U&) -> millimole_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct centimole_t final : public details::unit_t<T, std::centi, amount_dimension>
{
    using _base = details::unit_t<T, std::centi, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"centimole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cmol"};
};

template <is_unit_value_type_c T>
centimole_t(T) -> centimole_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == amount_dimension)
centimole_t(const U&) -> centimole_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decimole_t final : public details::unit_t<T, std::deci, amount_dimension>
{
    using _base = details::unit_t<T, std::deci, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decimole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dmol"};
};

template <is_unit_value_type_c T>
decimole_t(T) -> decimole_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == amount_dimension)
decimole_t(const U&) -> decimole_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decamole_t final : public details::unit_t<T, std::deca, amount_dimension>
{
    using _base = details::unit_t<T, std::deca, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decamole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"damol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"damol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"damol"};
};

template <is_unit_value_type_c T>
decamole_t(T) -> decamole_t<T>;

template <is_unit_value_type_c T>
struct hectomole_t final : public details::unit_t<T, std::hecto, amount_dimension>
{
    using _base = details::unit_t<T, std::hecto, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hectomole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"hmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"hmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"hmol"};
};

template <is_unit_value_type_c T>
hectomole_t(T) -> hectomole_t<T>;

template <is_unit_value_type_c T>
struct kilomole_t final : public details::unit_t<T, std::kilo, amount_dimension>
{
    using _base = details::unit_t<T, std::kilo, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilomole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kmol"};
};

template <is_unit_value_type_c T>
kilomole_t(T) -> kilomole_t<T>;

template <is_unit_value_type_c T>
struct megamole_t final : public details::unit_t<T, std::mega, amount_dimension>
{
    using _base = details::unit_t<T, std::mega, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megamole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Mmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Mmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Mmol"};
};

template <is_unit_value_type_c T>
megamole_t(T) -> megamole_t<T>;

template <is_unit_value_type_c T>
struct gigamole_t final : public details::unit_t<T, std::giga, amount_dimension>
{
    using _base = details::unit_t<T, std::giga, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigamole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Gmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Gmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Gmol"};
};

template <is_unit_value_type_c T>
gigamole_t(T) -> gigamole_t<T>;

template <is_unit_value_type_c T>
struct teramole_t final : public details::unit_t<T, std::tera, amount_dimension>
{
    using _base = details::unit_t<T, std::tera, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"teramole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Tmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Tmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Tmol"};
};

template <is_unit_value_type_c T>
teramole_t(T) -> teramole_t<T>;

template <is_unit_value_type_c T>
struct petamole_t final : public details::unit_t<T, std::peta, amount_dimension>
{
    using _base = details::unit_t<T, std::peta, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"petamole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Pmol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Pmol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Pmol"};
};

template <is_unit_value_type_c T>
petamole_t(T) -> petamole_t<T>;

template <is_unit_value_type_c T>
struct examole_t final : public details::unit_t<T, std::exa, amount_dimension>
{
    using _base = details::unit_t<T, std::exa, amount_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"examole"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Emol"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Emol"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Emol"};
};

template <is_unit_value_type_c T>
examole_t(T) -> examole_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, amount_dimension>
{
    using type = mole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::atto, amount_dimension>
{
    using type = attomole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::femto, amount_dimension>
{
    using type = femtomole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::pico, amount_dimension>
{
    using type = picomole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::nano, amount_dimension>
{
    using type = nanomole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::micro, amount_dimension>
{
    using type = micromole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::milli, amount_dimension>
{
    using type = millimole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::centi, amount_dimension>
{
    using type = centimole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deci, amount_dimension>
{
    using type = decimole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deca, amount_dimension>
{
    using type = decamole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::hecto, amount_dimension>
{
    using type = hectomole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::kilo, amount_dimension>
{
    using type = kilomole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::mega, amount_dimension>
{
    using type = megamole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::giga, amount_dimension>
{
    using type = gigamole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::tera, amount_dimension>
{
    using type = teramole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::peta, amount_dimension>
{
    using type = petamole_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::exa, amount_dimension>
{
    using type = examole_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t intensity_dimension{0, 0, 0, 0, 0, 0, 1, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using intensity_unit_t = details::unit_t<type_t, ratio_t, intensity_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct candela_t final : public details::unit_t<T, std::ratio<1, 1>, intensity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"candela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cd"};
};

template <is_unit_value_type_c T>
candela_t(T) -> candela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
candela_t(const U&) -> candela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct attocandela_t final : public details::unit_t<T, std::atto, intensity_dimension>
{
    using _base = details::unit_t<T, std::atto, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"attocandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"acd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"acd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"acd"};
};

template <is_unit_value_type_c T>
attocandela_t(T) -> attocandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
attocandela_t(const U&) -> attocandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct femtocandela_t final : public details::unit_t<T, std::femto, intensity_dimension>
{
    using _base = details::unit_t<T, std::femto, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"femtocandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"fcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"fcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"fcd"};
};

template <is_unit_value_type_c T>
femtocandela_t(T) -> femtocandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
femtocandela_t(const U&) -> femtocandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct picocandela_t final : public details::unit_t<T, std::pico, intensity_dimension>
{
    using _base = details::unit_t<T, std::pico, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picocandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pcd"};
};

template <is_unit_value_type_c T>
picocandela_t(T) -> picocandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
picocandela_t(const U&) -> picocandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanocandela_t final : public details::unit_t<T, std::nano, intensity_dimension>
{
    using _base = details::unit_t<T, std::nano, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanocandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ncd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ncd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ncd"};
};

template <is_unit_value_type_c T>
nanocandela_t(T) -> nanocandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
nanocandela_t(const U&) -> nanocandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microcandela_t final : public details::unit_t<T, std::micro, intensity_dimension>
{
    using _base = details::unit_t<T, std::micro, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microcandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ucd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5cd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5cd"};
};

template <is_unit_value_type_c T>
microcandela_t(T) -> microcandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
microcandela_t(const U&) -> microcandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct millicandela_t final : public details::unit_t<T, std::milli, intensity_dimension>
{
    using _base = details::unit_t<T, std::milli, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millicandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mcd"};
};

template <is_unit_value_type_c T>
millicandela_t(T) -> millicandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
millicandela_t(const U&) -> millicandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct centicandela_t final : public details::unit_t<T, std::centi, intensity_dimension>
{
    using _base = details::unit_t<T, std::centi, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"centicandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ccd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ccd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ccd"};
};

template <is_unit_value_type_c T>
centicandela_t(T) -> centicandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
centicandela_t(const U&) -> centicandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decicandela_t final : public details::unit_t<T, std::deci, intensity_dimension>
{
    using _base = details::unit_t<T, std::deci, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decicandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dcd"};
};

template <is_unit_value_type_c T>
decicandela_t(T) -> decicandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
decicandela_t(const U&) -> decicandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decacandela_t final : public details::unit_t<T, std::deca, intensity_dimension>
{
    using _base = details::unit_t<T, std::deca, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"decacandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dacd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dacd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dacd"};
};

template <is_unit_value_type_c T>
decacandela_t(T) -> decacandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
decacandela_t(const U&) -> decacandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hectocandela_t final : public details::unit_t<T, std::hecto, intensity_dimension>
{
    using _base = details::unit_t<T, std::hecto, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hectocandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"hcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"hcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"hcd"};
};

template <is_unit_value_type_c T>
hectocandela_t(T) -> hectocandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
hectocandela_t(const U&) -> hectocandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilocandela_t final : public details::unit_t<T, std::kilo, intensity_dimension>
{
    using _base = details::unit_t<T, std::kilo, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilocandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kcd"};
};

template <is_unit_value_type_c T>
kilocandela_t(T) -> kilocandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
kilocandela_t(const U&) -> kilocandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megacandela_t final : public details::unit_t<T, std::mega, intensity_dimension>
{
    using _base = details::unit_t<T, std::mega, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megacandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Mcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Mcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Mcd"};
};

template <is_unit_value_type_c T>
megacandela_t(T) -> megacandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
megacandela_t(const U&) -> megacandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gigacandela_t final : public details::unit_t<T, std::giga, intensity_dimension>
{
    using _base = details::unit_t<T, std::giga, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigacandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Gcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Gcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Gcd"};
};

template <is_unit_value_type_c T>
gigacandela_t(T) -> gigacandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
gigacandela_t(const U&) -> gigacandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct teracandela_t final : public details::unit_t<T, std::tera, intensity_dimension>
{
    using _base = details::unit_t<T, std::tera, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"teracandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Tcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Tcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Tcd"};
};

template <is_unit_value_type_c T>
teracandela_t(T) -> teracandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
teracandela_t(const U&) -> teracandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct petacandela_t final : public details::unit_t<T, std::peta, intensity_dimension>
{
    using _base = details::unit_t<T, std::peta, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"petacandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Pcd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Pcd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Pcd"};
};

template <is_unit_value_type_c T>
petacandela_t(T) -> petacandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
petacandela_t(const U&) -> petacandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct exacandela_t final : public details::unit_t<T, std::exa, intensity_dimension>
{
    using _base = details::unit_t<T, std::exa, intensity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"exacandela"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Ecd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Ecd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Ecd"};
};

template <is_unit_value_type_c T>
exacandela_t(T) -> exacandela_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == intensity_dimension)
exacandela_t(const U&) -> exacandela_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, intensity_dimension>
{
    using type = candela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::atto, intensity_dimension>
{
    using type = attocandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::femto, intensity_dimension>
{
    using type = femtocandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::pico, intensity_dimension>
{
    using type = picocandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::nano, intensity_dimension>
{
    using type = nanocandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::micro, intensity_dimension>
{
    using type = microcandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::milli, intensity_dimension>
{
    using type = millicandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::centi, intensity_dimension>
{
    using type = centicandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deci, intensity_dimension>
{
    using type = decicandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::deca, intensity_dimension>
{
    using type = decacandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::hecto, intensity_dimension>
{
    using type = hectocandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::kilo, intensity_dimension>
{
    using type = kilocandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::mega, intensity_dimension>
{
    using type = megacandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::giga, intensity_dimension>
{
    using type = gigacandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::tera, intensity_dimension>
{
    using type = teracandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::peta, intensity_dimension>
{
    using type = petacandela_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::exa, intensity_dimension>
{
    using type = exacandela_t<T>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct radian_t final : public details::unit_t<T, std::ratio<1, 1>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"radian"};
    [[maybe_unused]] static constexpr std::string_view symbol{"rad"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"rad"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"rad"};
};

template <is_unit_value_type_c T>
radian_t(T) -> radian_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
radian_t(const U&) -> radian_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct degree_t final : public details::unit_t<T, std::ratio<1745329, 100000000>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<1745329, 100000000>, angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"degree"};
    [[maybe_unused]] static constexpr std::string_view symbol{"deg"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00B0"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00B0"};
};

template <is_unit_value_type_c T>
degree_t(T) -> degree_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == angle_dimension)
degree_t(const U&) -> degree_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gradian_t final : public details::unit_t<T, std::ratio<1570796, 100000000>, angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<1570796, 100000000>, angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gradian"};
    [[maybe_unused]] static constexpr std::string_view symbol{"grad"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"gon"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"gon"};
};

template <is_unit_value_type_c T>
gradian_t(T) -> gradian_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, angle_dimension>
{
    using type = radian_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1745329, 100000000>, angle_dimension>
{
    using type = degree_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1570796, 100000000>, angle_dimension>
{
    using type = gradian_t<T>;
};

}

namespace pkr::units
{
inline constexpr dimension_t solid_angle_dimension{0, 0, 0, 0, 0, 0, 0, 0, 1};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using solid_angle_unit_t = details::unit_t<type_t, ratio_t, solid_angle_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct steradian_t final : public details::unit_t<T, std::ratio<1, 1>, solid_angle_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, solid_angle_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"steradian"};
    [[maybe_unused]] static constexpr std::string_view symbol{"sr"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"sr"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"sr"};
};

template <is_unit_value_type_c T>
steradian_t(T) -> steradian_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == solid_angle_dimension)
steradian_t(const U&) -> steradian_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, solid_angle_dimension>
{
    using type = steradian_t<T>;
};

}

namespace pkr::units
{

inline constexpr dimension_t power_dimension{2, 1, -3, 0, 0, 0, 0, 0};

template <is_unit_value_type_c T>
struct watt_t final : public details::unit_t<T, std::ratio<1, 1>, power_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, power_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"watt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"W"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"W"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"W"};
};

template <is_unit_value_type_c T>
watt_t(T) -> watt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == power_dimension)
watt_t(const U&) -> watt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilowatt_t final : public details::unit_t<T, std::ratio<1000, 1>, power_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, power_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilowatt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kW"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kW"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kW"};
};

template <is_unit_value_type_c T>
kilowatt_t(T) -> kilowatt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == power_dimension)
kilowatt_t(const U&) -> kilowatt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct megawatt_t final : public details::unit_t<T, std::ratio<1000000, 1>, power_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, power_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"megawatt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"MW"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"MW"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"MW"};
};

template <is_unit_value_type_c T>
megawatt_t(T) -> megawatt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == power_dimension)
megawatt_t(const U&) -> megawatt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gigawatt_t final : public details::unit_t<T, std::ratio<1000000000, 1>, power_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000000, 1>, power_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gigawatt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"GW"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"GW"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"GW"};
};

template <is_unit_value_type_c T>
gigawatt_t(T) -> gigawatt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == power_dimension)
gigawatt_t(const U&) -> gigawatt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct microwatt_t final : public details::unit_t<T, std::ratio<1, 1000000>, power_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, power_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"microwatt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uW"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5W"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5W"};
};

template <is_unit_value_type_c T>
microwatt_t(T) -> microwatt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == power_dimension)
microwatt_t(const U&) -> microwatt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct milliwatt_t final : public details::unit_t<T, std::ratio<1, 1000>, power_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, power_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"milliwatt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mW"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mW"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mW"};
};

template <is_unit_value_type_c T>
milliwatt_t(T) -> milliwatt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == power_dimension)
milliwatt_t(const U&) -> milliwatt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nanowatt_t final : public details::unit_t<T, std::ratio<1, 1000000000>, power_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, power_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanowatt"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nW"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nW"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nW"};
};

template <is_unit_value_type_c T>
nanowatt_t(T) -> nanowatt_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == power_dimension)
nanowatt_t(const U&) -> nanowatt_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, power_dimension>
{
    using type = watt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, power_dimension>
{
    using type = kilowatt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 1>, power_dimension>
{
    using type = megawatt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000000, 1>, power_dimension>
{
    using type = gigawatt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, power_dimension>
{
    using type = microwatt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, power_dimension>
{
    using type = milliwatt_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000000>, power_dimension>
{
    using type = nanowatt_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t density_dimension{0, 1, 0, 0, 0, 0, 0, -3};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using density_unit_t = details::unit_t<type_t, ratio_t, density_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct kilogram_per_cubic_meter_t final : public details::unit_t<T, std::ratio<1, 1>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilogram per cubic meter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kg/m^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kg\u00B7m\u207B\u00B3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kg\u00B7m\u207B\u00B3"};
};

template <is_unit_value_type_c T>
kilogram_per_cubic_meter_t(T) -> kilogram_per_cubic_meter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
kilogram_per_cubic_meter_t(const U&) -> kilogram_per_cubic_meter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gram_per_cubic_meter_t final : public details::unit_t<T, std::ratio<1, 1000>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gram_per_cubic_meter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"g/m^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"g\u00B7m\u207B\u00B3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"g\u00B7m\u207B\u00B3"};
};

template <is_unit_value_type_c T>
gram_per_cubic_meter_t(T) -> gram_per_cubic_meter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
gram_per_cubic_meter_t(const U&) -> gram_per_cubic_meter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gram_per_cubic_centimeter_t final : public details::unit_t<T, std::ratio<1000000, 1>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gram_per_cubic_centimeter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"g/cm^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"g\u00B7cm\u207B\u00B3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"g\u00B7cm\u207B\u00B3"};
};

template <is_unit_value_type_c T>
gram_per_cubic_centimeter_t(T) -> gram_per_cubic_centimeter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
gram_per_cubic_centimeter_t(const U&) -> gram_per_cubic_centimeter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gram_per_milliliter_t final : public details::unit_t<T, std::ratio<1000000, 1>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gram_per_milliliter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"g/mL"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"g\u00B7mL\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"g\u00B7mL\u207B\u00B9"};
};

template <is_unit_value_type_c T>
gram_per_milliliter_t(T) -> gram_per_milliliter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
gram_per_milliliter_t(const U&) -> gram_per_milliliter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct kilogram_per_liter_t final : public details::unit_t<T, std::ratio<1000, 1>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"kilogram_per_liter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kg/L"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kg\u00B7L\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kg\u00B7L\u207B\u00B9"};
};

template <is_unit_value_type_c T>
kilogram_per_liter_t(T) -> kilogram_per_liter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
kilogram_per_liter_t(const U&) -> kilogram_per_liter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct gram_per_liter_t final : public details::unit_t<T, std::ratio<1, 1>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"gram_per_liter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"g/L"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"g\u00B7L\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"g\u00B7L\u207B\u00B9"};
};

template <is_unit_value_type_c T>
gram_per_liter_t(T) -> gram_per_liter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
gram_per_liter_t(const U&) -> gram_per_liter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct milligram_per_cubic_centimeter_t final : public details::unit_t<T, std::ratio<1000, 1>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"milligram_per_cubic_centimeter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mg/cm^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mg\u00B7cm\u207B\u00B3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mg\u00B7cm\u207B\u00B3"};
};

template <is_unit_value_type_c T>
milligram_per_cubic_centimeter_t(T) -> milligram_per_cubic_centimeter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
milligram_per_cubic_centimeter_t(const U&) -> milligram_per_cubic_centimeter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct milligram_per_milliliter_t final : public details::unit_t<T, std::ratio<1000, 1>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"milligram_per_milliliter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mg/mL"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mg\u00B7mL\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mg\u00B7mL\u207B\u00B9"};
};

template <is_unit_value_type_c T>
milligram_per_milliliter_t(T) -> milligram_per_milliliter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
milligram_per_milliliter_t(const U&) -> milligram_per_milliliter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct ton_per_cubic_meter_t final : public details::unit_t<T, std::ratio<1000000, 1>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"ton_per_cubic_meter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"t/m^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"t\u00B7m\u207B\u00B3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"t\u00B7m\u207B\u00B3"};
};

template <is_unit_value_type_c T>
ton_per_cubic_meter_t(T) -> ton_per_cubic_meter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
ton_per_cubic_meter_t(const U&) -> ton_per_cubic_meter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct atomic_mass_unit_per_cubic_angstrom_t final : public details::unit_t<T, std::ratio<166054, 1>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<166054, 1>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"atomic_mass_unit_per_cubic_angstrom"};
    [[maybe_unused]] static constexpr std::string_view symbol{"u/A^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"u\u00B7\u00C5\u207B\u00B3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"u\u00B7\u00C5\u207B\u00B3"};
};

template <is_unit_value_type_c T>
atomic_mass_unit_per_cubic_angstrom_t(T) -> atomic_mass_unit_per_cubic_angstrom_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, density_dimension>
{
    using type = kilogram_per_cubic_meter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, density_dimension>
{
    using type = gram_per_cubic_meter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 1>, density_dimension>
{
    using type = gram_per_cubic_centimeter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, density_dimension>
{
    using type = kilogram_per_liter_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<166054, 1>, density_dimension>
{
    using type = atomic_mass_unit_per_cubic_angstrom_t<T>;
};
}

namespace pkr::units
{

inline constexpr dimension_t mass_concentration_v{-3, 1, 0, 0, 0, 0, 0, 0};

inline constexpr dimension_t molar_concentration_v{-3, 0, 0, 0, 0, 1, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using mass_concentration_unit_t = details::unit_t<type_t, ratio_t, mass_concentration_v>;

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using molar_concentration_unit_t = details::unit_t<type_t, ratio_t, molar_concentration_v>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct mole_per_cubic_meter_concentration_t final : public details::unit_t<T, std::ratio<1, 1>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"mole_per_cubic_meter_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mol/m^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mol\u00B7m\u207B\u00B3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mol\u00B7m\u207B\u00B3"};
};

template <is_unit_value_type_c T>
mole_per_cubic_meter_concentration_t(T) -> mole_per_cubic_meter_concentration_t<T>;

template <is_unit_value_type_c T>
struct mole_per_liter_concentration_t final : public details::unit_t<T, std::ratio<1000, 1>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"mole_per_liter_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mol/L"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mol\u00B7L\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mol\u00B7L\u207B\u00B9"};
};

template <is_unit_value_type_c T>
mole_per_liter_concentration_t(T) -> mole_per_liter_concentration_t<T>;

template <is_unit_value_type_c T>
struct molar_concentration_t final : public details::unit_t<T, std::ratio<1000, 1>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"molar_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"M"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"M"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"M"};
};

template <is_unit_value_type_c T>
molar_concentration_t(T) -> molar_concentration_t<T>;

template <is_unit_value_type_c T>
struct millimolar_concentration_t final : public details::unit_t<T, std::ratio<1, 1>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"millimolar_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mM"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mM"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mM"};
};

template <is_unit_value_type_c T>
millimolar_concentration_t(T) -> millimolar_concentration_t<T>;

template <is_unit_value_type_c T>
struct micromolar_concentration_t final : public details::unit_t<T, std::ratio<1, 1000>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"micromolar_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"uM"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b5M"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b5M"};
};

template <is_unit_value_type_c T>
micromolar_concentration_t(T) -> micromolar_concentration_t<T>;

template <is_unit_value_type_c T>
struct nanomolar_concentration_t final : public details::unit_t<T, std::ratio<1, 1000000>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nanomolar_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nM"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nM"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nM"};
};

template <is_unit_value_type_c T>
nanomolar_concentration_t(T) -> nanomolar_concentration_t<T>;

template <is_unit_value_type_c T>
struct picomolar_concentration_t final : public details::unit_t<T, std::ratio<1, 1000000000>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"picomolar_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pM"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pM"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pM"};
};

template <is_unit_value_type_c T>
picomolar_concentration_t(T) -> picomolar_concentration_t<T>;

template <is_unit_value_type_c T>
struct mole_per_cubic_centimeter_concentration_t final : public details::unit_t<T, std::ratio<1000000, 1>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"mole_per_cubic_centimeter_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mol/cm^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mol\u00B7cm\u207B\u00B3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mol\u00B7cm\u207B\u00B3"};
};

template <is_unit_value_type_c T>
mole_per_cubic_centimeter_concentration_t(T) -> mole_per_cubic_centimeter_concentration_t<T>;

template <is_unit_value_type_c T>
struct mole_per_milliliter_concentration_t final : public details::unit_t<T, std::ratio<1000000, 1>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"mole_per_milliliter_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mol/mL"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mol\u00B7mL\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mol\u00B7mL\u207B\u00B9"};
};

template <is_unit_value_type_c T>
mole_per_milliliter_concentration_t(T) -> mole_per_milliliter_concentration_t<T>;

template <is_unit_value_type_c T>
struct osmole_per_liter_concentration_t final : public details::unit_t<T, std::ratio<1000, 1>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1000, 1>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"osmole_per_liter_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Osm/L"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Osm\u00B7L\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Osm\u00B7L\u207B\u00B9"};
};

template <is_unit_value_type_c T>
osmole_per_liter_concentration_t(T) -> osmole_per_liter_concentration_t<T>;

template <is_unit_value_type_c T>
struct milliosmole_per_liter_concentration_t final : public details::unit_t<T, std::ratio<1, 1>, molar_concentration_v>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, molar_concentration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"milliosmole_per_liter_concentration"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mOsm/L"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mOsm\u00B7L\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mOsm\u00B7L\u207B\u00B9"};
};

template <is_unit_value_type_c T>
milliosmole_per_liter_concentration_t(T) -> milliosmole_per_liter_concentration_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000, 1>, molar_concentration_v>
{
    using type = mole_per_liter_concentration_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, molar_concentration_v>
{
    using type = millimolar_concentration_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000>, molar_concentration_v>
{
    using type = micromolar_concentration_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1000000>, molar_concentration_v>
{
    using type = nanomolar_concentration_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1000000, 1>, molar_concentration_v>
{
    using type = mole_per_cubic_centimeter_concentration_t<T>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1000, 1>, molar_concentration_v>
{
    using type = mole_per_liter_concentration_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1>, molar_concentration_v>
{
    using type = millimolar_concentration_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1000>, molar_concentration_v>
{
    using type = micromolar_concentration_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1000000>, molar_concentration_v>
{
    using type = nanomolar_concentration_t<double>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1000000, 1>, molar_concentration_v>
{
    using type = mole_per_cubic_centimeter_concentration_t<double>;
};
}

namespace pkr::units
{

inline constexpr dimension_t specific_heat_capacity_dimension{2, 0, -2, 0, -1, 0, 0, 0};

template <is_unit_value_type_c T>
struct specific_heat_capacity_t final : public details::unit_t<T, std::ratio<1, 1>, specific_heat_capacity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, specific_heat_capacity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"specific_heat_capacity"};
    [[maybe_unused]] static constexpr std::string_view symbol{"J/(kg*K)"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"J\u00B7kg\u207B\u00B9\u00B7K\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"J\u00B7kg\u207B\u00B9\u00B7K\u207B\u00B9"};
};

template <is_unit_value_type_c T>
specific_heat_capacity_t(T) -> specific_heat_capacity_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, specific_heat_capacity_dimension>
{
    using type = specific_heat_capacity_t<T>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1>, specific_heat_capacity_dimension>
{
    using type = specific_heat_capacity_t<double>;
};
}

namespace pkr::units
{

inline constexpr dimension_t thermal_conductivity_dimension{1, 1, -3, 0, -1, 0, 0, 0};

template <is_unit_value_type_c T>
struct thermal_conductivity_t final : public details::unit_t<T, std::ratio<1, 1>, thermal_conductivity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, thermal_conductivity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"thermal_conductivity"};
    [[maybe_unused]] static constexpr std::string_view symbol{"W/(m*K)"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"W\u00B7m\u207B\u00B9\u00B7K\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"W\u00B7m\u207B\u00B9\u00B7K\u207B\u00B9"};
};

template <is_unit_value_type_c T>
thermal_conductivity_t(T) -> thermal_conductivity_t<T>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, thermal_conductivity_dimension>
{
    using type = thermal_conductivity_t<T>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1>, thermal_conductivity_dimension>
{
    using type = thermal_conductivity_t<double>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct pascal_second_t final : public details::unit_t<T, std::ratio<1, 1>, dynamic_viscosity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, dynamic_viscosity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"pascal_second"};
    [[maybe_unused]] static constexpr std::string_view symbol{"Pa*s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"Pa\u00B7s"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"Pa\u00B7s"};
};

template <is_unit_value_type_c T>
pascal_second_t(T) -> pascal_second_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == dynamic_viscosity_dimension)
pascal_second_t(const U&) -> pascal_second_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct square_meter_per_second_t final : public details::unit_t<T, std::ratio<1, 1>, kinematic_viscosity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, kinematic_viscosity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"square_meter_per_second"};
    [[maybe_unused]] static constexpr std::string_view symbol{"m^2/s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"m\u00B2\u00B7s\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"m\u00B2\u00B7s\u207B\u00B9"};
};

template <is_unit_value_type_c T>
square_meter_per_second_t(T) -> square_meter_per_second_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == kinematic_viscosity_dimension)
square_meter_per_second_t(const U&) -> square_meter_per_second_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, dynamic_viscosity_dimension>
{
    using type = pascal_second_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, kinematic_viscosity_dimension>
{
    using type = square_meter_per_second_t<T>;
};
}

namespace pkr::units
{
template <is_unit_value_type_c T>
struct lumen_t final : public details::unit_t<T, std::ratio<1, 1>, dimension_t{0, 0, 0, 0, 0, 0, 1, 0, 1}>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, dimension_t{0, 0, 0, 0, 0, 0, 1, 0, 1}>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"lumen"};
    [[maybe_unused]] static constexpr std::string_view symbol{"lm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cd\u00b7sr"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cd\u00b7sr"};
};

template <is_unit_value_type_c T>
lumen_t(T) -> lumen_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == dimension_t{0, 0, 0, 0, 0, 0, 1, 0, 1})
lumen_t(const U&) -> lumen_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, dimension_t{0, 0, 0, 0, 0, 0, 1, 0, 1}>
{
    using type = lumen_t<T>;
};
}

namespace pkr::units
{
template <is_unit_value_type_c T>
struct lux_t final : public details::unit_t<T, std::ratio<1, 1>, dimension_t{-2, 0, 0, 0, 0, 0, 1, 0, 1}>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, dimension_t{-2, 0, 0, 0, 0, 0, 1, 0, 1}>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"lux"};
    [[maybe_unused]] static constexpr std::string_view symbol{"lx"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cd\u00b7sr\u00b7m\u207b\u00b2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cd\u00b7sr\u00b7m\u207b\u00b2"};
};

template <is_unit_value_type_c T>
lux_t(T) -> lux_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == dimension_t{-2, 0, 0, 0, 0, 0, 1, 0, 1})
lux_t(const U&) -> lux_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, dimension_t{-2, 0, 0, 0, 0, 0, 1, 0, 1}>
{
    using type = lux_t<T>;
};
}
namespace pkr::units
{
template <is_unit_value_type_c T>
struct watt_per_steradian_t final : public details::unit_t<T, std::ratio<1, 1>, dimension_t{1, 2, -3, 0, 0, 0, 0, 0, -1}>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, dimension_t{1, 2, -3, 0, 0, 0, 0, 0, -1}>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"watt_per_steradian"};
    [[maybe_unused]] static constexpr std::string_view symbol{"W/sr"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"W\u00B7sr\u207B\u00B9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"W\u00B7sr\u207B\u00B9"};
};

template <is_unit_value_type_c T>
watt_per_steradian_t(T) -> watt_per_steradian_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == dimension_t{1, 2, -3, 0, 0, 0, 0, 0, -1})
watt_per_steradian_t(const U&) -> watt_per_steradian_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, dimension_t{1, 2, -3, 0, 0, 0, 0, 0, -1}>
{
    using type = watt_per_steradian_t<T>;
};

template <>
struct details::derived_unit_type_t<double, std::ratio<1, 1>, dimension_t{1, 2, -3, 0, 0, 0, 0, 0, -1}>
{
    using type = watt_per_steradian_t<double>;
};
}
namespace pkr::units
{
template <is_unit_value_type_c T>
struct watt_per_square_meter_per_steradian_t final : public details::unit_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, -1}>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, -1}>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"watt_per_square_meter_per_steradian"};
    [[maybe_unused]] static constexpr std::string_view symbol{"W/(m2·sr)"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"W\u00b7m\u207b\u00b2\u00b7sr\u207b\u00b9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"W\u00b7m\u207b\u00b2\u00b7sr\u207b\u00b9"};
};

template <is_unit_value_type_c T>
watt_per_square_meter_per_steradian_t(T) -> watt_per_square_meter_per_steradian_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == dimension_t{1, -2, -3, 0, 0, 0, 0, 0, -1})
watt_per_square_meter_per_steradian_t(const U&) -> watt_per_square_meter_per_steradian_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct radiance_t final : public details::unit_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, -1}>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, -1}>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"radiance"};
    [[maybe_unused]] static constexpr std::string_view symbol{"W/(m2·sr)"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"W\u00b7m\u207b\u00b2\u00b7sr\u207b\u00b9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"W\u00b7m\u207b\u00b2\u00b7sr\u207b\u00b9"};
};

template <is_unit_value_type_c T>
radiance_t(T) -> radiance_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == dimension_t{1, -2, -3, 0, 0, 0, 0, 0, -1})
radiance_t(const U&) -> radiance_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, -1}>
{
    using type = radiance_t<T>;
};
}

namespace pkr::units
{
template <is_unit_value_type_c T>
struct watt_per_square_meter_t final : public details::unit_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, 0}>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, 0}>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"watt_per_square_meter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"W/m2"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"W\u00b7m\u207b\u00b2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"W\u00b7m\u207b\u00b2"};
};

template <is_unit_value_type_c T>
watt_per_square_meter_t(T) -> watt_per_square_meter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == dimension_t{1, -2, -3, 0, 0, 0, 0, 0, 0})
watt_per_square_meter_t(const U&) -> watt_per_square_meter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct irradiance_t final : public details::unit_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, 0}>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, 0}>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"irradiance"};
    [[maybe_unused]] static constexpr std::string_view symbol{"W/m2"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"W\u00b7m\u207b\u00b2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"W\u00b7m\u207b\u00b2"};
};

template <is_unit_value_type_c T>
irradiance_t(T) -> irradiance_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == dimension_t{1, -2, -3, 0, 0, 0, 0, 0, 0})
irradiance_t(const U&) -> irradiance_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, dimension_t{1, -2, -3, 0, 0, 0, 0, 0, 0}>
{
    using type = irradiance_t<T>;
};
}

namespace pkr::units
{
template <is_unit_value_type_c T>
struct scalar_t final : public details::unit_t<T, std::ratio<1, 1>, scalar_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, scalar_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"scalar"};
    [[maybe_unused]] static constexpr std::string_view symbol{""};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L""};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8""};
};

template <is_unit_value_type_c T>
scalar_t(T) -> scalar_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == scalar_dimension)
scalar_t(const U&) -> scalar_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1, 1>, scalar_dimension>
{
    using type = scalar_t<T>;
};
}
namespace pkr::units
{
template <typename T, typename Ratio1, dimension_t Dim, typename Ratio2>
constexpr auto add(const details::unit_t<T, Ratio1, Dim>& a, const details::unit_t<T, Ratio2, Dim>& b)
{
    return a + b;
}

template <typename T, typename Ratio1, dimension_t Dim, typename Ratio2>
constexpr auto subtract(const details::unit_t<T, Ratio1, Dim>& a, const details::unit_t<T, Ratio2, Dim>& b)
{
    return a - b;
}

template <typename T, typename Ratio1, dimension_t Dim1, typename Ratio2, dimension_t Dim2>
constexpr auto multiply(const details::unit_t<T, Ratio1, Dim1>& a, const details::unit_t<T, Ratio2, Dim2>& b)
{
    return a * b;
}

template <typename T, typename Ratio1, dimension_t Dim1, typename Ratio2, dimension_t Dim2>
constexpr auto divide(const details::unit_t<T, Ratio1, Dim1>& a, const details::unit_t<T, Ratio2, Dim2>& b)
{
    return a / b;
}

template <typename T, typename Ratio, dimension_t Dim>
constexpr auto multiply_scalar(const details::unit_t<T, Ratio, Dim>& a, T scalar)
{
    return a * scalar;
}

template <typename T, typename Ratio, dimension_t Dim>
constexpr auto divide_scalar(const details::unit_t<T, Ratio, Dim>& a, T scalar)
{
    return a / scalar;
}

template <typename T, typename Ratio, dimension_t Dim>
    requires pkr_unit_can_take_square_root_c<Dim>
auto sqrt(const details::unit_t<T, Ratio, Dim>& a)
{

    using result_ratio = Ratio;
    constexpr dimension_t result_dim = {
        Dim.length / 2,
        Dim.mass / 2,
        Dim.time / 2,
        Dim.current / 2,
        Dim.temperature / 2,
        Dim.amount / 2,
        Dim.intensity / 2,
        Dim.angle / 2};
    return details::unit_t<T, result_ratio, result_dim>{std::sqrt(a.value())};
}

template <typename T, typename Ratio, dimension_t Dim>
constexpr auto square(const details::unit_t<T, Ratio, Dim>& a)
{

    using result_ratio = Ratio;
    constexpr dimension_t result_dim = {
        Dim.length * 2, Dim.mass * 2, Dim.time * 2, Dim.current * 2, Dim.temperature * 2, Dim.amount * 2, Dim.intensity * 2, Dim.angle * 2};
    return details::unit_t<T, result_ratio, result_dim>{a.value() * a.value()};
}

template <typename T, typename Ratio, dimension_t Dim>
constexpr auto cube(const details::unit_t<T, Ratio, Dim>& a)
{
    using result_ratio = Ratio;
    constexpr dimension_t result_dim = {
        Dim.length * 3, Dim.mass * 3, Dim.time * 3, Dim.current * 3, Dim.temperature * 3, Dim.amount * 3, Dim.intensity * 3, Dim.angle * 3};
    return details::unit_t<T, result_ratio, result_dim>{a.value() * a.value() * a.value()};
}

template <typename T, typename Ratio, dimension_t Dim>
auto exp(const details::unit_t<T, Ratio, Dim>& a)
{
    static_assert(
        Dim.length == 0 && Dim.mass == 0 && Dim.time == 0 && Dim.current == 0 && Dim.temperature == 0 && Dim.amount == 0 && Dim.intensity == 0 &&
            Dim.angle == 0,
        "exp() requires dimensionless input");
    return details::unit_t<T, std::ratio<1, 1>, scalar_dimension>{std::exp(a.value())};
}

template <typename T, typename Ratio, dimension_t Dim>
auto log(const details::unit_t<T, Ratio, Dim>& a)
{
    static_assert(
        Dim.length == 0 && Dim.mass == 0 && Dim.time == 0 && Dim.current == 0 && Dim.temperature == 0 && Dim.amount == 0 && Dim.intensity == 0 &&
            Dim.angle == 0,
        "log() requires dimensionless input");
    return details::unit_t<T, std::ratio<1, 1>, scalar_dimension>{std::log(a.value())};
}

template <typename T, typename Ratio, dimension_t Dim, typename ExpT, typename ExpRatio>
auto pow(const details::unit_t<T, Ratio, Dim>& base, const details::unit_t<ExpT, ExpRatio, scalar_dimension>& exponent)
{

    return details::unit_t<T, Ratio, Dim>{std::pow(base.value(), exponent.value())};
}

template <int N, typename T, typename Ratio, dimension_t Dim>
auto pow(const details::unit_t<T, Ratio, Dim>& base)
{

    constexpr dimension_t powered_dim{
        .length = static_cast<signed char>(Dim.length * N),
        .mass = static_cast<signed char>(Dim.mass * N),
        .time = static_cast<signed char>(Dim.time * N),
        .current = static_cast<signed char>(Dim.current * N),
        .temperature = static_cast<signed char>(Dim.temperature * N),
        .amount = static_cast<signed char>(Dim.amount * N),
        .intensity = static_cast<signed char>(Dim.intensity * N),
        .angle = static_cast<signed char>(Dim.angle * N)};

    if constexpr (std::is_same_v<Ratio, std::ratio<1, 1>>)
    {
        using result_type = typename details::derived_unit_type_t<T, std::ratio<1, 1>, powered_dim>::type;
        if constexpr (N == 0)
            return result_type{1.0};
        else if constexpr (N == 1)
            return result_type{base.value()};
        else if constexpr (N > 0)
        {
            T result = base.value();
            for (int i = 1; i < N; ++i)
                result *= base.value();
            return result_type{result};
        }
        else
        {
            T result = 1.0 / base.value();
            for (int i = 1; i < -N; ++i)
                result /= base.value();
            return result_type{result};
        }
    }
    else
    {

        using result_type = details::unit_t<T, Ratio, powered_dim>;
        if constexpr (N == 0)
            return result_type{1.0};
        else if constexpr (N == 1)
            return result_type{base.value()};
        else if constexpr (N > 0)
        {
            T result = base.value();
            for (int i = 1; i < N; ++i)
                result *= base.value();
            return result_type{result};
        }
        else
        {
            T result = 1.0 / base.value();
            for (int i = 1; i < -N; ++i)
                result /= base.value();
            return result_type{result};
        }
    }
}

template <is_base_pkr_unit_c T>
auto exp(const T& x) noexcept
{
    constexpr auto dim = details::is_pkr_unit<T>::value_dimension;
    static_assert(
        dim.length == 0 && dim.mass == 0 && dim.time == 0 && dim.current == 0 && dim.temperature == 0 && dim.amount == 0 && dim.intensity == 0 &&
            dim.angle == 0,
        "exp() only works on dimensionless units");
    return T{std::exp(x.value())};
}

template <is_base_pkr_unit_c T>
auto log(const T& x)
{
    constexpr auto dim = details::is_pkr_unit<T>::value_dimension;
    static_assert(
        dim.length == 0 && dim.mass == 0 && dim.time == 0 && dim.current == 0 && dim.temperature == 0 && dim.amount == 0 && dim.intensity == 0 &&
            dim.angle == 0,
        "log() only works on dimensionless units");
    if (x.value() <= 0)
    {
        throw std::invalid_argument("log of non-positive value");
    }

    return details::unit_t<typename details::is_pkr_unit<T>::value_type, std::ratio<1, 1>, dimension_t{}>{std::log(x.value())};
}

template <is_base_pkr_unit_c T>
auto sqrt(const T& x)
{
    using value_type = typename details::is_pkr_unit<T>::value_type;
    using ratio = typename details::is_pkr_unit<T>::ratio_type;
    constexpr auto dim = details::is_pkr_unit<T>::value_dimension;

    using sqrt_ratio = ratio;

    constexpr dimension_t sqrt_dim{
        .length = dim.length / 2,
        .mass = dim.mass / 2,
        .time = dim.time / 2,
        .current = dim.current / 2,
        .temperature = dim.temperature / 2,
        .amount = dim.amount / 2,
        .intensity = dim.intensity / 2,
        .angle = dim.angle / 2};
    if (x.value() < 0)
    {
        throw std::invalid_argument("sqrt of negative value");
    }
    return details::unit_t<value_type, sqrt_ratio, sqrt_dim>{std::sqrt(x.value())};
}

template <is_base_pkr_unit_c T>
constexpr auto normalize(const T& unit) noexcept
{
    return unit.in_base_si_units();
}

template <is_angle_unit_c T>
auto sin(const T& angle) noexcept
{
    return scalar_t{std::sin(angle.value())};
}

template <is_angle_unit_c T>
auto cos(const T& angle) noexcept
{
    return scalar_t{std::cos(angle.value())};
}

template <is_angle_unit_c T>
auto tan(const T& angle) noexcept
{
    return scalar_t{std::tan(angle.value())};
}
}

namespace pkr::units
{

namespace details
{

template <typename T>
constexpr T solar_mass_kg()
{
    return static_cast<T>(1.989e30);
}

}

namespace constants
{

constexpr auto solar_mass_kg = details::solar_mass_kg<double>();

constexpr auto solar_mass = pkr::units::kilogram_t(solar_mass_kg);

namespace details
{
template <typename T>
constexpr T gravitational_constant_value()
{
    return static_cast<T>(6.67430e-11);
}
}

constexpr auto gravitational_constant_value = details::gravitational_constant_value<double>();

inline constexpr dimension_t gravitational_constant_dimension{3, -1, -2, 0, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using gravitational_constant_unit_t = ::pkr::units::details::unit_t<type_t, ratio_t, gravitational_constant_dimension>;

constexpr auto gravitational_constant = gravitational_constant_unit_t<>{gravitational_constant_value};

}

}
namespace pkr::units
{

namespace details
{
template <typename T>
constexpr T bohr_radius()
{
    return static_cast<T>(5.29177210544e-11);
}

template <typename T>
constexpr T rydberg_constant()
{
    return static_cast<T>(10973731.568157);
}

template <typename T>
constexpr T hartree_energy()
{
    return static_cast<T>(4.3597447222060e-18);
}

template <typename T>
constexpr T hartree_energy_ev()
{
    return static_cast<T>(27.211386245981);
}

}

constexpr meter_t bohr_radius{details::bohr_radius<double>()};
constexpr auto rydberg_constant = details::rydberg_constant<double>();
constexpr joule_t hartree_energy{details::hartree_energy<double>()};

}
namespace pkr::units
{

namespace details
{
template <typename T>
constexpr T electron_volt()
{
    return static_cast<T>(1.602176634e-19);
}

template <typename T>
constexpr T hartree_in_ev()
{
    return static_cast<T>(27.211386245981);
}

template <typename T>
constexpr T atomic_mass_unit_in_ev()
{
    return static_cast<T>(931494103.72);
}

template <typename T>
constexpr T atomic_mass_unit_in_hz()
{
    return static_cast<T>(2.25234272185e23);
}
template <typename T>
constexpr T ev_in_hz()
{
    return static_cast<T>(2.417989242e14);
}

template <typename T>
constexpr T ev_in_inverse_meter()
{
    return static_cast<T>(8.065543937e5);
}

template <typename T>
constexpr T hz_in_inverse_meter()
{
    return static_cast<T>(3.335640951e-9);
}

}

constexpr auto electron_volt = details::electron_volt<double>();
constexpr auto hartree_in_ev = details::hartree_in_ev<double>();
constexpr auto atomic_mass_unit_in_ev = details::atomic_mass_unit_in_ev<double>();
constexpr auto atomic_mass_unit_in_hz = details::atomic_mass_unit_in_hz<double>();

constexpr auto ev_in_hz = details::ev_in_hz<double>();
constexpr auto ev_in_inverse_meter = details::ev_in_inverse_meter<double>();
constexpr auto hz_in_inverse_meter = details::hz_in_inverse_meter<double>();

}

namespace pkr::units
{

inline constexpr dimension_t josephson_dimension{-2, -1, 2, 1, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using josephson_unit_t = details::unit_t<type_t, ratio_t, josephson_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct josephson_t final : public details::unit_t<T, std::ratio<1, 1>, josephson_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, josephson_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"josephson"};
    [[maybe_unused]] static constexpr std::string_view symbol{"K_J"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"K_J"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"K_J"};
};

template <is_unit_value_type_c T>
josephson_t(T) -> josephson_t<T>;
}

namespace pkr::units
{

namespace details
{
template <typename T>
constexpr T vacuum_impedance()
{
    return static_cast<T>(376.730313412);
}

template <typename T>
constexpr T josephson_constant()
{
    return static_cast<T>(483597.8484e9);
}

template <typename T>
constexpr T von_klitzing_constant()
{
    return static_cast<T>(25812.80745);
}

template <typename T>
constexpr T magnetic_flux_quantum()
{
    return static_cast<T>(2.067833848e-15);
}

template <typename T>
constexpr T conductance_quantum()
{
    return static_cast<T>(7.748091729e-5);
}

template <typename T>
constexpr T inverse_conductance_quantum()
{
    return static_cast<T>(12906.40372);
}

}

constexpr ohm_t vacuum_impedance{details::vacuum_impedance<double>()};
constexpr josephson_t josephson_constant{details::josephson_constant<double>()};
constexpr ohm_t von_klitzing_constant{details::von_klitzing_constant<double>()};
constexpr weber_t magnetic_flux_quantum{details::magnetic_flux_quantum<double>()};
constexpr siemens_t conductance_quantum{details::conductance_quantum<double>()};
constexpr ohm_t inverse_conductance_quantum{details::inverse_conductance_quantum<double>()};

}

namespace pkr::units
{

inline constexpr dimension_t area_dimension{2, 0, 0, 0, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using area_unit_t = details::unit_t<type_t, ratio_t, area_dimension>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct square_meter_t final : public details::unit_t<T, std::ratio<1, 1>, area_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, area_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"square meter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"m^2"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"m\u00b2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"m\u00b2"};
};

template <is_unit_value_type_c T>
square_meter_t(T) -> square_meter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == area_dimension)
square_meter_t(const U&) -> square_meter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct square_kilometer_t final : public details::unit_t<T, std::ratio<1000000, 1>, area_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000, 1>, area_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"square kilometer"};
    [[maybe_unused]] static constexpr std::string_view symbol{"km^2"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"km\u00b2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"km\u00b2"};
};

template <is_unit_value_type_c T>
square_kilometer_t(T) -> square_kilometer_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == area_dimension)
square_kilometer_t(const U&) -> square_kilometer_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct square_centimeter_t final : public details::unit_t<T, std::ratio<1, 10000>, area_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 10000>, area_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"square centimeter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cm^2"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cm\u00b2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cm\u00b2"};
};

template <is_unit_value_type_c T>
square_centimeter_t(T) -> square_centimeter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == area_dimension)
square_centimeter_t(const U&) -> square_centimeter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct square_millimeter_t final : public details::unit_t<T, std::ratio<1, 1000000>, area_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, area_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"square millimeter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mm^2"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mm\u00b2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mm\u00b2"};
};

template <is_unit_value_type_c T>
square_millimeter_t(T) -> square_millimeter_t<T>;
}

namespace pkr::units
{

namespace details
{
template <typename T>
constexpr T fermi_coupling_constant()
{
    return static_cast<T>(1.1663787e-5);
}

template <typename T>
constexpr T weak_mixing_angle()
{
    return static_cast<T>(0.22305);
}

template <typename T>
constexpr T classical_electron_radius()
{
    return static_cast<T>(2.8179403205e-15);
}

template <typename T>
constexpr T thomson_cross_section()
{
    return static_cast<T>(6.6524587051e-29);
}

template <typename T>
constexpr T neutron_compton_wavelength()
{
    return static_cast<T>(1.31959090382e-15);
}

template <typename T>
constexpr T proton_compton_wavelength()
{
    return static_cast<T>(1.32140985360e-15);
}

}

constexpr auto fermi_coupling_constant = details::fermi_coupling_constant<double>();
constexpr auto weak_mixing_angle = details::weak_mixing_angle<double>();
constexpr meter_t classical_electron_radius{details::classical_electron_radius<double>()};
constexpr square_meter_t thomson_cross_section{details::thomson_cross_section<double>()};
constexpr meter_t neutron_compton_wavelength{details::neutron_compton_wavelength<double>()};
constexpr meter_t proton_compton_wavelength{details::proton_compton_wavelength<double>()};

}
namespace pkr::units
{

namespace details
{
template <typename T>
constexpr T muon_mass()
{
    return static_cast<T>(1.883531627e-28);
}

template <typename T>
constexpr T tau_mass()
{
    return static_cast<T>(3.16754e-27);
}
template <typename T>
constexpr T deuteron_mass()
{
    return static_cast<T>(3.3435837768e-27);
}

template <typename T>
constexpr T triton_mass()
{
    return static_cast<T>(5.0073567512e-27);
}

template <typename T>
constexpr T helion_mass()
{
    return static_cast<T>(5.0064127862e-27);
}

template <typename T>
constexpr T alpha_particle_mass()
{
    return static_cast<T>(6.6446573450e-27);
}

}

constexpr kilogram_t muon_mass{details::muon_mass<double>()};
constexpr kilogram_t tau_mass{details::tau_mass<double>()};
constexpr kilogram_t deuteron_mass{details::deuteron_mass<double>()};
constexpr kilogram_t triton_mass{details::triton_mass<double>()};
constexpr kilogram_t helion_mass{details::helion_mass<double>()};
constexpr kilogram_t alpha_particle_mass{details::alpha_particle_mass<double>()};

}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct inch_t final : public details::unit_t<T, std::ratio<254, 10000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<254, 10000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"inch"};
    [[maybe_unused]] static constexpr std::string_view symbol{"in"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"in"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"in"};
};

template <is_unit_value_type_c T>
inch_t(T) -> inch_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
inch_t(const U&) -> inch_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct mil_t final : public details::unit_t<T, std::ratio<254, 10000000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<254, 10000000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"mil"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mil"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mil"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mil"};
};

template <is_unit_value_type_c T>
mil_t(T) -> mil_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
mil_t(const U&) -> mil_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct foot_t final : public details::unit_t<T, std::ratio<3048, 10000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<3048, 10000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"foot"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ft"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ft"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ft"};
};

template <is_unit_value_type_c T>
foot_t(T) -> foot_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
foot_t(const U&) -> foot_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct yard_t final : public details::unit_t<T, std::ratio<9144, 10000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<9144, 10000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"yard"};
    [[maybe_unused]] static constexpr std::string_view symbol{"yd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"yd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"yd"};
};

template <is_unit_value_type_c T>
yard_t(T) -> yard_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
yard_t(const U&) -> yard_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct fathom_t final : public details::unit_t<T, std::ratio<18288, 10000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<18288, 10000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"fathom"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ftm"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ftm"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ftm"};
};

template <is_unit_value_type_c T>
fathom_t(T) -> fathom_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
fathom_t(const U&) -> fathom_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct rod_t final : public details::unit_t<T, std::ratio<50292, 10000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<50292, 10000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"rod"};
    [[maybe_unused]] static constexpr std::string_view symbol{"rd"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"rd"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"rd"};
};

template <is_unit_value_type_c T>
rod_t(T) -> rod_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
rod_t(const U&) -> rod_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct chain_t final : public details::unit_t<T, std::ratio<201168, 10000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<201168, 10000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"chain"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ch"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ch"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ch"};
};

template <is_unit_value_type_c T>
chain_t(T) -> chain_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
chain_t(const U&) -> chain_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct furlong_t final : public details::unit_t<T, std::ratio<201168, 1000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<201168, 1000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"furlong"};
    [[maybe_unused]] static constexpr std::string_view symbol{"fur"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"fur"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"fur"};
};

template <is_unit_value_type_c T>
furlong_t(T) -> furlong_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
furlong_t(const U&) -> furlong_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct mile_t final : public details::unit_t<T, std::ratio<1609344, 1000>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<1609344, 1000>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"mile"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mi"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mi"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mi"};
};

template <is_unit_value_type_c T>
mile_t(T) -> mile_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
mile_t(const U&) -> mile_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct nautical_mile_t final : public details::unit_t<T, std::ratio<1852, 1>, length_dimension>
{
    using _base = details::unit_t<T, std::ratio<1852, 1>, length_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"nautical_mile"};
    [[maybe_unused]] static constexpr std::string_view symbol{"nmi"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"nmi"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"nmi"};
};

template <is_unit_value_type_c T>
nautical_mile_t(T) -> nautical_mile_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == length_dimension)
nautical_mile_t(const U&) -> nautical_mile_t<typename details::is_pkr_unit<U>::value_type>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct grain_t final : public details::unit_t<T, std::ratio<64799, 1000000000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<64799, 1000000000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"grain"};
    [[maybe_unused]] static constexpr std::string_view symbol{"gr"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"gr"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"gr"};
};

template <is_unit_value_type_c T>
grain_t(T) -> grain_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
grain_t(const U&) -> grain_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct dram_t final : public details::unit_t<T, std::ratio<1771845, 1000000000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<1771845, 1000000000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"dram"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dr"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dr"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dr"};
};

template <is_unit_value_type_c T>
dram_t(T) -> dram_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
dram_t(const U&) -> dram_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct ounce_t final : public details::unit_t<T, std::ratio<28349523, 1000000000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<28349523, 1000000000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"ounce"};
    [[maybe_unused]] static constexpr std::string_view symbol{"oz"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"oz"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"oz"};
};

template <is_unit_value_type_c T>
ounce_t(T) -> ounce_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
ounce_t(const U&) -> ounce_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct pound_t final : public details::unit_t<T, std::ratio<453592370, 1000000000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<453592370, 1000000000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"pound"};
    [[maybe_unused]] static constexpr std::string_view symbol{"lb"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"lb"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"lb"};
};

template <is_unit_value_type_c T>
pound_t(T) -> pound_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
pound_t(const U&) -> pound_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct stone_t final : public details::unit_t<T, std::ratio<6350293180, 1000000000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<6350293180, 1000000000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"stone"};
    [[maybe_unused]] static constexpr std::string_view symbol{"st"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"st"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"st"};
};

template <is_unit_value_type_c T>
stone_t(T) -> stone_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
stone_t(const U&) -> stone_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct hundredweight_t final : public details::unit_t<T, std::ratio<50802345, 1000000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<50802345, 1000000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"hundredweight"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cwt"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cwt"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cwt"};
};

template <is_unit_value_type_c T>
hundredweight_t(T) -> hundredweight_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
hundredweight_t(const U&) -> hundredweight_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct us_ton_t final : public details::unit_t<T, std::ratio<907184740, 1000000000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<907184740, 1000000000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"us_ton"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ton"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ton"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ton"};
};

template <is_unit_value_type_c T>
us_ton_t(T) -> us_ton_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
us_ton_t(const U&) -> us_ton_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct long_ton_t final : public details::unit_t<T, std::ratio<1016046909, 1000000000>, mass_dimension>
{
    using _base = details::unit_t<T, std::ratio<1016046909, 1000000000>, mass_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"long_ton"};
    [[maybe_unused]] static constexpr std::string_view symbol{"long ton"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"long ton"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"long ton"};
};

template <is_unit_value_type_c T>
long_ton_t(T) -> long_ton_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == mass_dimension)
long_ton_t(const U&) -> long_ton_t<typename details::is_pkr_unit<U>::value_type>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct miles_per_hour_t final : public details::unit_t<T, std::ratio<1609344, 3600000>, velocity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1609344, 3600000>, velocity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"miles per hour"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mph"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mph"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mph"};
};

template <is_unit_value_type_c T>
miles_per_hour_t(T) -> miles_per_hour_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == velocity_dimension)
miles_per_hour_t(const U&) -> miles_per_hour_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct feet_per_second_t final : public details::unit_t<T, std::ratio<3048, 10000>, velocity_dimension>
{
    using _base = details::unit_t<T, std::ratio<3048, 10000>, velocity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"feet per second"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ft/s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ft\u00b7s\u207b\u00b9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ft\u00b7s\u207b\u00b9"};
};

template <is_unit_value_type_c T>
feet_per_second_t(T) -> feet_per_second_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == velocity_dimension)
feet_per_second_t(const U&) -> feet_per_second_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct inches_per_second_t final : public details::unit_t<T, std::ratio<254, 10000>, velocity_dimension>
{
    using _base = details::unit_t<T, std::ratio<254, 10000>, velocity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"inches per second"};
    [[maybe_unused]] static constexpr std::string_view symbol{"in/s"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"in\u00b7s\u207b\u00b9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"in\u00b7s\u207b\u00b9"};
};

template <is_unit_value_type_c T>
inches_per_second_t(T) -> inches_per_second_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == velocity_dimension)
inches_per_second_t(const U&) -> inches_per_second_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct knots_t final : public details::unit_t<T, std::ratio<1852, 3600>, velocity_dimension>
{
    using _base = details::unit_t<T, std::ratio<1852, 3600>, velocity_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"knots"};
    [[maybe_unused]] static constexpr std::string_view symbol{"kn"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"kn"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"kn"};
};

template <is_unit_value_type_c T>
knots_t(T) -> knots_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == velocity_dimension)
knots_t(const U&) -> knots_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1609344, 3600000>, velocity_dimension>
{
    using type = miles_per_hour_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<3048, 10000>, velocity_dimension>
{
    using type = feet_per_second_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<254, 10000>, velocity_dimension>
{
    using type = inches_per_second_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1852, 3600>, velocity_dimension>
{
    using type = knots_t<T>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct feet_per_second_squared_t final : public details::unit_t<T, std::ratio<3048, 10000>, acceleration_v>
{
    using _base = details::unit_t<T, std::ratio<3048, 10000>, acceleration_v>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"feet per second squared"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ft/s^2"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ft\u00b7s\u207b\u00b2"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ft\u00b7s\u207b\u00b2"};
};

template <is_unit_value_type_c T>
feet_per_second_squared_t(T) -> feet_per_second_squared_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == acceleration_v)
feet_per_second_squared_t(const U&) -> feet_per_second_squared_t<typename details::is_pkr_unit<U>::value_type>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct poundal_t final : public details::unit_t<T, std::ratio<45359237, 1000000000>, force_dimension>
{
    using _base = details::unit_t<T, std::ratio<45359237, 1000000000>, force_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"poundal"};
    [[maybe_unused]] static constexpr std::string_view symbol{"pdl"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"pdl"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"pdl"};
};

template <is_unit_value_type_c T>
poundal_t(T) -> poundal_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == force_dimension)
poundal_t(const U&) -> poundal_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct pound_force_t final : public details::unit_t<T, std::ratio<4448222, 1000000>, force_dimension>
{
    using _base = details::unit_t<T, std::ratio<4448222, 1000000>, force_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"pound_force"};
    [[maybe_unused]] static constexpr std::string_view symbol{"lbf"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"lbf"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"lbf"};
};

template <is_unit_value_type_c T>
pound_force_t(T) -> pound_force_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == force_dimension)
pound_force_t(const U&) -> pound_force_t<typename details::is_pkr_unit<U>::value_type>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct psi_t final : public details::unit_t<T, std::ratio<6894757, 1000>, pressure_dimension>
{
    using _base = details::unit_t<T, std::ratio<6894757, 1000>, pressure_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"psi"};
    [[maybe_unused]] static constexpr std::string_view symbol{"psi"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"psi"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"psi"};
};

template <is_unit_value_type_c T>
psi_t(T) -> psi_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == pressure_dimension)
psi_t(const U&) -> psi_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<6894757, 1000>, pressure_dimension>
{
    using type = psi_t<T>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct horsepower_t final : public details::unit_t<T, std::ratio<745700, 1000>, power_dimension>
{
    using _base = details::unit_t<T, std::ratio<745700, 1000>, power_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"horsepower"};
    [[maybe_unused]] static constexpr std::string_view symbol{"hp"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"hp"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"hp"};
};

template <is_unit_value_type_c T>
horsepower_t(T) -> horsepower_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == power_dimension)
horsepower_t(const U&) -> horsepower_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<745700, 1000>, power_dimension>
{
    using type = horsepower_t<T>;
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct pound_per_cubic_inch_t final : public details::unit_t<T, std::ratio<27679904, 1000000>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<27679904, 1000000>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"pound_per_cubic_inch"};
    [[maybe_unused]] static constexpr std::string_view symbol{"lb/in^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"lb\u00b7in\u207b\u00b3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"lb\u00b7in\u207b\u00b3"};
};

template <is_unit_value_type_c T>
pound_per_cubic_inch_t(T) -> pound_per_cubic_inch_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
pound_per_cubic_inch_t(const U&) -> pound_per_cubic_inch_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct pound_per_cubic_foot_t final : public details::unit_t<T, std::ratio<16018, 1000000>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<16018, 1000000>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"pound_per_cubic_foot"};
    [[maybe_unused]] static constexpr std::string_view symbol{"lb/ft^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"lb\u00b7ft\u207b\u00b3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"lb\u00b7ft\u207b\u00b3"};
};

template <is_unit_value_type_c T>
pound_per_cubic_foot_t(T) -> pound_per_cubic_foot_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
pound_per_cubic_foot_t(const U&) -> pound_per_cubic_foot_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct pound_per_gallon_t final : public details::unit_t<T, std::ratio<119826, 1000000>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<119826, 1000000>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"pound_per_gallon"};
    [[maybe_unused]] static constexpr std::string_view symbol{"lb/gal"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"lb\u00b7gal\u207b\u00b9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"lb\u00b7gal\u207b\u00b9"};
};

template <is_unit_value_type_c T>
pound_per_gallon_t(T) -> pound_per_gallon_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
pound_per_gallon_t(const U&) -> pound_per_gallon_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct ounce_per_cubic_inch_t final : public details::unit_t<T, std::ratio<1729994, 1000000>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<1729994, 1000000>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"ounce_per_cubic_inch"};
    [[maybe_unused]] static constexpr std::string_view symbol{"oz/in^3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"oz\u00b7in\u207b\u00b3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"oz\u00b7in\u207b\u00b3"};
};

template <is_unit_value_type_c T>
ounce_per_cubic_inch_t(T) -> ounce_per_cubic_inch_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
ounce_per_cubic_inch_t(const U&) -> ounce_per_cubic_inch_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct ounce_per_fluid_ounce_t final : public details::unit_t<T, std::ratio<33814, 1000>, density_dimension>
{
    using _base = details::unit_t<T, std::ratio<33814, 1000>, density_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"ounce_per_fluid_ounce"};
    [[maybe_unused]] static constexpr std::string_view symbol{"oz/fl oz"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"oz\u00b7fl oz\u207b\u00b9"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"oz\u00b7fl oz\u207b\u00b9"};
};

template <is_unit_value_type_c T>
ounce_per_fluid_ounce_t(T) -> ounce_per_fluid_ounce_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == density_dimension)
ounce_per_fluid_ounce_t(const U&) -> ounce_per_fluid_ounce_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<27679904, 1000000>, density_dimension>
{
    using type = pound_per_cubic_inch_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<16018, 1000000>, density_dimension>
{
    using type = pound_per_cubic_foot_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<119826, 1000000>, density_dimension>
{
    using type = pound_per_gallon_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<1729994, 1000000>, density_dimension>
{
    using type = ounce_per_cubic_inch_t<T>;
};

template <is_unit_value_type_c T>
struct details::derived_unit_type_t<T, std::ratio<33814, 1000>, density_dimension>
{
    using type = ounce_per_fluid_ounce_t<T>;
};
}

namespace pkr::units
{

namespace literals
{

constexpr inch_t<double> operator""_in(long double value) noexcept
{
    return inch_t<double>{static_cast<double>(value)};
}

constexpr foot_t<double> operator""_ft(long double value) noexcept
{
    return foot_t<double>{static_cast<double>(value)};
}

constexpr yard_t<double> operator""_yd(long double value) noexcept
{
    return yard_t<double>{static_cast<double>(value)};
}

constexpr mile_t<double> operator""_mi(long double value) noexcept
{
    return mile_t<double>{static_cast<double>(value)};
}

constexpr nautical_mile_t<double> operator""_nmi(long double value) noexcept
{
    return nautical_mile_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr grain_t<double> operator""_gr(long double value) noexcept
{
    return grain_t<double>{static_cast<double>(value)};
}

constexpr ounce_t<double> operator""_oz(long double value) noexcept
{
    return ounce_t<double>{static_cast<double>(value)};
}

constexpr pound_t<double> operator""_lb(long double value) noexcept
{
    return pound_t<double>{static_cast<double>(value)};
}

constexpr stone_t<double> operator""_st(long double value) noexcept
{
    return stone_t<double>{static_cast<double>(value)};
}

constexpr us_ton_t<double> operator""_short_ton(long double value) noexcept
{
    return us_ton_t<double>{static_cast<double>(value)};
}

constexpr long_ton_t<double> operator""_long_ton(long double value) noexcept
{
    return long_ton_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr feet_per_second_squared_t<double> operator""_fts2(long double value) noexcept
{
    return feet_per_second_squared_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr miles_per_hour_t<double> operator""_mph(long double value) noexcept
{
    return miles_per_hour_t<double>{static_cast<double>(value)};
}

constexpr knots_t<double> operator""_kt(long double value) noexcept
{
    return knots_t<double>{static_cast<double>(value)};
}

constexpr feet_per_second_t<double> operator""_fps(long double value) noexcept
{
    return feet_per_second_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr psi_t<double> operator""_psi(long double value) noexcept
{
    return psi_t<double>{static_cast<double>(value)};
}

constexpr horsepower_t<double> operator""_hp(long double value) noexcept
{
    return horsepower_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

constexpr intmax_t constexpr_pow(intmax_t base, unsigned int exp) noexcept
{
    if (exp == 0)
        return 1;

    intmax_t result = 1;
    for (unsigned int i = 0; i < exp; ++i)
    {
        result *= base;
    }
    return result;
}
template <typename unit_type, int power_v>
struct power_of
{
    static_assert(details::is_pkr_unit<unit_type>::value, "power_of requires an si_unit type");

    using unit_traits = details::is_pkr_unit<unit_type>;
    using value_type = typename unit_traits::value_type;
    using source_ratio = typename unit_traits::ratio_type;
    static constexpr dimension_t source_dim = unit_traits::value_dimension;

    static constexpr dimension_t powered_dim{
        .length = static_cast<signed char>(source_dim.length * power_v),
        .mass = static_cast<signed char>(source_dim.mass * power_v),
        .time = static_cast<signed char>(source_dim.time * power_v),
        .current = static_cast<signed char>(source_dim.current * power_v),
        .temperature = static_cast<signed char>(source_dim.temperature * power_v),
        .amount = static_cast<signed char>(source_dim.amount * power_v),
        .intensity = static_cast<signed char>(source_dim.intensity * power_v),
        .angle = static_cast<signed char>(source_dim.angle * power_v)};

    static constexpr intmax_t powered_num = (power_v >= 0) ? constexpr_pow(source_ratio::num, static_cast<unsigned int>(power_v))
                                                           : constexpr_pow(source_ratio::den, static_cast<unsigned int>(-power_v));

    static constexpr intmax_t powered_den = (power_v >= 0) ? constexpr_pow(source_ratio::den, static_cast<unsigned int>(power_v))
                                                           : constexpr_pow(source_ratio::num, static_cast<unsigned int>(-power_v));

    using powered_ratio = std::ratio<powered_num, powered_den>;

    using type = details::unit_t<value_type, powered_ratio, powered_dim>;
};

template <typename unit_type, int power_v>
using power_of_t = typename power_of<unit_type, power_v>::type;

template <typename unit_type, int power_v>
using Pow [[deprecated("Use power_of<unit_type, power_v> instead of Pow<unit_type, power_v>")]] = power_of<unit_type, power_v>;

template <typename unit_type, int power_v>
using Pow_t [[deprecated("Use power_of_t<unit_type, power_v> instead of Pow_t<unit_type, power_v>")]] = power_of_t<unit_type, power_v>;

template <typename unit_type, int power_v>
struct details::is_pkr_unit<power_of<unit_type, power_v>> : std::true_type
{
    static constexpr bool value = true;
    using value_type = typename power_of<unit_type, power_v>::value_type;
    using ratio_type = typename power_of<unit_type, power_v>::powered_ratio;
    static constexpr dimension_t value_dimension = power_of<unit_type, power_v>::powered_dim;
};

}

namespace pkr::units
{
template <typename... Units>
struct per
{
};

template <typename Unit>
struct per_unit_squared : per<Unit, std::integral_constant<int, 2>>
{
    using per_type = per<Unit, std::integral_constant<int, 2>>;
};

template <typename Unit>
struct per_unit_cubed : per<Unit, std::integral_constant<int, 3>>
{
    using per_type = per<Unit, std::integral_constant<int, 3>>;
};

template <typename Unit>
struct per_unit_quartic : per<Unit, std::integral_constant<int, 4>>
{
    using per_type = per<Unit, std::integral_constant<int, 4>>;
};

template <typename Unit>
struct per_unit_inverse : per<Unit, std::integral_constant<int, -1>>
{
    using per_type = per<Unit, std::integral_constant<int, -1>>;
};

template <typename Unit>
struct per_unit_inverse_squared : per<Unit, std::integral_constant<int, -2>>
{
    using per_type = per<Unit, std::integral_constant<int, -2>>;
};

constexpr dimension_t combine_dimensions_multiply(dimension_t left, dimension_t right) noexcept
{
    return dimension_t{
        static_cast<int>(left.length + right.length),
        static_cast<int>(left.mass + right.mass),
        static_cast<int>(left.time + right.time),
        static_cast<int>(left.current + right.current),
        static_cast<int>(left.temperature + right.temperature),
        static_cast<int>(left.amount + right.amount),
        static_cast<int>(left.intensity + right.intensity),
        static_cast<int>(left.angle + right.angle)};
}

constexpr dimension_t combine_dimensions_divide(dimension_t left, dimension_t right) noexcept
{
    return dimension_t{
        static_cast<int>(left.length - right.length),
        static_cast<int>(left.mass - right.mass),
        static_cast<int>(left.time - right.time),
        static_cast<int>(left.current - right.current),
        static_cast<int>(left.temperature - right.temperature),
        static_cast<int>(left.amount - right.amount),
        static_cast<int>(left.intensity - right.intensity),
        static_cast<int>(left.angle - right.angle)};
}

constexpr dimension_t pow_dimension(dimension_t dim, int power) noexcept
{
    return dimension_t{
        static_cast<int>(dim.length * power),
        static_cast<int>(dim.mass * power),
        static_cast<int>(dim.time * power),
        static_cast<int>(dim.current * power),
        static_cast<int>(dim.temperature * power),
        static_cast<int>(dim.amount * power),
        static_cast<int>(dim.intensity * power),
        static_cast<int>(dim.angle * power)};
}

template <typename T>
struct is_integral_constant : std::false_type
{
};

template <typename T, T Value>
struct is_integral_constant<std::integral_constant<T, Value>> : std::true_type
{
};

template <typename T>
constexpr bool is_integral_constant_v = is_integral_constant<T>::value;

template <typename Ratio, int power_v>
struct ratio_pow
{
    static constexpr int power = power_v;
    static constexpr intmax_t num =
        (power >= 0) ? constexpr_pow(Ratio::num, static_cast<unsigned int>(power)) : constexpr_pow(Ratio::den, static_cast<unsigned int>(-power));
    static constexpr intmax_t den =
        (power >= 0) ? constexpr_pow(Ratio::den, static_cast<unsigned int>(power)) : constexpr_pow(Ratio::num, static_cast<unsigned int>(-power));
    using type = std::ratio<num, den>;
};

template <typename type_t, typename source_ratio_t, typename target_ratio_t>
constexpr type_t compute_conversion_factor() noexcept
{
    return (static_cast<type_t>(source_ratio_t::num) * static_cast<type_t>(target_ratio_t::den)) /
           (static_cast<type_t>(source_ratio_t::den) * static_cast<type_t>(target_ratio_t::num));
}

template <typename Ratio, dimension_t Dim, typename... Units>
struct apply_numerators;

template <typename Ratio, dimension_t Dim>
struct apply_numerators<Ratio, Dim>
{
    using ratio = Ratio;
    static constexpr dimension_t dim = Dim;
};

template <typename Ratio, dimension_t Dim, typename Unit, typename... Rest>
    requires(is_pkr_unit_c<Unit>)
struct apply_numerators<Ratio, Dim, Unit, Rest...>
{
    using unit_traits = details::is_pkr_unit<Unit>;
    using next_ratio = std::ratio_multiply<Ratio, typename unit_traits::ratio_type>;
    static constexpr dimension_t next_dim = combine_dimensions_multiply(Dim, unit_traits::value_dimension);
    using next = apply_numerators<next_ratio, next_dim, Rest...>;
    using ratio = typename next::ratio;
    static constexpr dimension_t dim = next::dim;
};

template <typename Ratio, dimension_t Dim, typename... Items>
struct apply_denominators;

template <typename Ratio, dimension_t Dim>
struct apply_denominators<Ratio, Dim>
{
    using ratio = Ratio;
    static constexpr dimension_t dim = Dim;
};

template <typename Ratio, dimension_t Dim, typename Unit>
    requires(is_pkr_unit_c<Unit>)
struct apply_denominators<Ratio, Dim, Unit>
{
    using unit_traits = details::is_pkr_unit<Unit>;
    using powered_ratio = typename ratio_pow<typename unit_traits::ratio_type, 1>::type;
    using next_ratio = std::ratio_divide<Ratio, powered_ratio>;
    static constexpr dimension_t powered_dim = pow_dimension(unit_traits::value_dimension, 1);
    static constexpr dimension_t next_dim = combine_dimensions_divide(Dim, powered_dim);
    using ratio = next_ratio;
    static constexpr dimension_t dim = next_dim;
};

template <typename Ratio, dimension_t Dim, typename Unit, typename PowerConst, typename... Rest>
    requires(is_pkr_unit_c<Unit> && is_integral_constant_v<PowerConst>)
struct apply_denominators<Ratio, Dim, Unit, PowerConst, Rest...>
{
    using unit_traits = details::is_pkr_unit<Unit>;
    static constexpr int power = static_cast<int>(PowerConst::value);
    using powered_ratio = typename ratio_pow<typename unit_traits::ratio_type, power>::type;
    using next_ratio = std::ratio_divide<Ratio, powered_ratio>;
    static constexpr dimension_t powered_dim = pow_dimension(unit_traits::value_dimension, power);
    static constexpr dimension_t next_dim = combine_dimensions_divide(Dim, powered_dim);
    using next = apply_denominators<next_ratio, next_dim, Rest...>;
    using ratio = typename next::ratio;
    static constexpr dimension_t dim = next::dim;
};

template <typename Ratio, dimension_t Dim, typename Unit, typename Unit2, typename... Rest>
    requires(is_pkr_unit_c<Unit> && is_pkr_unit_c<Unit2>)
struct apply_denominators<Ratio, Dim, Unit, Unit2, Rest...>
{
    using unit_traits = details::is_pkr_unit<Unit>;
    using powered_ratio = typename ratio_pow<typename unit_traits::ratio_type, 1>::type;
    using next_ratio = std::ratio_divide<Ratio, powered_ratio>;
    static constexpr dimension_t powered_dim = pow_dimension(unit_traits::value_dimension, 1);
    static constexpr dimension_t next_dim = combine_dimensions_divide(Dim, powered_dim);
    using next = apply_denominators<next_ratio, next_dim, Unit2, Rest...>;
    using ratio = typename next::ratio;
    static constexpr dimension_t dim = next::dim;
};

template <typename source_unit_t, typename... numerator_unit_types, typename... denominator_items>
constexpr auto multi_unit_cast_impl(const source_unit_t& source, std::tuple<numerator_unit_types...>*, std::tuple<denominator_items...>*) noexcept
{
    using source_traits = details::is_pkr_unit<source_unit_t>;
    using source_ratio = typename source_traits::ratio_type;
    using source_value_type = typename source_traits::value_type;

    using after_num = apply_numerators<std::ratio<1, 1>, scalar_dimension, numerator_unit_types...>;
    using after_den = apply_denominators<typename after_num::ratio, after_num::dim, denominator_items...>;

    using result_ratio = typename after_den::ratio;
    constexpr dimension_t result_dim = after_den::dim;

    using result_unit = details::unit_t<source_value_type, result_ratio, result_dim>;
    constexpr source_value_type conversion_factor = compute_conversion_factor<source_value_type, source_ratio, result_ratio>();
    return result_unit(source.value() * conversion_factor);
}

namespace _multi_unit_cast_detail
{

template <typename T, typename = void>
struct is_per : std::false_type
{
};

template <typename... Units>
struct is_per<per<Units...>> : std::true_type
{
};

template <typename T>
struct is_per<T, std::void_t<typename T::per_type>> : is_per<typename T::per_type>
{
};

template <typename T>
constexpr bool is_per_v = is_per<T>::value;

template <typename NumUnit, typename DenomPer, typename SourceUnit>
concept valid_multi_unit_cast_single = is_pkr_unit_c<NumUnit> && is_per_v<DenomPer> && is_pkr_unit_c<SourceUnit>;

template <typename Num1Unit, typename Num2Unit, typename DenomPer, typename SourceUnit>
concept valid_multi_unit_cast_dual = is_pkr_unit_c<Num1Unit> && is_pkr_unit_c<Num2Unit> && is_per_v<DenomPer> && is_pkr_unit_c<SourceUnit>;

template <typename Num1Unit, typename Num2Unit, typename Num3Unit, typename DenomPer, typename SourceUnit>
concept valid_multi_unit_cast_triple =
    is_pkr_unit_c<Num1Unit> && is_pkr_unit_c<Num2Unit> && is_pkr_unit_c<Num3Unit> && is_per_v<DenomPer> && is_pkr_unit_c<SourceUnit>;

template <typename num_t, typename per_wrapper>
struct multi_unit_cast_helper;

template <typename num_t, typename per_wrapper>
    requires(requires { typename per_wrapper::per_type; })
struct multi_unit_cast_helper<num_t, per_wrapper>
{
    template <typename source_t>
    static constexpr auto call(const source_t& source) noexcept
    {
        return multi_unit_cast_helper<num_t, typename per_wrapper::per_type>::call(source);
    }
};

template <typename num_t, typename... denoms>
struct multi_unit_cast_helper<num_t, per<denoms...>>
{
    template <typename source_t>
    static constexpr auto call(const source_t& source) noexcept
    {
        return multi_unit_cast_impl(source, static_cast<std::tuple<num_t>*>(nullptr), static_cast<std::tuple<denoms...>*>(nullptr));
    }
};

template <typename num1_t, typename num2_t, typename per_wrapper>
struct multi_unit_cast_helper2;

template <typename num1_t, typename num2_t, typename per_wrapper>
    requires(requires { typename per_wrapper::per_type; })
struct multi_unit_cast_helper2<num1_t, num2_t, per_wrapper>
{
    template <typename source_t>
    static constexpr auto call(const source_t& source) noexcept
    {
        return multi_unit_cast_helper2<num1_t, num2_t, typename per_wrapper::per_type>::call(source);
    }
};

template <typename num1_t, typename num2_t, typename... denoms>
struct multi_unit_cast_helper2<num1_t, num2_t, per<denoms...>>
{
    template <typename source_t>
    static constexpr auto call(const source_t& source) noexcept
    {
        return multi_unit_cast_impl(source, static_cast<std::tuple<num1_t, num2_t>*>(nullptr), static_cast<std::tuple<denoms...>*>(nullptr));
    }
};

template <typename num1_t, typename num2_t, typename num3_t, typename per_wrapper>
struct multi_unit_cast_helper3;

template <typename num1_t, typename num2_t, typename num3_t, typename per_wrapper>
    requires(requires { typename per_wrapper::per_type; })
struct multi_unit_cast_helper3<num1_t, num2_t, num3_t, per_wrapper>
{
    template <typename source_t>
    static constexpr auto call(const source_t& source) noexcept
    {
        return multi_unit_cast_helper3<num1_t, num2_t, num3_t, typename per_wrapper::per_type>::call(source);
    }
};

template <typename num1_t, typename num2_t, typename num3_t, typename... denoms>
struct multi_unit_cast_helper3<num1_t, num2_t, num3_t, per<denoms...>>
{
    template <typename source_t>
    static constexpr auto call(const source_t& source) noexcept
    {
        return multi_unit_cast_impl(source, static_cast<std::tuple<num1_t, num2_t, num3_t>*>(nullptr), static_cast<std::tuple<denoms...>*>(nullptr));
    }
};
}

template <typename num_t, typename per_unit, typename source_t>
    requires _multi_unit_cast_detail::valid_multi_unit_cast_single<num_t, per_unit, source_t>
constexpr auto multi_unit_cast(const source_t& source) noexcept
{
    return _multi_unit_cast_detail::multi_unit_cast_helper<num_t, per_unit>::call(source);
}

template <typename num1_t, typename num2_t, typename per_unit, typename source_t>
    requires _multi_unit_cast_detail::valid_multi_unit_cast_dual<num1_t, num2_t, per_unit, source_t>
constexpr auto multi_unit_cast(const source_t& source) noexcept
{
    return _multi_unit_cast_detail::multi_unit_cast_helper2<num1_t, num2_t, per_unit>::call(source);
}

template <typename num1_t, typename num2_t, typename num3_t, typename per_unit, typename source_t>
    requires _multi_unit_cast_detail::valid_multi_unit_cast_triple<num1_t, num2_t, num3_t, per_unit, source_t>
constexpr auto multi_unit_cast(const source_t& source) noexcept
{
    return _multi_unit_cast_detail::multi_unit_cast_helper3<num1_t, num2_t, num3_t, per_unit>::call(source);
}

template <typename num_t, typename per_unit, typename source_t>
    requires _multi_unit_cast_detail::valid_multi_unit_cast_single<num_t, per_unit, source_t>
constexpr auto multi_unit_cast_to_base_units(const source_t& source) noexcept
{
    auto result = multi_unit_cast<num_t, per_unit>(source);
    return result.in_base_si_units();
}

template <typename num1_t, typename num2_t, typename per_unit, typename source_t>
    requires _multi_unit_cast_detail::valid_multi_unit_cast_dual<num1_t, num2_t, per_unit, source_t>
constexpr auto multi_unit_cast_to_base_units(const source_t& source) noexcept
{
    auto result = multi_unit_cast<num1_t, num2_t, per_unit>(source);
    return result.in_base_si_units();
}

template <typename num1_t, typename num2_t, typename num3_t, typename per_unit, typename source_t>
    requires _multi_unit_cast_detail::valid_multi_unit_cast_triple<num1_t, num2_t, num3_t, per_unit, source_t>
constexpr auto multi_unit_cast_to_base_units(const source_t& source) noexcept
{
    auto result = multi_unit_cast<num1_t, num2_t, num3_t, per_unit>(source);
    return result.in_base_si_units();
}

template <typename num_t, typename per_unit, typename source_t>
    requires _multi_unit_cast_detail::valid_multi_unit_cast_single<num_t, per_unit, source_t>
constexpr auto multi_unit_cast_to_derived(const source_t& source) noexcept
{
    auto base = multi_unit_cast_to_base_units<num_t, per_unit>(source);
    using base_unit = std::decay_t<decltype(base)>;
    using value_type = typename base_unit::value_type;
    using derived_type = typename details::derived_unit_type_t<value_type, std::ratio<1, 1>, base_unit::dimension::value>::type;
    return derived_type{base.value()};
}

template <typename num1_t, typename num2_t, typename per_unit, typename source_t>
    requires _multi_unit_cast_detail::valid_multi_unit_cast_dual<num1_t, num2_t, per_unit, source_t>
constexpr auto multi_unit_cast_to_derived(const source_t& source) noexcept
{
    auto base = multi_unit_cast_to_base_units<num1_t, num2_t, per_unit>(source);
    using base_unit = std::decay_t<decltype(base)>;
    using value_type = typename base_unit::value_type;
    using derived_type = typename details::derived_unit_type_t<value_type, std::ratio<1, 1>, base_unit::dimension::value>::type;
    return derived_type{base.value()};
}

template <typename num1_t, typename num2_t, typename num3_t, typename per_unit, typename source_t>
    requires _multi_unit_cast_detail::valid_multi_unit_cast_triple<num1_t, num2_t, num3_t, per_unit, source_t>
constexpr auto multi_unit_cast_to_derived(const source_t& source) noexcept
{
    auto base = multi_unit_cast_to_base_units<num1_t, num2_t, num3_t, per_unit>(source);
    using base_unit = std::decay_t<decltype(base)>;
    using value_type = typename base_unit::value_type;
    using derived_type = typename details::derived_unit_type_t<value_type, std::ratio<1, 1>, base_unit::dimension::value>::type;
    return derived_type{base.value()};
}

}

namespace pkr::units
{

inline constexpr dimension_t volume_dimension{3, 0, 0, 0, 0, 0, 0, 0};

template <typename type_t = double, typename ratio_t = std::ratio<1, 1>>
using volume_unit_t = details::unit_t<type_t, ratio_t, volume_dimension>;
}

namespace pkr::units
{

namespace literals
{

constexpr meter_per_second_squared_t<double> operator""_mps2(long double value) noexcept
{
    return meter_per_second_squared_t<double>{static_cast<double>(value)};
}

constexpr centimeter_per_second_squared_t<double> operator""_cms2(long double value) noexcept
{
    return centimeter_per_second_squared_t<double>{static_cast<double>(value)};
}

constexpr millimeter_per_second_squared_t<double> operator""_mms2(long double value) noexcept
{
    return millimeter_per_second_squared_t<double>{static_cast<double>(value)};
}

constexpr standard_gravity_t<double> operator""_g_earth(long double value) noexcept
{
    return standard_gravity_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr attomole_t<double> operator""_amol(long double value) noexcept
{
    return attomole_t<double>{static_cast<double>(value)};
}

constexpr femtomole_t<double> operator""_fmol(long double value) noexcept
{
    return femtomole_t<double>{static_cast<double>(value)};
}

constexpr picomole_t<double> operator""_pmol(long double value) noexcept
{
    return picomole_t<double>{static_cast<double>(value)};
}

constexpr nanomole_t<double> operator""_nmol(long double value) noexcept
{
    return nanomole_t<double>{static_cast<double>(value)};
}

constexpr micromole_t<double> operator""_umol(long double value) noexcept
{
    return micromole_t<double>{static_cast<double>(value)};
}

constexpr millimole_t<double> operator""_mmol(long double value) noexcept
{
    return millimole_t<double>{static_cast<double>(value)};
}

constexpr centimole_t<double> operator""_cmol(long double value) noexcept
{
    return centimole_t<double>{static_cast<double>(value)};
}

constexpr decimole_t<double> operator""_dmol(long double value) noexcept
{
    return decimole_t<double>{static_cast<double>(value)};
}

constexpr mole_t<double> operator""_mol(long double value) noexcept
{
    return mole_t<double>{static_cast<double>(value)};
}

constexpr decamole_t<double> operator""_damol(long double value) noexcept
{
    return decamole_t<double>{static_cast<double>(value)};
}

constexpr hectomole_t<double> operator""_hmol(long double value) noexcept
{
    return hectomole_t<double>{static_cast<double>(value)};
}

constexpr kilomole_t<double> operator""_kmol(long double value) noexcept
{
    return kilomole_t<double>{static_cast<double>(value)};
}

constexpr megamole_t<double> operator""_Mmol(long double value) noexcept
{
    return megamole_t<double>{static_cast<double>(value)};
}

constexpr gigamole_t<double> operator""_Gmol(long double value) noexcept
{
    return gigamole_t<double>{static_cast<double>(value)};
}

constexpr teramole_t<double> operator""_Tmol(long double value) noexcept
{
    return teramole_t<double>{static_cast<double>(value)};
}

constexpr petamole_t<double> operator""_Pmol(long double value) noexcept
{
    return petamole_t<double>{static_cast<double>(value)};
}

constexpr examole_t<double> operator""_Emol(long double value) noexcept
{
    return examole_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr attoampere_t<double> operator""_aA(long double value) noexcept
{
    return attoampere_t<double>{static_cast<double>(value)};
}

constexpr femtoampere_t<double> operator""_fA(long double value) noexcept
{
    return femtoampere_t<double>{static_cast<double>(value)};
}

constexpr picoampere_t<double> operator""_pA(long double value) noexcept
{
    return picoampere_t<double>{static_cast<double>(value)};
}

constexpr nanoampere_t<double> operator""_nA(long double value) noexcept
{
    return nanoampere_t<double>{static_cast<double>(value)};
}

constexpr microampere_t<double> operator""_uA(long double value) noexcept
{
    return microampere_t<double>{static_cast<double>(value)};
}

constexpr milliampere_t<double> operator""_mA(long double value) noexcept
{
    return milliampere_t<double>{static_cast<double>(value)};
}

constexpr centiampere_t<double> operator""_cA(long double value) noexcept
{
    return centiampere_t<double>{static_cast<double>(value)};
}

constexpr deciampere_t<double> operator""_dA(long double value) noexcept
{
    return deciampere_t<double>{static_cast<double>(value)};
}

constexpr ampere_t<double> operator""_A(long double value) noexcept
{
    return ampere_t<double>{static_cast<double>(value)};
}

constexpr decaampere_t<double> operator""_daA(long double value) noexcept
{
    return decaampere_t<double>{static_cast<double>(value)};
}

constexpr hectoampere_t<double> operator""_hA(long double value) noexcept
{
    return hectoampere_t<double>{static_cast<double>(value)};
}

constexpr kiloampere_t<double> operator""_kA(long double value) noexcept
{
    return kiloampere_t<double>{static_cast<double>(value)};
}

constexpr megaampere_t<double> operator""_MA(long double value) noexcept
{
    return megaampere_t<double>{static_cast<double>(value)};
}

constexpr gigaampere_t<double> operator""_GA(long double value) noexcept
{
    return gigaampere_t<double>{static_cast<double>(value)};
}

constexpr teraampere_t<double> operator""_TA(long double value) noexcept
{
    return teraampere_t<double>{static_cast<double>(value)};
}

constexpr petaampere_t<double> operator""_PA(long double value) noexcept
{
    return petaampere_t<double>{static_cast<double>(value)};
}

constexpr exaampere_t<double> operator""_EA(long double value) noexcept
{
    return exaampere_t<double>{static_cast<double>(value)};
}

}

}
namespace pkr::units
{

namespace literals
{

constexpr coulomb_t<double> operator""_C(long double value) noexcept
{
    return coulomb_t<double>{static_cast<double>(value)};
}

constexpr kilocoulomb_t<double> operator""_kC(long double value) noexcept
{
    return kilocoulomb_t<double>{static_cast<double>(value)};
}

constexpr millicoulomb_t<double> operator""_mC(long double value) noexcept
{
    return millicoulomb_t<double>{static_cast<double>(value)};
}

constexpr microcoulomb_t<double> operator""_uC(long double value) noexcept
{
    return microcoulomb_t<double>{static_cast<double>(value)};
}

constexpr nanocoulomb_t<double> operator""_nC(long double value) noexcept
{
    return nanocoulomb_t<double>{static_cast<double>(value)};
}

constexpr picocoulomb_t<double> operator""_pC(long double value) noexcept
{
    return picocoulomb_t<double>{static_cast<double>(value)};
}

constexpr volt_t<double> operator""_V(long double value) noexcept
{
    return volt_t<double>{static_cast<double>(value)};
}

constexpr kilovolt_t<double> operator""_kV(long double value) noexcept
{
    return kilovolt_t<double>{static_cast<double>(value)};
}

constexpr megavolt_t<double> operator""_MV(long double value) noexcept
{
    return megavolt_t<double>{static_cast<double>(value)};
}

constexpr millivolt_t<double> operator""_mV(long double value) noexcept
{
    return millivolt_t<double>{static_cast<double>(value)};
}

constexpr microvolt_t<double> operator""_uV(long double value) noexcept
{
    return microvolt_t<double>{static_cast<double>(value)};
}

constexpr ohm_t<double> operator""_ohm(long double value) noexcept
{
    return ohm_t<double>{static_cast<double>(value)};
}

constexpr kiloohm_t<double> operator""_kohm(long double value) noexcept
{
    return kiloohm_t<double>{static_cast<double>(value)};
}

constexpr megaohm_t<double> operator""_Mohm(long double value) noexcept
{
    return megaohm_t<double>{static_cast<double>(value)};
}

constexpr gigaohm_t<double> operator""_Gohm(long double value) noexcept
{
    return gigaohm_t<double>{static_cast<double>(value)};
}

constexpr milliohm_t<double> operator""_mohm(long double value) noexcept
{
    return milliohm_t<double>{static_cast<double>(value)};
}

constexpr microohm_t<double> operator""_uohm(long double value) noexcept
{
    return microohm_t<double>{static_cast<double>(value)};
}

constexpr farad_t<double> operator""_F(long double value) noexcept
{
    return farad_t<double>{static_cast<double>(value)};
}

constexpr millifarad_t<double> operator""_mF(long double value) noexcept
{
    return millifarad_t<double>{static_cast<double>(value)};
}

constexpr microfarad_t<double> operator""_uF(long double value) noexcept
{
    return microfarad_t<double>{static_cast<double>(value)};
}

constexpr nanofarad_t<double> operator""_nF(long double value) noexcept
{
    return nanofarad_t<double>{static_cast<double>(value)};
}

constexpr picofarad_t<double> operator""_pF(long double value) noexcept
{
    return picofarad_t<double>{static_cast<double>(value)};
}

constexpr henry_t<double> operator""_H(long double value) noexcept
{
    return henry_t<double>{static_cast<double>(value)};
}

constexpr millihenry_t<double> operator""_mH(long double value) noexcept
{
    return millihenry_t<double>{static_cast<double>(value)};
}

constexpr microhenry_t<double> operator""_uH(long double value) noexcept
{
    return microhenry_t<double>{static_cast<double>(value)};
}

constexpr nanohenry_t<double> operator""_nH(long double value) noexcept
{
    return nanohenry_t<double>{static_cast<double>(value)};
}

constexpr siemens_t<double> operator""_S(long double value) noexcept
{
    return siemens_t<double>{static_cast<double>(value)};
}

constexpr millisiemens_t<double> operator""_mS(long double value) noexcept
{
    return millisiemens_t<double>{static_cast<double>(value)};
}

constexpr microsiemens_t<double> operator""_uS(long double value) noexcept
{
    return microsiemens_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr attocandela_t<double> operator""_acd(long double value) noexcept
{
    return attocandela_t<double>{static_cast<double>(value)};
}

constexpr femtocandela_t<double> operator""_fcd(long double value) noexcept
{
    return femtocandela_t<double>{static_cast<double>(value)};
}

constexpr picocandela_t<double> operator""_pcd(long double value) noexcept
{
    return picocandela_t<double>{static_cast<double>(value)};
}

constexpr nanocandela_t<double> operator""_ncd(long double value) noexcept
{
    return nanocandela_t<double>{static_cast<double>(value)};
}

constexpr microcandela_t<double> operator""_ucd(long double value) noexcept
{
    return microcandela_t<double>{static_cast<double>(value)};
}

constexpr millicandela_t<double> operator""_mcd(long double value) noexcept
{
    return millicandela_t<double>{static_cast<double>(value)};
}

constexpr centicandela_t<double> operator""_ccd(long double value) noexcept
{
    return centicandela_t<double>{static_cast<double>(value)};
}

constexpr decicandela_t<double> operator""_dcd(long double value) noexcept
{
    return decicandela_t<double>{static_cast<double>(value)};
}

constexpr candela_t<double> operator""_cd(long double value) noexcept
{
    return candela_t<double>{static_cast<double>(value)};
}

constexpr decacandela_t<double> operator""_dacd(long double value) noexcept
{
    return decacandela_t<double>{static_cast<double>(value)};
}

constexpr hectocandela_t<double> operator""_hcd(long double value) noexcept
{
    return hectocandela_t<double>{static_cast<double>(value)};
}

constexpr kilocandela_t<double> operator""_kcd(long double value) noexcept
{
    return kilocandela_t<double>{static_cast<double>(value)};
}

constexpr megacandela_t<double> operator""_Mcd(long double value) noexcept
{
    return megacandela_t<double>{static_cast<double>(value)};
}

constexpr gigacandela_t<double> operator""_Gcd(long double value) noexcept
{
    return gigacandela_t<double>{static_cast<double>(value)};
}

constexpr teracandela_t<double> operator""_Tcd(long double value) noexcept
{
    return teracandela_t<double>{static_cast<double>(value)};
}

constexpr petacandela_t<double> operator""_Pcd(long double value) noexcept
{
    return petacandela_t<double>{static_cast<double>(value)};
}

constexpr exacandela_t<double> operator""_Ecd(long double value) noexcept
{
    return exacandela_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr attometer_t<double> operator""_am(long double value) noexcept
{
    return attometer_t<double>{static_cast<double>(value)};
}

constexpr femtometer_t<double> operator""_fm(long double value) noexcept
{
    return femtometer_t<double>{static_cast<double>(value)};
}

constexpr picometer_t<double> operator""_pm(long double value) noexcept
{
    return picometer_t<double>{static_cast<double>(value)};
}

constexpr nanometer_t<double> operator""_nm(long double value) noexcept
{
    return nanometer_t<double>{static_cast<double>(value)};
}

constexpr micrometer_t<double> operator""_um(long double value) noexcept
{
    return micrometer_t<double>{static_cast<double>(value)};
}

constexpr millimeter_t<double> operator""_mm(long double value) noexcept
{
    return millimeter_t<double>{static_cast<double>(value)};
}

constexpr centimeter_t<double> operator""_cm(long double value) noexcept
{
    return centimeter_t<double>{static_cast<double>(value)};
}

constexpr decimeter_t<double> operator""_dm(long double value) noexcept
{
    return decimeter_t<double>{static_cast<double>(value)};
}

constexpr meter_t<double> operator""_m(long double value) noexcept
{
    return meter_t<double>{static_cast<double>(value)};
}

constexpr kilometer_t<double> operator""_km(long double value) noexcept
{
    return kilometer_t<double>{static_cast<double>(value)};
}

constexpr megameter_t<double> operator""_Mm(long double value) noexcept
{
    return megameter_t<double>{static_cast<double>(value)};
}

constexpr gigameter_t<double> operator""_Gm(long double value) noexcept
{
    return gigameter_t<double>{static_cast<double>(value)};
}

constexpr terameter_t<double> operator""_Tm(long double value) noexcept
{
    return terameter_t<double>{static_cast<double>(value)};
}

constexpr petameter_t<double> operator""_Pm(long double value) noexcept
{
    return petameter_t<double>{static_cast<double>(value)};
}

constexpr exameter_t<double> operator""_Em(long double value) noexcept
{
    return exameter_t<double>{static_cast<double>(value)};
}

constexpr angstrom_t<double> operator""_angstrom(long double value) noexcept
{
    return angstrom_t<double>{static_cast<double>(value)};
}

constexpr au_t<double> operator""_au(long double value) noexcept
{
    return au_t<double>{static_cast<double>(value)};
}

constexpr light_year_t<double> operator""_ly(long double value) noexcept
{
    return light_year_t<double>{static_cast<double>(value)};
}

constexpr parsec_t<double> operator""_pc(long double value) noexcept
{
    return parsec_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr picogram_t<double> operator""_pg(long double value) noexcept
{
    return picogram_t<double>{static_cast<double>(value)};
}

constexpr nanogram_t<double> operator""_ng(long double value) noexcept
{
    return nanogram_t<double>{static_cast<double>(value)};
}

constexpr microgram_t<double> operator""_ug(long double value) noexcept
{
    return microgram_t<double>{static_cast<double>(value)};
}

constexpr milligram_t<double> operator""_mg(long double value) noexcept
{
    return milligram_t<double>{static_cast<double>(value)};
}

constexpr centigram_t<double> operator""_cg(long double value) noexcept
{
    return centigram_t<double>{static_cast<double>(value)};
}

constexpr decigram_t<double> operator""_dg(long double value) noexcept
{
    return decigram_t<double>{static_cast<double>(value)};
}

constexpr gram_t<double> operator""_g(long double value) noexcept
{
    return gram_t<double>{static_cast<double>(value)};
}

constexpr decagram_t<double> operator""_dag(long double value) noexcept
{
    return decagram_t<double>{static_cast<double>(value)};
}

constexpr hectogram_t<double> operator""_hg(long double value) noexcept
{
    return hectogram_t<double>{static_cast<double>(value)};
}

constexpr kilogram_t<double> operator""_kg(long double value) noexcept
{
    return kilogram_t<double>{static_cast<double>(value)};
}

constexpr gigagram_t<double> operator""_Gg(long double value) noexcept
{
    return gigagram_t<double>{static_cast<double>(value)};
}

constexpr teragram_t<double> operator""_Tg(long double value) noexcept
{
    return teragram_t<double>{static_cast<double>(value)};
}

constexpr petagram_t<double> operator""_Pg(long double value) noexcept
{
    return petagram_t<double>{static_cast<double>(value)};
}

constexpr exagram_t<double> operator""_Eg(long double value) noexcept
{
    return exagram_t<double>{static_cast<double>(value)};
}

constexpr metric_ton_t<double> operator""_t(long double value) noexcept
{
    return metric_ton_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr newton_t<double> operator""_N(long double value) noexcept
{
    return newton_t<double>{static_cast<double>(value)};
}

constexpr kilonewton_t<double> operator""_kN(long double value) noexcept
{
    return kilonewton_t<double>{static_cast<double>(value)};
}

constexpr meganewton_t<double> operator""_MN(long double value) noexcept
{
    return meganewton_t<double>{static_cast<double>(value)};
}

constexpr millinewton_t<double> operator""_mN(long double value) noexcept
{
    return millinewton_t<double>{static_cast<double>(value)};
}

constexpr micronewton_t<double> operator""_uN(long double value) noexcept
{
    return micronewton_t<double>{static_cast<double>(value)};
}

constexpr nanonewton_t<double> operator""_nN(long double value) noexcept
{
    return nanonewton_t<double>{static_cast<double>(value)};
}

constexpr pascal_t<double> operator""_Pa(long double value) noexcept
{
    return pascal_t<double>{static_cast<double>(value)};
}

constexpr kilopascal_t<double> operator""_kPa(long double value) noexcept
{
    return kilopascal_t<double>{static_cast<double>(value)};
}

constexpr megapascal_t<double> operator""_MPa(long double value) noexcept
{
    return megapascal_t<double>{static_cast<double>(value)};
}

constexpr hectopascal_t<double> operator""_hPa(long double value) noexcept
{
    return hectopascal_t<double>{static_cast<double>(value)};
}

constexpr bar_t<double> operator""_bar(long double value) noexcept
{
    return bar_t<double>{static_cast<double>(value)};
}

constexpr atmosphere_t<double> operator""_atm(long double value) noexcept
{
    return atmosphere_t<double>{static_cast<double>(value)};
}

constexpr joule_t<double> operator""_J(long double value) noexcept
{
    return joule_t<double>{static_cast<double>(value)};
}

constexpr kilojoule_t<double> operator""_kJ(long double value) noexcept
{
    return kilojoule_t<double>{static_cast<double>(value)};
}

constexpr megajoule_t<double> operator""_MJ(long double value) noexcept
{
    return megajoule_t<double>{static_cast<double>(value)};
}

constexpr gigajoule_t<double> operator""_GJ(long double value) noexcept
{
    return gigajoule_t<double>{static_cast<double>(value)};
}

constexpr millijoule_t<double> operator""_mJ(long double value) noexcept
{
    return millijoule_t<double>{static_cast<double>(value)};
}

constexpr microjoule_t<double> operator""_uJ(long double value) noexcept
{
    return microjoule_t<double>{static_cast<double>(value)};
}

constexpr calorie_t<double> operator""_cal(long double value) noexcept
{
    return calorie_t<double>{static_cast<double>(value)};
}

constexpr kilocalorie_t<double> operator""_kcal(long double value) noexcept
{
    return kilocalorie_t<double>{static_cast<double>(value)};
}

constexpr watt_hour_t<double> operator""_Wh(long double value) noexcept
{
    return watt_hour_t<double>{static_cast<double>(value)};
}

constexpr kilowatt_hour_t<double> operator""_kWh(long double value) noexcept
{
    return kilowatt_hour_t<double>{static_cast<double>(value)};
}

constexpr electronvolt_t<double> operator""_eV(long double value) noexcept
{
    return electronvolt_t<double>{static_cast<double>(value)};
}

constexpr kiloelectronvolt_t<double> operator""_keV(long double value) noexcept
{
    return kiloelectronvolt_t<double>{static_cast<double>(value)};
}

constexpr megaelectronvolt_t<double> operator""_MeV(long double value) noexcept
{
    return megaelectronvolt_t<double>{static_cast<double>(value)};
}

constexpr gigaelectronvolt_t<double> operator""_GeV(long double value) noexcept
{
    return gigaelectronvolt_t<double>{static_cast<double>(value)};
}

constexpr watt_t<double> operator""_W(long double value) noexcept
{
    return watt_t<double>{static_cast<double>(value)};
}

constexpr kilowatt_t<double> operator""_kW(long double value) noexcept
{
    return kilowatt_t<double>{static_cast<double>(value)};
}

constexpr megawatt_t<double> operator""_MW(long double value) noexcept
{
    return megawatt_t<double>{static_cast<double>(value)};
}

constexpr gigawatt_t<double> operator""_GW(long double value) noexcept
{
    return gigawatt_t<double>{static_cast<double>(value)};
}

constexpr milliwatt_t<double> operator""_mW(long double value) noexcept
{
    return milliwatt_t<double>{static_cast<double>(value)};
}

constexpr microwatt_t<double> operator""_uW(long double value) noexcept
{
    return microwatt_t<double>{static_cast<double>(value)};
}

constexpr nanowatt_t<double> operator""_nW(long double value) noexcept
{
    return nanowatt_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{
template <is_unit_value_type_c T>
struct celsius_t final : public details::unit_t<T, std::ratio<1, 1>, temperature_dimension>
{

    using base = details::unit_t<T, std::ratio<1, 1>, temperature_dimension>;
    using base::base;
    [[maybe_unused]] static constexpr std::string_view name{"celsius"};
    [[maybe_unused]] static constexpr std::string_view symbol{"C"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b0C"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b0C"};
};

template <is_unit_value_type_c T>
celsius_t(T) -> celsius_t<T>;
}

namespace pkr::units
{
template <is_unit_value_type_c T>
struct fahrenheit_t final : public details::unit_t<T, std::ratio<1, 1>, temperature_dimension>
{

    using base = details::unit_t<T, std::ratio<1, 1>, temperature_dimension>;
    using base::base;
    [[maybe_unused]] static constexpr std::string_view name{"fahrenheit"};
    [[maybe_unused]] static constexpr std::string_view symbol{"F"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"\u00b0F"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"\u00b0F"};
};

template <is_unit_value_type_c T>
fahrenheit_t(T) -> fahrenheit_t<T>;
}

namespace pkr::units
{

namespace literals
{

constexpr attokelvin_t<double> operator""_aK(long double value) noexcept
{
    return attokelvin_t<double>{static_cast<double>(value)};
}

constexpr femtokelvin_t<double> operator""_fK(long double value) noexcept
{
    return femtokelvin_t<double>{static_cast<double>(value)};
}

constexpr picokelvin_t<double> operator""_pK(long double value) noexcept
{
    return picokelvin_t<double>{static_cast<double>(value)};
}

constexpr nanokelvin_t<double> operator""_nK(long double value) noexcept
{
    return nanokelvin_t<double>{static_cast<double>(value)};
}

constexpr microkelvin_t<double> operator""_uK(long double value) noexcept
{
    return microkelvin_t<double>{static_cast<double>(value)};
}

constexpr millikelvin_t<double> operator""_mK(long double value) noexcept
{
    return millikelvin_t<double>{static_cast<double>(value)};
}

constexpr centikelvin_t<double> operator""_cK(long double value) noexcept
{
    return centikelvin_t<double>{static_cast<double>(value)};
}

constexpr decikelvin_t<double> operator""_dK(long double value) noexcept
{
    return decikelvin_t<double>{static_cast<double>(value)};
}

constexpr kelvin_t<double> operator""_K(long double value) noexcept
{
    return kelvin_t<double>{static_cast<double>(value)};
}

constexpr decakelvin_t<double> operator""_daK(long double value) noexcept
{
    return decakelvin_t<double>{static_cast<double>(value)};
}

constexpr hectokelvin_t<double> operator""_hK(long double value) noexcept
{
    return hectokelvin_t<double>{static_cast<double>(value)};
}

constexpr kilokelvin_t<double> operator""_kK(long double value) noexcept
{
    return kilokelvin_t<double>{static_cast<double>(value)};
}

constexpr megakelvin_t<double> operator""_MK(long double value) noexcept
{
    return megakelvin_t<double>{static_cast<double>(value)};
}

constexpr gigakelvin_t<double> operator""_GK(long double value) noexcept
{
    return gigakelvin_t<double>{static_cast<double>(value)};
}

constexpr terakelvin_t<double> operator""_TK(long double value) noexcept
{
    return terakelvin_t<double>{static_cast<double>(value)};
}

constexpr petakelvin_t<double> operator""_PK(long double value) noexcept
{
    return petakelvin_t<double>{static_cast<double>(value)};
}

constexpr exakelvin_t<double> operator""_EK(long double value) noexcept
{
    return exakelvin_t<double>{static_cast<double>(value)};
}

constexpr celsius_t<double> operator""_degC(long double value) noexcept
{
    return celsius_t<double>{static_cast<double>(value)};
}

constexpr fahrenheit_t<double> operator""_degF(long double value) noexcept
{
    return fahrenheit_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr attosecond_t<double> operator""_as(long double value) noexcept
{
    return attosecond_t<double>{static_cast<double>(value)};
}

constexpr femtosecond_t<double> operator""_fs(long double value) noexcept
{
    return femtosecond_t<double>{static_cast<double>(value)};
}

constexpr picosecond_t<double> operator""_ps(long double value) noexcept
{
    return picosecond_t<double>{static_cast<double>(value)};
}

constexpr nanosecond_t<double> operator""_ns(long double value) noexcept
{
    return nanosecond_t<double>{static_cast<double>(value)};
}

constexpr microsecond_t<double> operator""_us(long double value) noexcept
{
    return microsecond_t<double>{static_cast<double>(value)};
}

constexpr millisecond_t<double> operator""_ms(long double value) noexcept
{
    return millisecond_t<double>{static_cast<double>(value)};
}

constexpr centisecond_t<double> operator""_cs(long double value) noexcept
{
    return centisecond_t<double>{static_cast<double>(value)};
}

constexpr decisecond_t<double> operator""_ds(long double value) noexcept
{
    return decisecond_t<double>{static_cast<double>(value)};
}

constexpr second_t<double> operator""_s(long double value) noexcept
{
    return second_t<double>{static_cast<double>(value)};
}

constexpr decasecond_t<double> operator""_das(long double value) noexcept
{
    return decasecond_t<double>{static_cast<double>(value)};
}

constexpr hectosecond_t<double> operator""_hs(long double value) noexcept
{
    return hectosecond_t<double>{static_cast<double>(value)};
}

constexpr kilosecond_t<double> operator""_ks(long double value) noexcept
{
    return kilosecond_t<double>{static_cast<double>(value)};
}

constexpr megasecond_t<double> operator""_Ms(long double value) noexcept
{
    return megasecond_t<double>{static_cast<double>(value)};
}

constexpr gigasecond_t<double> operator""_Gs(long double value) noexcept
{
    return gigasecond_t<double>{static_cast<double>(value)};
}

constexpr terasecond_t<double> operator""_Ts(long double value) noexcept
{
    return terasecond_t<double>{static_cast<double>(value)};
}

constexpr petasecond_t<double> operator""_Ps(long double value) noexcept
{
    return petasecond_t<double>{static_cast<double>(value)};
}

constexpr exasecond_t<double> operator""_Es(long double value) noexcept
{
    return exasecond_t<double>{static_cast<double>(value)};
}

constexpr minute_t<double> operator""_min(long double value) noexcept
{
    return minute_t<double>{static_cast<double>(value)};
}

constexpr hour_t<double> operator""_h(long double value) noexcept
{
    return hour_t<double>{static_cast<double>(value)};
}

constexpr day_t<double> operator""_d(long double value) noexcept
{
    return day_t<double>{static_cast<double>(value)};
}

constexpr week_t<double> operator""_wk(long double value) noexcept
{
    return week_t<double>{static_cast<double>(value)};
}

constexpr month_t<double> operator""_mo(long double value) noexcept
{
    return month_t<double>{static_cast<double>(value)};
}

constexpr year_t<double> operator""_yr(long double value) noexcept
{
    return year_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

namespace literals
{

constexpr meter_per_second_t<double> operator""_mps(long double value) noexcept
{
    return meter_per_second_t<double>{static_cast<double>(value)};
}

constexpr kilometer_per_hour_t<double> operator""_kmph(long double value) noexcept
{
    return kilometer_per_hour_t<double>{static_cast<double>(value)};
}

constexpr centimeter_per_second_t<double> operator""_cmps(long double value) noexcept
{
    return centimeter_per_second_t<double>{static_cast<double>(value)};
}

}

}

namespace pkr::units
{

template <typename T>
struct vec_3d_t
{
    T x, y, z;

    vec_3d_t()
        : x{0}
        , y{0}
        , z{0}
    {
    }

    vec_3d_t(T x_value, T y_value, T z_value)
        : x{x_value}
        , y{y_value}
        , z{z_value}
    {
    }

    vec_3d_t& operator+=(const vec_3d_t& other)
    {
        x += other.x;
        y += other.y;
        z += other.z;
        return *this;
    }

    vec_3d_t& operator-=(const vec_3d_t& other)
    {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        return *this;
    }

    vec_3d_t& operator*=(T scalar)
    {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        return *this;
    }

    vec_3d_t& operator/=(T scalar)
    {
        x /= scalar;
        y /= scalar;
        z /= scalar;
        return *this;
    }
};

template <typename T>
constexpr vec_3d_t<T> operator+(const vec_3d_t<T>& a, const vec_3d_t<T>& b)
{
    return vec_3d_t<T>{a.x + b.x, a.y + b.y, a.z + b.z};
}

template <typename T>
constexpr vec_3d_t<T> operator-(const vec_3d_t<T>& a, const vec_3d_t<T>& b)
{
    return vec_3d_t<T>{a.x - b.x, a.y - b.y, a.z - b.z};
}

template <typename T>
constexpr vec_3d_t<T> operator*(T scalar, const vec_3d_t<T>& v)
{
    return vec_3d_t<T>{scalar * v.x, scalar * v.y, scalar * v.z};
}

template <typename T>
constexpr vec_3d_t<T> operator*(const vec_3d_t<T>& v, T scalar)
{
    return scalar * v;
}

template <typename T>
constexpr T dot(const vec_3d_t<T>& a, const vec_3d_t<T>& b)
{
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

template <typename T>
constexpr vec_3d_t<T> cross(const vec_3d_t<T>& a, const vec_3d_t<T>& b)
{
    return vec_3d_t<T>{a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x};
}

}

namespace pkr::units
{

template <typename T>
struct matrix_3d_t
{
public:
    constexpr matrix_3d_t()
        : m_data{}
    {
    }

    constexpr matrix_3d_t(const std::array<std::array<T, 3>, 3>& init)
        : m_data{init}
    {
    }

    constexpr std::array<T, 3>& operator[](size_t i)
    {
        return m_data[i];
    }

    constexpr const std::array<T, 3>& operator[](size_t i) const
    {
        return m_data[i];
    }

private:
    std::array<std::array<T, 3>, 3> m_data;
};

template <typename T>
constexpr matrix_3d_t<T> identity_3d()
{
    matrix_3d_t<T> m = {};
    for (int i = 0; i < 3; ++i)
        m[i][i] = 1;
    return m;
}

template <typename T>
constexpr vec_3d_t<T> matrix_vector_multiply(const matrix_3d_t<T>& m, const vec_3d_t<T>& v)
{
    return vec_3d_t<T>{
        m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z, m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z, m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z};
}

template <typename T>
constexpr vec_3d_t<T> operator*(const matrix_3d_t<T>& m, const vec_3d_t<T>& v)
{
    return matrix_vector_multiply(m, v);
}

}

namespace pkr::units
{
namespace details
{

struct is_measurement_rss_t_tag
{
};

}

template <typename T>
concept is_measurement_rss_c = std::is_base_of_v<details::is_measurement_rss_t_tag, T>;

template <is_pkr_unit_c UnitT>
class measurement_rss_t : public details::is_measurement_rss_t_tag
{
private:
    UnitT m_value;
    UnitT m_uncertainty;

public:

    constexpr measurement_rss_t() = default;

    constexpr measurement_rss_t(UnitT value, UnitT uncertainty)
        : m_value(value)
        , m_uncertainty(uncertainty)
    {

        if (uncertainty.value() < 0)
        {
            m_uncertainty = UnitT{0};
        }
    }

    constexpr measurement_rss_t(typename UnitT::value_type value, typename UnitT::value_type uncertainty)
        : m_value(UnitT{value})
        , m_uncertainty(UnitT{uncertainty})
    {

        if (uncertainty < 0)
        {
            m_uncertainty = UnitT{0};
        }
    }

    constexpr measurement_rss_t(const measurement_rss_t&) = default;

    constexpr measurement_rss_t(measurement_rss_t&&) = default;

    constexpr measurement_rss_t& operator=(const measurement_rss_t&) = default;

    constexpr measurement_rss_t& operator=(measurement_rss_t&&) = default;
    template <typename OtherUnitT>
        requires is_pkr_unit_c<OtherUnitT> && same_dimensions_c<UnitT, OtherUnitT>
    constexpr auto operator+(const measurement_rss_t<OtherUnitT>& other) const
    {

        auto result_value = m_value + other.unit_value();

        auto uncertainty1_value = m_uncertainty.value();
        auto uncertainty2_value = UnitT{other.unit_uncertainty()}.value();

        auto u1_squared = uncertainty1_value * uncertainty1_value;
        auto u2_squared = uncertainty2_value * uncertainty2_value;
        auto total_uncertainty_value = std::sqrt(u1_squared + u2_squared);

        return measurement_rss_t<UnitT>{result_value, UnitT{total_uncertainty_value}};
    }

    template <typename OtherUnitT>
        requires is_pkr_unit_c<OtherUnitT> && same_dimensions_c<UnitT, OtherUnitT>
    constexpr auto operator-(const measurement_rss_t<OtherUnitT>& other) const
    {

        auto result_value = m_value - other.unit_value();

        auto uncertainty1_value = m_uncertainty.value();
        auto uncertainty2_value = UnitT{other.unit_uncertainty()}.value();

        auto u1_squared = uncertainty1_value * uncertainty1_value;
        auto u2_squared = uncertainty2_value * uncertainty2_value;
        auto total_uncertainty_value = std::sqrt(u1_squared + u2_squared);

        return measurement_rss_t<UnitT>{result_value, UnitT{total_uncertainty_value}};
    }

    template <typename OtherUnitT>
    constexpr auto operator*(const measurement_rss_t<OtherUnitT>& other) const
    {

        auto result_value = (m_value * other.unit_value()).in_base_si_units();
        using result_type = decltype(result_value);

        auto rel_uncertainty1 = relative_uncertainty().value();

        if constexpr (std::is_same_v<UnitT, OtherUnitT>)
        {
            if (this == reinterpret_cast<const measurement_rss_t<UnitT>*>(&other))
            {

                auto result_uncertainty_value = result_value.value() * (2.0 * rel_uncertainty1);
                return measurement_rss_t<result_type>{result_value, result_type{result_uncertainty_value}};
            }
        }

        auto rel_uncertainty2 = other.relative_uncertainty().value();
        auto total_rel_uncertainty = std::sqrt(rel_uncertainty1 * rel_uncertainty1 + rel_uncertainty2 * rel_uncertainty2);
        auto result_uncertainty_value = result_value.value() * total_rel_uncertainty;

        return measurement_rss_t<result_type>{result_value, result_type{result_uncertainty_value}};
    }

    template <typename OtherUnitT>
    constexpr auto operator/(const measurement_rss_t<OtherUnitT>& other) const
    {

        auto result_value = (m_value / other.unit_value()).in_base_si_units();
        using result_type = decltype(result_value);

        if constexpr (std::is_same_v<UnitT, OtherUnitT>)
        {
            if (this == reinterpret_cast<const measurement_rss_t<UnitT>*>(&other))
            {

                return measurement_rss_t<result_type>{result_type{1.0}, result_type{0.0}};
            }
        }

        auto rel_uncertainty1 = relative_uncertainty().value();
        auto rel_uncertainty2 = other.relative_uncertainty().value();

        auto total_rel_uncertainty = std::sqrt(rel_uncertainty1 * rel_uncertainty1 + rel_uncertainty2 * rel_uncertainty2);
        auto result_uncertainty_value = result_value.value() * total_rel_uncertainty;

        return measurement_rss_t<result_type>{result_value, result_type{result_uncertainty_value}};
    }

    constexpr measurement_rss_t operator-() const noexcept
    {
        return measurement_rss_t{-m_value, m_uncertainty};
    }

    constexpr auto value() const
    {
        return m_value.value();
    }

    constexpr auto uncertainty() const
    {
        return m_uncertainty.value();
    }

    constexpr const UnitT& unit_value() const
    {
        return m_value;
    }

    constexpr const UnitT& unit_uncertainty() const
    {
        return m_uncertainty;
    }

    constexpr auto relative_uncertainty() const
    {

        if (m_value.value() == static_cast<typename UnitT::value_type>(0))
        {
            using result_type = decltype(m_uncertainty / m_value);
            return result_type{static_cast<typename UnitT::value_type>(0)};
        }
        return m_uncertainty / m_value;
    }

    constexpr const UnitT& combined_uncertainty() const
    {
        return m_uncertainty;
    }

    constexpr auto squared() const
    {
        auto x = unit_value();
        auto result_value = x * x;

        auto rel_unc = 2.0 * relative_uncertainty().value();
        auto result_uncertainty_value = result_value.value() * rel_unc;

        using ResultUnitT = decltype(result_value);
        return measurement_rss_t<ResultUnitT>{result_value, ResultUnitT{result_uncertainty_value}};
    }

    constexpr auto cubed() const
    {
        auto x = unit_value();
        auto result_value = x * x * x;

        auto rel_unc = 3.0 * relative_uncertainty().value();
        auto result_uncertainty_value = result_value.value() * rel_unc;

        using ResultUnitT = decltype(result_value);
        return measurement_rss_t<ResultUnitT>{result_value, ResultUnitT{result_uncertainty_value}};
    }

    template <int N>
    constexpr auto pow() const
    {
        static_assert(N >= 0, "measurement_rss_t::pow<N>: N must be non-negative (use reciprocal for negative powers)");

        auto result_value = pkr::units::pow<N>(unit_value());

        auto rel_unc = static_cast<typename UnitT::value_type>(N) * relative_uncertainty().value();
        auto result_uncertainty_value = result_value.value() * rel_unc;

        using ResultUnitT = decltype(result_value);
        return measurement_rss_t<ResultUnitT>{result_value, ResultUnitT{result_uncertainty_value}};
    }

    template <typename U = UnitT>
        requires pkr_unit_can_take_square_root_c<details::is_pkr_unit<U>::value_dimension>
    constexpr auto sqrt() const
    {
        auto result_value = pkr::units::sqrt(unit_value());

        auto rel_unc = relative_uncertainty().value() / 2.0;
        auto result_uncertainty_value = result_value.value() * rel_unc;

        return measurement_rss_t<decltype(result_value)>{result_value, decltype(result_value){result_uncertainty_value}};
    }

    template <typename U = UnitT>
        requires pkr::units::is_angle_unit_c<U>
    auto sin() const
    {
        auto result_value = pkr::units::scalar_t{std::sin(value())};

        auto cos_x = std::cos(value());
        auto result_uncertainty_value = std::abs(cos_x) * uncertainty();

        return measurement_rss_t<pkr::units::scalar_t<typename UnitT::value_type>>{result_value, pkr::units::scalar_t{result_uncertainty_value}};
    }

    template <typename U = UnitT>
        requires pkr::units::is_angle_unit_c<U>
    auto cos() const
    {
        auto result_value = pkr::units::scalar_t{std::cos(value())};

        auto sin_x = std::sin(value());
        auto result_uncertainty_value = std::abs(sin_x) * uncertainty();

        return measurement_rss_t<pkr::units::scalar_t<typename UnitT::value_type>>{result_value, pkr::units::scalar_t{result_uncertainty_value}};
    }

    template <typename U = UnitT>
        requires pkr::units::is_angle_unit_c<U>
    auto tan() const
    {
        auto result_value = pkr::units::scalar_t{std::tan(value())};

        auto cos_x = std::cos(value());
        auto sec_squared = 1.0 / (cos_x * cos_x);
        auto result_uncertainty_value = sec_squared * uncertainty();

        return measurement_rss_t<pkr::units::scalar_t<typename UnitT::value_type>>{result_value, pkr::units::scalar_t{result_uncertainty_value}};
    }

    constexpr bool is_valid() const
    {
        return m_uncertainty.value() >= 0;
    }

    std::string to_string() const
    {
        std::stringstream ss;
        ss << m_value.value() << " +/- " << m_uncertainty.value();
        return ss.str();
    }
};

template <typename UnitT>
constexpr bool operator==(const measurement_rss_t<UnitT>& lhs, const measurement_rss_t<UnitT>& rhs)
{
    return lhs.unit_value() == rhs.unit_value() && lhs.unit_uncertainty() == rhs.unit_uncertainty();
}

template <typename UnitT>
constexpr bool operator!=(const measurement_rss_t<UnitT>& lhs, const measurement_rss_t<UnitT>& rhs)
{
    return !(lhs == rhs);
}

template <typename UnitT>
std::ostream& operator<<(std::ostream& os, const measurement_rss_t<UnitT>& measurement)
{
    using stored_t = std::remove_cv_t<UnitT>;
    os << measurement.value() << " +/- " << measurement.uncertainty() << " " << stored_t::symbol;
    return os;
}

template <typename UnitT, typename T>
    requires(std::is_arithmetic_v<T> || pkr::units::is_base_pkr_unit_c<T>)
auto operator*(const measurement_rss_t<UnitT>& lhs, T rhs)
{
    return measurement_rss_t<UnitT>(lhs.value() * rhs, lhs.uncertainty() * std::abs(rhs));
}

template <typename T, typename UnitT>
    requires(std::is_arithmetic_v<T> || pkr::units::is_base_pkr_unit_c<T>)
auto operator*(T lhs, const measurement_rss_t<UnitT>& rhs)
{
    return rhs * lhs;
}

template <typename UnitT, typename T>
    requires(std::is_arithmetic_v<T> || pkr::units::is_base_pkr_unit_c<T>)
auto operator/(const measurement_rss_t<UnitT>& lhs, T rhs)
{
    return measurement_rss_t<UnitT>(lhs.value() / rhs, lhs.uncertainty() / std::abs(rhs));
}

template <typename T, typename UnitT>
    requires is_unit_value_type_c<T>
auto operator/(T lhs, const measurement_rss_t<UnitT>& rhs)
{

    using stored_t = std::remove_cv_t<UnitT>;
    using value_type = typename details::is_pkr_unit<stored_t>::value_type;
    using ratio_type = typename details::is_pkr_unit<stored_t>::ratio_type;
    constexpr auto dim = details::is_pkr_unit<stored_t>::value_dimension;
    constexpr dimension_t inv_dim{-dim.length, -dim.mass, -dim.time, -dim.current, -dim.temperature, -dim.amount, -dim.intensity, -dim.angle};
    using inv_ratio = std::ratio_divide<std::ratio<1, 1>, ratio_type>;
    using InvUnit = details::unit_t<value_type, inv_ratio, inv_dim>;
    return measurement_rss_t<InvUnit>(lhs / rhs.value(), lhs * rhs.uncertainty() / (rhs.value() * rhs.value()));
}

template <typename UnitT>
constexpr auto combined_uncertainty_rss(const measurement_rss_t<UnitT>& measurement)
{
    return measurement.uncertainty();
}

template <typename UnitT>
constexpr typename UnitT::value_type relative_uncertainty_percent_rss(const measurement_rss_t<UnitT>& measurement)
{
    return measurement.relative_uncertainty().value() * 100.0;
}

}

namespace std
{

template <typename UnitT, typename CharT>
struct formatter<pkr::units::measurement_rss_t<UnitT>, CharT>
{
    using stored_t = std::remove_cv_t<UnitT>;
    std::formatter<typename stored_t::value_type, CharT> value_formatter;

    template <typename ParseContext>
    constexpr auto parse(ParseContext& ctx)
    {
        return value_formatter.parse(ctx);
    }

    template <typename FormatContext>
    auto format(const pkr::units::measurement_rss_t<UnitT>& measurement, FormatContext& ctx) const
    {
        auto out = ctx.out();

        out = value_formatter.format(measurement.value(), ctx);

        auto pm_symbol = pkr::units::impl::char_traits_dispatch<CharT>::plus_minus();
        out = std::copy(pm_symbol.begin(), pm_symbol.end(), out);
        out = value_formatter.format(measurement.uncertainty(), ctx);

        *out++ = static_cast<CharT>(' ');
        if constexpr (std::is_same_v<CharT, char>)
            return std::copy(stored_t::symbol.begin(), stored_t::symbol.end(), out);
        else if constexpr (std::is_same_v<CharT, char8_t>)
            return std::copy(stored_t::u8_symbol.begin(), stored_t::u8_symbol.end(), out);
        else if constexpr (std::is_same_v<CharT, wchar_t>)
            return std::copy(stored_t::w_symbol.begin(), stored_t::w_symbol.end(), out);
        else
        {
            for (char ch : stored_t::symbol)
                *out++ = static_cast<CharT>(ch);
            return out;
        }
    }
};

}
namespace pkr::units
{
namespace details
{

struct is_measurement_lin_t_tag
{
};

}

template <typename T>
concept is_measurement_lin_c = std::is_base_of_v<details::is_measurement_lin_t_tag, T>;

template <is_pkr_unit_c UnitT>
class measurement_lin_t : public details::is_measurement_lin_t_tag
{
private:
    UnitT m_value;
    UnitT m_uncertainty;

public:

    constexpr measurement_lin_t() = default;

    constexpr measurement_lin_t(UnitT value, UnitT uncertainty)
        : m_value(value)
        , m_uncertainty(uncertainty)
    {

        if (uncertainty.value() < 0)
        {
            m_uncertainty = UnitT{0};
        }
    }

    constexpr measurement_lin_t(typename UnitT::value_type value, typename UnitT::value_type uncertainty)
        : m_value(UnitT{value})
        , m_uncertainty(UnitT{uncertainty})
    {

        if (uncertainty < 0)
        {
            m_uncertainty = UnitT{0};
        }
    }

    constexpr measurement_lin_t(const measurement_lin_t&) = default;

    constexpr measurement_lin_t(measurement_lin_t&&) = default;

    constexpr measurement_lin_t& operator=(const measurement_lin_t&) = default;

    constexpr measurement_lin_t& operator=(measurement_lin_t&&) = default;
    template <typename OtherUnitT>
        requires is_pkr_unit_c<OtherUnitT> && same_dimensions_c<UnitT, OtherUnitT>
    constexpr auto operator+(const measurement_lin_t<OtherUnitT>& other) const
    {

        auto result_value = m_value + other.unit_value();

        auto uncertainty1_value = m_uncertainty.value();
        auto uncertainty2_value = UnitT{other.unit_uncertainty()}.value();

        auto total_uncertainty_value = uncertainty1_value + uncertainty2_value;

        return measurement_lin_t<UnitT>{result_value, UnitT{total_uncertainty_value}};
    }

    template <typename OtherUnitT>
        requires is_pkr_unit_c<OtherUnitT> && same_dimensions_c<UnitT, OtherUnitT>
    constexpr auto operator-(const measurement_lin_t<OtherUnitT>& other) const
    {

        auto result_value = m_value - other.unit_value();

        auto uncertainty1_value = m_uncertainty.value();
        auto uncertainty2_value = UnitT{other.unit_uncertainty()}.value();

        auto total_uncertainty_value = uncertainty1_value + uncertainty2_value;

        return measurement_lin_t<UnitT>{result_value, UnitT{total_uncertainty_value}};
    }

    template <typename OtherUnitT>
    constexpr auto operator*(const measurement_lin_t<OtherUnitT>& other) const
    {

        auto result_value = (m_value * other.unit_value()).in_base_si_units();
        using result_type = decltype(result_value);

        auto rel_uncertainty1 = relative_uncertainty().value();

        if constexpr (std::is_same_v<UnitT, OtherUnitT>)
        {
            if (this == reinterpret_cast<const measurement_lin_t<UnitT>*>(&other))
            {

                auto result_uncertainty_value = result_value.value() * (2.0 * rel_uncertainty1);
                return measurement_lin_t<result_type>{result_value, result_type{result_uncertainty_value}};
            }
        }

        auto rel_uncertainty2 = other.relative_uncertainty().value();
        auto total_rel_uncertainty = rel_uncertainty1 + rel_uncertainty2;
        auto result_uncertainty_value = result_value.value() * total_rel_uncertainty;

        return measurement_lin_t<result_type>{result_value, result_type{result_uncertainty_value}};
    }

    template <typename OtherUnitT>
    constexpr auto operator/(const measurement_lin_t<OtherUnitT>& other) const
    {

        auto result_value = (m_value / other.unit_value()).in_base_si_units();
        using result_type = decltype(result_value);

        if constexpr (std::is_same_v<UnitT, OtherUnitT>)
        {
            if (this == reinterpret_cast<const measurement_lin_t<UnitT>*>(&other))
            {

                return measurement_lin_t<result_type>{result_type{1.0}, result_type{0.0}};
            }
        }

        auto rel_uncertainty1 = relative_uncertainty().value();
        auto rel_uncertainty2 = other.relative_uncertainty().value();

        auto total_rel_uncertainty = rel_uncertainty1 + rel_uncertainty2;
        auto result_uncertainty_value = result_value.value() * total_rel_uncertainty;

        return measurement_lin_t<result_type>{result_value, result_type{result_uncertainty_value}};
    }

    constexpr measurement_lin_t operator-() const noexcept
    {
        return measurement_lin_t{-m_value, m_uncertainty};
    }

    constexpr auto value() const
    {
        return m_value.value();
    }

    constexpr auto uncertainty() const
    {
        return m_uncertainty.value();
    }

    constexpr const UnitT& unit_value() const
    {
        return m_value;
    }

    constexpr const UnitT& unit_uncertainty() const
    {
        return m_uncertainty;
    }

    constexpr auto relative_uncertainty() const
    {

        if (m_value.value() == static_cast<typename UnitT::value_type>(0))
        {
            using result_type = decltype(m_uncertainty / m_value);
            return result_type{static_cast<typename UnitT::value_type>(0)};
        }
        return m_uncertainty / m_value;
    }

    constexpr const UnitT& combined_uncertainty() const
    {
        return m_uncertainty;
    }

    constexpr bool is_valid() const
    {
        return m_uncertainty.value() >= 0;
    }

    std::string to_string() const
    {
        std::stringstream ss;
        ss << m_value.value() << " +/- " << m_uncertainty.value();
        return ss.str();
    }
};

template <typename UnitT>
constexpr bool operator==(const measurement_lin_t<UnitT>& lhs, const measurement_lin_t<UnitT>& rhs)
{
    return lhs.unit_value() == rhs.unit_value() && lhs.unit_uncertainty() == rhs.unit_uncertainty();
}

template <typename UnitT>
constexpr bool operator!=(const measurement_lin_t<UnitT>& lhs, const measurement_lin_t<UnitT>& rhs)
{
    return !(lhs == rhs);
}

template <typename UnitT>
std::ostream& operator<<(std::ostream& os, const measurement_lin_t<UnitT>& measurement)
{
    using stored_t = std::remove_cv_t<UnitT>;
    os << measurement.value() << " +/- " << measurement.uncertainty() << " " << stored_t::symbol;
    return os;
}

template <typename UnitT, typename T>
    requires(std::is_arithmetic_v<T> || pkr::units::is_base_pkr_unit_c<T>)
auto operator*(const measurement_lin_t<UnitT>& lhs, T rhs)
{
    return measurement_lin_t<UnitT>(lhs.value() * rhs, lhs.uncertainty() * std::abs(rhs));
}

template <typename T, typename UnitT>
    requires(std::is_arithmetic_v<T> || pkr::units::is_base_pkr_unit_c<T>)
auto operator*(T lhs, const measurement_lin_t<UnitT>& rhs)
{
    return rhs * lhs;
}

template <typename UnitT, typename T>
    requires(std::is_arithmetic_v<T> || pkr::units::is_base_pkr_unit_c<T>)
auto operator/(const measurement_lin_t<UnitT>& lhs, T rhs)
{
    return measurement_lin_t<UnitT>(lhs.value() / rhs, lhs.uncertainty() / std::abs(rhs));
}

template <typename T, typename UnitT>
    requires is_unit_value_type_c<T>
auto operator/(T lhs, const measurement_lin_t<UnitT>& rhs)
{

    using stored_t = std::remove_cv_t<UnitT>;
    using value_type = typename details::is_pkr_unit<stored_t>::value_type;
    using ratio_type = typename details::is_pkr_unit<stored_t>::ratio_type;
    constexpr auto dim = details::is_pkr_unit<stored_t>::value_dimension;
    constexpr dimension_t inv_dim{-dim.length, -dim.mass, -dim.time, -dim.current, -dim.temperature, -dim.amount, -dim.intensity, -dim.angle};
    using inv_ratio = std::ratio_divide<std::ratio<1, 1>, ratio_type>;
    using InvUnit = details::unit_t<value_type, inv_ratio, inv_dim>;
    return measurement_lin_t<InvUnit>(lhs / rhs.value(), lhs * rhs.uncertainty() / (rhs.value() * rhs.value()));
}

template <typename UnitT>
constexpr auto square_lin(const measurement_lin_t<UnitT>& measurement)
{
    auto x = measurement.unit_value();
    auto result_value = x * x;

    auto relative_uncertainty = 2.0 * measurement.relative_uncertainty().value();
    auto result_uncertainty_value = result_value.value() * relative_uncertainty;

    using ResultUnitT = decltype(result_value);
    return measurement_lin_t<ResultUnitT>{result_value, ResultUnitT{result_uncertainty_value}};
}

template <typename UnitT>
constexpr auto sum_of_squares_lin(const measurement_lin_t<UnitT>& x, const measurement_lin_t<UnitT>& y, const measurement_lin_t<UnitT>& z)
{
    auto x_sq = square_lin(x);
    auto y_sq = square_lin(y);
    auto z_sq = square_lin(z);
    auto xy_sum = x_sq + y_sq;
    return xy_sum + z_sq;
}

template <typename UnitT>
    requires pkr_unit_can_take_square_root_c<details::is_pkr_unit<UnitT>::value_dimension>
constexpr auto sqrt_lin(const measurement_lin_t<UnitT>& measurement)
{
    auto result_value = sqrt(measurement.unit_value());

    auto relative_uncertainty = measurement.relative_uncertainty().value() / 2.0;
    auto result_uncertainty_value = result_value.value() * relative_uncertainty;

    return measurement_lin_t<decltype(result_value)>{result_value, decltype(result_value){result_uncertainty_value}};
}

template <typename UnitT>
constexpr auto cube_lin(const measurement_lin_t<UnitT>& measurement)
{
    auto x = measurement.unit_value();
    auto result_value = x * x * x;

    auto relative_uncertainty = 3.0 * measurement.relative_uncertainty().value();
    auto result_uncertainty_value = result_value.value() * relative_uncertainty;

    using ResultUnitT = decltype(result_value);
    return measurement_lin_t<ResultUnitT>{result_value, ResultUnitT{result_uncertainty_value}};
}

template <int N, typename UnitT>
constexpr auto pow_lin(const measurement_lin_t<UnitT>& measurement)
{
    auto result_value = pow<N>(measurement.unit_value());

    auto relative_uncertainty = static_cast<typename UnitT::value_type>(std::abs(N)) * measurement.relative_uncertainty().value();
    auto result_uncertainty_value = result_value.value() * relative_uncertainty;

    using ResultUnitT = decltype(result_value);
    return measurement_lin_t<ResultUnitT>{result_value, ResultUnitT{result_uncertainty_value}};
}

template <typename UnitT>
    requires pkr::units::is_angle_unit_c<UnitT>
auto sin_lin(const measurement_lin_t<UnitT>& measurement)
{
    auto result_value = pkr::units::scalar_t{std::sin(measurement.value())};

    auto cos_x = std::cos(measurement.value());
    auto result_uncertainty_value = std::abs(cos_x) * measurement.uncertainty();

    return measurement_lin_t<pkr::units::scalar_t<typename UnitT::value_type>>{result_value, pkr::units::scalar_t{result_uncertainty_value}};
}

template <typename UnitT>
    requires pkr::units::is_angle_unit_c<UnitT>
auto cos_lin(const measurement_lin_t<UnitT>& measurement)
{
    auto result_value = pkr::units::scalar_t{std::cos(measurement.value())};

    auto sin_x = std::sin(measurement.value());
    auto result_uncertainty_value = std::abs(sin_x) * measurement.uncertainty();

    return measurement_lin_t<pkr::units::scalar_t<typename UnitT::value_type>>{result_value, pkr::units::scalar_t{result_uncertainty_value}};
}

template <typename UnitT>
    requires pkr::units::is_angle_unit_c<UnitT>
auto tan_lin(const measurement_lin_t<UnitT>& measurement)
{
    auto result_value = pkr::units::scalar_t{std::tan(measurement.value())};

    auto cos_x = std::cos(measurement.value());
    auto sec_squared = 1.0 / (cos_x * cos_x);
    auto result_uncertainty_value = sec_squared * measurement.uncertainty();

    return measurement_lin_t<pkr::units::scalar_t<typename UnitT::value_type>>{result_value, pkr::units::scalar_t{result_uncertainty_value}};
}

template <typename UnitT>
constexpr auto combined_uncertainty_lin(const measurement_lin_t<UnitT>& measurement)
{
    return measurement.uncertainty();
}

template <typename UnitT>
constexpr typename UnitT::value_type relative_uncertainty_percent_lin(const measurement_lin_t<UnitT>& measurement)
{
    return measurement.relative_uncertainty().value() * 100.0;
}

}

namespace std
{

template <typename UnitT, typename CharT>
struct formatter<pkr::units::measurement_lin_t<UnitT>, CharT>
{
    using stored_t = std::remove_cv_t<UnitT>;
    std::formatter<typename stored_t::value_type, CharT> value_formatter;

    template <typename ParseContext>
    constexpr auto parse(ParseContext& ctx)
    {
        return value_formatter.parse(ctx);
    }

    template <typename FormatContext>
    auto format(const pkr::units::measurement_lin_t<UnitT>& measurement, FormatContext& ctx) const
    {
        auto out = ctx.out();

        out = value_formatter.format(measurement.value(), ctx);

        auto pm_symbol = pkr::units::impl::char_traits_dispatch<CharT>::plus_minus();
        out = std::copy(pm_symbol.begin(), pm_symbol.end(), out);
        out = value_formatter.format(measurement.uncertainty(), ctx);

        *out++ = static_cast<CharT>(' ');
        if constexpr (std::is_same_v<CharT, char>)
            return std::copy(stored_t::symbol.begin(), stored_t::symbol.end(), out);
        else if constexpr (std::is_same_v<CharT, char8_t>)
            return std::copy(stored_t::u8_symbol.begin(), stored_t::u8_symbol.end(), out);
        else if constexpr (std::is_same_v<CharT, wchar_t>)
            return std::copy(stored_t::w_symbol.begin(), stored_t::w_symbol.end(), out);
        else
        {
            for (char ch : stored_t::symbol)
                *out++ = static_cast<CharT>(ch);
            return out;
        }
    }
};

}

namespace pkr::units
{

template <typename T>
struct vec_4d_t
{
    T x, y, z, w;

    vec_4d_t()
        : x{0}
        , y{0}
        , z{0}
        , w{1}
    {
    }

    vec_4d_t(T x_value, T y_value, T z_value, T w_value = 1)
        : x{x_value}
        , y{y_value}
        , z{z_value}
        , w{w_value}
    {
    }

    vec_4d_t& operator+=(const vec_4d_t& other)
    {
        x += other.x;
        y += other.y;
        z += other.z;
        w += other.w;
        return *this;
    }

    vec_4d_t& operator-=(const vec_4d_t& other)
    {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        w -= other.w;
        return *this;
    }

    vec_4d_t& operator*=(T scalar)
    {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        w *= scalar;
        return *this;
    }

    vec_4d_t& operator/=(T scalar)
    {
        x /= scalar;
        y /= scalar;
        z /= scalar;
        w /= scalar;
        return *this;
    }

    double magnitude() const
        requires requires(T a) { std::sqrt(a * a); }
    {
        return std::sqrt(static_cast<double>(x * x + y * y + z * z));
    }
};

template <typename T>
    requires(!is_base_pkr_unit_c<T>)
constexpr vec_4d_t<T> operator+(const vec_4d_t<T>& a, const vec_4d_t<T>& b)
{
    return vec_4d_t<T>{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

template <typename T>
constexpr vec_4d_t<T> operator-(const vec_4d_t<T>& a, const vec_4d_t<T>& b)
{
    return vec_4d_t<T>{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}

template <typename T, typename U>
    requires requires(T a, U b) { a * b; }
constexpr auto operator*(U scalar, const vec_4d_t<T>& v)
{
    using ResultT = decltype(scalar * v.x);
    return vec_4d_t<ResultT>{scalar * v.x, scalar * v.y, scalar * v.z, scalar * v.w};
}

template <typename T, typename U>
    requires requires(T a, U b) { a * b; }
constexpr auto operator*(const vec_4d_t<T>& v, U scalar)
{
    return scalar * v;
}

template <typename T>
constexpr vec_4d_t<T> operator/(const vec_4d_t<T>& v, T scalar)
{
    return vec_4d_t<T>{v.x / scalar, v.y / scalar, v.z / scalar, v.w / scalar};
}

template <typename T>
constexpr vec_4d_t<T> operator-(const vec_4d_t<T>& v)
{
    return vec_4d_t<T>{-v.x, -v.y, -v.z, -v.w};
}

template <typename T>
constexpr bool operator==(const vec_4d_t<T>& a, const vec_4d_t<T>& b)
{
    return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
}

template <typename T>
    requires(!is_base_pkr_unit_c<T>)
constexpr auto dot(const vec_4d_t<T>& a, const vec_4d_t<T>& b) noexcept
{
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
}

}

namespace pkr::units
{

template <typename T>
struct matrix_4d_t
{
public:
    constexpr matrix_4d_t()
        : m_data{}
    {
    }

    constexpr matrix_4d_t(const std::array<std::array<T, 4>, 4>& init)
        : m_data{init}
    {
    }

    constexpr std::array<T, 4>& operator[](size_t i)
    {
        return m_data[i];
    }

    constexpr const std::array<T, 4>& operator[](size_t i) const
    {
        return m_data[i];
    }

private:
    std::array<std::array<T, 4>, 4> m_data;
};

template <typename T>
constexpr matrix_4d_t<T> identity_4d()
{
    matrix_4d_t<T> m = {};
    for (int i = 0; i < 4; ++i)
        m[i][i] = 1;
    return m;
}

template <typename T>
constexpr vec_4d_t<T> matrix_vector_multiply(const matrix_4d_t<T>& m, const vec_4d_t<T>& v)
{
    return vec_4d_t<T>{
        m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w,
        m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,
        m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,
        m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] * v.w};
}

template <typename T>
constexpr vec_4d_t<T> operator*(const matrix_4d_t<T>& m, const vec_4d_t<T>& v)
{
    return matrix_vector_multiply(m, v);
}

}

namespace pkr::units
{

template <pkr::units::is_pkr_unit_c T>
struct vec_measurement_lin_3d_t
{
    pkr::units::measurement_lin_t<T> x, y, z;

    vec_measurement_lin_3d_t()
        : x{0.0, 0.0}
        , y{0.0, 0.0}
        , z{0.0, 0.0}
    {
    }

    vec_measurement_lin_3d_t(pkr::units::measurement_lin_t<T> x, pkr::units::measurement_lin_t<T> y, pkr::units::measurement_lin_t<T> z)
        : x{x}
        , y{y}
        , z{z}
    {
    }

    vec_measurement_lin_3d_t(
        typename T::value_type x_val,
        typename T::value_type x_unc,
        typename T::value_type y_val,
        typename T::value_type y_unc,
        typename T::value_type z_val,
        typename T::value_type z_unc)
        : x{x_val, x_unc}
        , y{y_val, y_unc}
        , z{z_val, z_unc}
    {
    }

    constexpr vec_measurement_lin_3d_t& operator+=(const vec_measurement_lin_3d_t& other) noexcept
    {
        x = x + other.x;
        y = y + other.y;
        z = z + other.z;
        return *this;
    }

    constexpr vec_measurement_lin_3d_t& operator-=(const vec_measurement_lin_3d_t& other) noexcept
    {
        x = x - other.x;
        y = y - other.y;
        z = z - other.z;
        return *this;
    }

    constexpr vec_measurement_lin_3d_t& operator*=(double scalar) noexcept
    {
        x = x * scalar;
        y = y * scalar;
        z = z * scalar;
        return *this;
    }

    constexpr vec_measurement_lin_3d_t& operator/=(double scalar) noexcept
    {
        x = x / scalar;
        y = y / scalar;
        z = z / scalar;
        return *this;
    }

    constexpr auto magnitude() const noexcept
    {
        using measurement_t = pkr::units::measurement_lin_t<T>;
        auto x_sq = x * x;
        auto y_sq = y * y;
        auto z_sq = z * z;
        auto sum_sq = x_sq + y_sq + z_sq;
        auto value = std::sqrt(sum_sq.value());
        auto uncertainty = std::sqrt((sum_sq.uncertainty() * sum_sq.uncertainty()) / (4.0 * value * value));
        return measurement_t{value, uncertainty};
    }
};

template <pkr::units::is_pkr_unit_c T>
constexpr auto operator+(const vec_measurement_lin_3d_t<T>& a, const vec_measurement_lin_3d_t<T>& b) noexcept
{
    return vec_measurement_lin_3d_t<T>{a.x + b.x, a.y + b.y, a.z + b.z};
}

template <pkr::units::is_pkr_unit_c T>
constexpr auto operator-(const vec_measurement_lin_3d_t<T>& a, const vec_measurement_lin_3d_t<T>& b) noexcept
{
    return vec_measurement_lin_3d_t<T>{a.x - b.x, a.y - b.y, a.z - b.z};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_3d_t<T> operator*(const vec_measurement_lin_3d_t<T>& v, double scalar) noexcept
{
    return vec_measurement_lin_3d_t<T>{v.x * scalar, v.y * scalar, v.z * scalar};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_3d_t<T> operator*(double scalar, const vec_measurement_lin_3d_t<T>& v) noexcept
{
    return v * scalar;
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_3d_t<T> operator/(const vec_measurement_lin_3d_t<T>& v, double scalar) noexcept
{
    return vec_measurement_lin_3d_t<T>{v.x / scalar, v.y / scalar, v.z / scalar};
}

template <pkr::units::is_pkr_unit_c T>
constexpr auto dot(const vec_measurement_lin_3d_t<T>& a, const vec_measurement_lin_3d_t<T>& b) noexcept
{
    return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_3d_t<T> cross(const vec_measurement_lin_3d_t<T>& a, const vec_measurement_lin_3d_t<T>& b) noexcept
{
    return vec_measurement_lin_3d_t<T>{(a.y * b.z) - (a.z * b.y), (a.z * b.x) - (a.x * b.z), (a.x * b.y) - (a.y * b.x)};
}

}

namespace pkr::units
{

template <pkr::units::is_pkr_unit_c T>
class matrix_measurement_lin_3d_t
{
public:
    using value_type = pkr::units::measurement_lin_t<T>;
    using array_type = std::array<std::array<value_type, 3>, 3>;

    array_type data;

    constexpr matrix_measurement_lin_3d_t() = default;

    constexpr matrix_measurement_lin_3d_t(const array_type& arr)
        : data(arr)
    {
    }

    constexpr value_type& operator()(size_t row, size_t col)
    {
        return data[row][col];
    }

    constexpr const value_type& operator()(size_t row, size_t col) const
    {
        return data[row][col];
    }

    constexpr std::array<value_type, 3>& operator[](size_t row)
    {
        return data[row];
    }

    constexpr const std::array<value_type, 3>& operator[](size_t row) const
    {
        return data[row];
    }
};

template <pkr::units::is_pkr_unit_c T>
constexpr matrix_measurement_lin_3d_t<T> identity_3d()
{
    matrix_measurement_lin_3d_t<T> m{};
    for (size_t i = 0; i < 3; ++i)
    {
        m[i][i] = typename matrix_measurement_lin_3d_t<T>::value_type{1.0, 0.0};
    }
    return m;
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_3d_t<T> matrix_vector_multiply(const matrix_measurement_lin_3d_t<T>& m, const vec_measurement_lin_3d_t<T>& v) noexcept
{
    auto r0 = (m.data[0][0] * v.x) + (m.data[0][1] * v.y) + (m.data[0][2] * v.z);
    auto r1 = (m.data[1][0] * v.x) + (m.data[1][1] * v.y) + (m.data[1][2] * v.z);
    auto r2 = (m.data[2][0] * v.x) + (m.data[2][1] * v.y) + (m.data[2][2] * v.z);
    return vec_measurement_lin_3d_t<T>{r0, r1, r2};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_3d_t<T> operator*(const matrix_measurement_lin_3d_t<T>& m, const vec_measurement_lin_3d_t<T>& v) noexcept
{
    return matrix_vector_multiply(m, v);
}

}

namespace pkr::units
{

template <pkr::units::is_pkr_unit_c T>
struct vec_measurement_lin_4d_t
{
    pkr::units::measurement_lin_t<T> x, y, z, w;

    vec_measurement_lin_4d_t()
        : x{0.0, 0.0}
        , y{0.0, 0.0}
        , z{0.0, 0.0}
        , w{1.0, 0.0}
    {
    }

    vec_measurement_lin_4d_t(
        pkr::units::measurement_lin_t<T> x,
        pkr::units::measurement_lin_t<T> y,
        pkr::units::measurement_lin_t<T> z,
        pkr::units::measurement_lin_t<T> w = pkr::units::measurement_lin_t<T>{1.0, 0.0})
        : x{x}
        , y{y}
        , z{z}
        , w{w}
    {
    }

    vec_measurement_lin_4d_t(
        typename T::value_type x_val,
        typename T::value_type x_unc,
        typename T::value_type y_val,
        typename T::value_type y_unc,
        typename T::value_type z_val,
        typename T::value_type z_unc,
        typename T::value_type w_val = 1.0,
        typename T::value_type w_unc = 0.0)
        : x{x_val, x_unc}
        , y{y_val, y_unc}
        , z{z_val, z_unc}
        , w{w_val, w_unc}
    {
    }

    constexpr vec_measurement_lin_4d_t& operator+=(const vec_measurement_lin_4d_t& other) noexcept
    {
        x = x + other.x;
        y = y + other.y;
        z = z + other.z;
        w = w + other.w;
        return *this;
    }

    constexpr vec_measurement_lin_4d_t& operator-=(const vec_measurement_lin_4d_t& other) noexcept
    {
        x = x - other.x;
        y = y - other.y;
        z = z - other.z;
        w = w - other.w;
        return *this;
    }

    constexpr vec_measurement_lin_4d_t& operator*=(double scalar) noexcept
    {
        x = x * scalar;
        y = y * scalar;
        z = z * scalar;
        w = w * scalar;
        return *this;
    }

    constexpr vec_measurement_lin_4d_t& operator/=(double scalar) noexcept
    {
        x = x / scalar;
        y = y / scalar;
        z = z / scalar;
        w = w / scalar;
        return *this;
    }

    constexpr auto magnitude() const noexcept
    {
        using measurement_t = pkr::units::measurement_lin_t<T>;

        auto x_sq = x * x;
        auto y_sq = y * y;
        auto z_sq = z * z;
        auto sum_sq = x_sq + y_sq + z_sq;

        auto value = std::sqrt(sum_sq.value());
        auto uncertainty = std::sqrt((sum_sq.uncertainty() * sum_sq.uncertainty()) / (4.0 * value * value));
        return measurement_t{value, uncertainty};
    }
};

template <pkr::units::is_pkr_unit_c T>
constexpr auto operator+(const vec_measurement_lin_4d_t<T>& a, const vec_measurement_lin_4d_t<T>& b) noexcept
{
    return vec_measurement_lin_4d_t<T>{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

template <pkr::units::is_pkr_unit_c T>
constexpr auto operator-(const vec_measurement_lin_4d_t<T>& a, const vec_measurement_lin_4d_t<T>& b) noexcept
{
    return vec_measurement_lin_4d_t<T>{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_4d_t<T> operator*(const vec_measurement_lin_4d_t<T>& v, double scalar) noexcept
{
    return vec_measurement_lin_4d_t<T>{v.x * scalar, v.y * scalar, v.z * scalar, v.w * scalar};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_4d_t<T> operator*(double scalar, const vec_measurement_lin_4d_t<T>& v) noexcept
{
    return v * scalar;
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_4d_t<T> operator/(const vec_measurement_lin_4d_t<T>& v, double scalar) noexcept
{
    return vec_measurement_lin_4d_t<T>{v.x / scalar, v.y / scalar, v.z / scalar, v.w / scalar};
}

template <pkr::units::is_pkr_unit_c T>
constexpr auto dot(const vec_measurement_lin_4d_t<T>& a, const vec_measurement_lin_4d_t<T>& b) noexcept
{
    return (a.x * b.x) + (a.y * b.y) + ((a.z * b.z) + (a.w * b.w));
}

}

namespace pkr::units
{

template <pkr::units::is_pkr_unit_c T>
class matrix_measurement_lin_4d_t
{
public:
    using value_type = pkr::units::measurement_lin_t<T>;
    using array_type = std::array<std::array<value_type, 4>, 4>;

    array_type data;

    constexpr matrix_measurement_lin_4d_t() = default;

    constexpr matrix_measurement_lin_4d_t(const array_type& arr)
        : data(arr)
    {
    }

    constexpr value_type& operator()(size_t row, size_t col)
    {
        return data[row][col];
    }

    constexpr const value_type& operator()(size_t row, size_t col) const
    {
        return data[row][col];
    }

    constexpr std::array<value_type, 4>& operator[](size_t row)
    {
        return data[row];
    }

    constexpr const std::array<value_type, 4>& operator[](size_t row) const
    {
        return data[row];
    }
};

template <pkr::units::is_pkr_unit_c T>
constexpr matrix_measurement_lin_4d_t<T> identity_4d()
{
    matrix_measurement_lin_4d_t<T> m{};
    for (size_t i = 0; i < 4; ++i)
    {
        m[i][i] = typename matrix_measurement_lin_4d_t<T>::value_type{1.0, 0.0};
    }
    return m;
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_4d_t<T> matrix_vector_multiply(const matrix_measurement_lin_4d_t<T>& m, const vec_measurement_lin_4d_t<T>& v) noexcept
{
    auto r0 = (m.data[0][0] * v.x) + (m.data[0][1] * v.y) + (m.data[0][2] * v.z) + (m.data[0][3] * v.w);
    auto r1 = (m.data[1][0] * v.x) + (m.data[1][1] * v.y) + (m.data[1][2] * v.z) + (m.data[1][3] * v.w);
    auto r2 = (m.data[2][0] * v.x) + (m.data[2][1] * v.y) + (m.data[2][2] * v.z) + (m.data[2][3] * v.w);
    auto r3 = (m.data[3][0] * v.x) + (m.data[3][1] * v.y) + (m.data[3][2] * v.z) + (m.data[3][3] * v.w);
    return vec_measurement_lin_4d_t<T>{r0, r1, r2, r3};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_lin_4d_t<T> operator*(const matrix_measurement_lin_4d_t<T>& m, const vec_measurement_lin_4d_t<T>& v) noexcept
{
    return matrix_vector_multiply(m, v);
}

}

namespace pkr::units
{

template <pkr::units::is_pkr_unit_c T>
struct vec_measurement_rss_3d_t
{
    pkr::units::measurement_rss_t<T> x, y, z;

    vec_measurement_rss_3d_t()
        : x{0.0, 0.0}
        , y{0.0, 0.0}
        , z{0.0, 0.0}
    {
    }

    vec_measurement_rss_3d_t(
        pkr::units::measurement_rss_t<T> x_measurement,
        pkr::units::measurement_rss_t<T> y_measurement,
        pkr::units::measurement_rss_t<T> z_measurement)
        : x{x_measurement}
        , y{y_measurement}
        , z{z_measurement}
    {
    }

    vec_measurement_rss_3d_t(
        typename T::value_type x_val,
        typename T::value_type x_unc,
        typename T::value_type y_val,
        typename T::value_type y_unc,
        typename T::value_type z_val,
        typename T::value_type z_unc)
        : x{x_val, x_unc}
        , y{y_val, y_unc}
        , z{z_val, z_unc}
    {
    }

    constexpr vec_measurement_rss_3d_t& operator+=(const vec_measurement_rss_3d_t& other) noexcept
    {
        x = x + other.x;
        y = y + other.y;
        z = z + other.z;
        return *this;
    }

    constexpr vec_measurement_rss_3d_t& operator-=(const vec_measurement_rss_3d_t& other) noexcept
    {
        x = x - other.x;
        y = y - other.y;
        z = z - other.z;
        return *this;
    }

    constexpr vec_measurement_rss_3d_t& operator*=(double scalar) noexcept
    {
        x = x * scalar;
        y = y * scalar;
        z = z * scalar;
        return *this;
    }

    constexpr vec_measurement_rss_3d_t& operator/=(double scalar) noexcept
    {
        x = x / scalar;
        y = y / scalar;
        z = z / scalar;
        return *this;
    }

    constexpr auto magnitude() const noexcept
    {
        using measurement_t = pkr::units::measurement_rss_t<T>;
        auto x_sq = x * x;
        auto y_sq = y * y;
        auto z_sq = z * z;
        auto sum_sq = x_sq + y_sq + z_sq;
        auto value = std::sqrt(sum_sq.value());
        auto uncertainty = std::sqrt((sum_sq.uncertainty() * sum_sq.uncertainty()) / (4.0 * value * value));
        return measurement_t{value, uncertainty};
    }
};

template <pkr::units::is_pkr_unit_c T>
constexpr auto operator+(const vec_measurement_rss_3d_t<T>& a, const vec_measurement_rss_3d_t<T>& b) noexcept
{
    return vec_measurement_rss_3d_t<T>{a.x + b.x, a.y + b.y, a.z + b.z};
}

template <pkr::units::is_pkr_unit_c T>
constexpr auto operator-(const vec_measurement_rss_3d_t<T>& a, const vec_measurement_rss_3d_t<T>& b) noexcept
{
    return vec_measurement_rss_3d_t<T>{a.x - b.x, a.y - b.y, a.z - b.z};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_3d_t<T> operator*(const vec_measurement_rss_3d_t<T>& v, double scalar) noexcept
{
    return vec_measurement_rss_3d_t<T>{v.x * scalar, v.y * scalar, v.z * scalar};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_3d_t<T> operator*(double scalar, const vec_measurement_rss_3d_t<T>& v) noexcept
{
    return v * scalar;
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_3d_t<T> operator/(const vec_measurement_rss_3d_t<T>& v, double scalar) noexcept
{
    return vec_measurement_rss_3d_t<T>{v.x / scalar, v.y / scalar, v.z / scalar};
}

template <pkr::units::is_pkr_unit_c T>
constexpr auto dot(const vec_measurement_rss_3d_t<T>& a, const vec_measurement_rss_3d_t<T>& b) noexcept
{
    return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_3d_t<T> cross(const vec_measurement_rss_3d_t<T>& a, const vec_measurement_rss_3d_t<T>& b) noexcept
{
    return vec_measurement_rss_3d_t<T>{(a.y * b.z) - (a.z * b.y), (a.z * b.x) - (a.x * b.z), (a.x * b.y) - (a.y * b.x)};
}

}

namespace pkr::units
{

template <pkr::units::is_pkr_unit_c T>
class matrix_measurement_rss_3d_t
{
public:
    using value_type = pkr::units::measurement_rss_t<T>;
    using array_type = std::array<std::array<value_type, 3>, 3>;

    array_type data;

    constexpr matrix_measurement_rss_3d_t() = default;

    constexpr matrix_measurement_rss_3d_t(const array_type& arr)
        : data(arr)
    {
    }

    constexpr value_type& operator()(size_t row, size_t col)
    {
        return data[row][col];
    }

    constexpr const value_type& operator()(size_t row, size_t col) const
    {
        return data[row][col];
    }

    constexpr std::array<value_type, 3>& operator[](size_t row)
    {
        return data[row];
    }

    constexpr const std::array<value_type, 3>& operator[](size_t row) const
    {
        return data[row];
    }
};

template <pkr::units::is_pkr_unit_c T>
constexpr matrix_measurement_rss_3d_t<T> identity_3d()
{
    matrix_measurement_rss_3d_t<T> m{};
    for (size_t i = 0; i < 3; ++i)
    {
        m[i][i] = typename matrix_measurement_rss_3d_t<T>::value_type{1.0, 0.0};
    }
    return m;
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_3d_t<T> matrix_vector_multiply(const matrix_measurement_rss_3d_t<T>& m, const vec_measurement_rss_3d_t<T>& v) noexcept
{
    auto r0 = (m.data[0][0] * v.x) + (m.data[0][1] * v.y) + (m.data[0][2] * v.z);
    auto r1 = (m.data[1][0] * v.x) + (m.data[1][1] * v.y) + (m.data[1][2] * v.z);
    auto r2 = (m.data[2][0] * v.x) + (m.data[2][1] * v.y) + (m.data[2][2] * v.z);
    return vec_measurement_rss_3d_t<T>{r0, r1, r2};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_3d_t<T> operator*(const matrix_measurement_rss_3d_t<T>& m, const vec_measurement_rss_3d_t<T>& v) noexcept
{
    return matrix_vector_multiply(m, v);
}

}

namespace pkr::units
{

template <pkr::units::is_pkr_unit_c T>
struct vec_measurement_rss_4d_t
{
    pkr::units::measurement_rss_t<T> x, y, z, w;

    vec_measurement_rss_4d_t()
        : x{0.0, 0.0}
        , y{0.0, 0.0}
        , z{0.0, 0.0}
        , w{1.0, 0.0}
    {
    }

    vec_measurement_rss_4d_t(
        pkr::units::measurement_rss_t<T> x_value,
        pkr::units::measurement_rss_t<T> y_value,
        pkr::units::measurement_rss_t<T> z_value,
        pkr::units::measurement_rss_t<T> w_value = pkr::units::measurement_rss_t<T>{1.0, 0.0})
        : x{x_value}
        , y{y_value}
        , z{z_value}
        , w{w_value}
    {
    }

    vec_measurement_rss_4d_t(
        typename T::value_type x_val,
        typename T::value_type x_unc,
        typename T::value_type y_val,
        typename T::value_type y_unc,
        typename T::value_type z_val,
        typename T::value_type z_unc,
        typename T::value_type w_val = 1.0,
        typename T::value_type w_unc = 0.0)
        : x{x_val, x_unc}
        , y{y_val, y_unc}
        , z{z_val, z_unc}
        , w{w_val, w_unc}
    {
    }

    constexpr vec_measurement_rss_4d_t& operator+=(const vec_measurement_rss_4d_t& other) noexcept
    {
        x = x + other.x;
        y = y + other.y;
        z = z + other.z;
        w = w + other.w;
        return *this;
    }

    constexpr vec_measurement_rss_4d_t& operator-=(const vec_measurement_rss_4d_t& other) noexcept
    {
        x = x - other.x;
        y = y - other.y;
        z = z - other.z;
        w = w - other.w;
        return *this;
    }

    constexpr vec_measurement_rss_4d_t& operator*=(double scalar) noexcept
    {
        x = x * scalar;
        y = y * scalar;
        z = z * scalar;
        w = w * scalar;
        return *this;
    }

    constexpr vec_measurement_rss_4d_t& operator/=(double scalar) noexcept
    {
        x = x / scalar;
        y = y / scalar;
        z = z / scalar;
        w = w / scalar;
        return *this;
    }

    constexpr auto magnitude() const noexcept
    {
        using measurement_t = pkr::units::measurement_rss_t<T>;

        auto x_sq = x * x;
        auto y_sq = y * y;
        auto z_sq = z * z;
        auto sum_sq = x_sq + y_sq + z_sq;

        auto value = std::sqrt(sum_sq.value());
        auto uncertainty = std::sqrt((sum_sq.uncertainty() * sum_sq.uncertainty()) / (4.0 * value * value));
        return measurement_t{value, uncertainty};
    }
};

template <pkr::units::is_pkr_unit_c T>
constexpr auto operator+(const vec_measurement_rss_4d_t<T>& a, const vec_measurement_rss_4d_t<T>& b) noexcept
{
    return vec_measurement_rss_4d_t<T>{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

template <pkr::units::is_pkr_unit_c T>
constexpr auto operator-(const vec_measurement_rss_4d_t<T>& a, const vec_measurement_rss_4d_t<T>& b) noexcept
{
    return vec_measurement_rss_4d_t<T>{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_4d_t<T> operator*(const vec_measurement_rss_4d_t<T>& v, double scalar) noexcept
{
    return vec_measurement_rss_4d_t<T>{v.x * scalar, v.y * scalar, v.z * scalar, v.w * scalar};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_4d_t<T> operator*(double scalar, const vec_measurement_rss_4d_t<T>& v) noexcept
{
    return v * scalar;
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_4d_t<T> operator/(const vec_measurement_rss_4d_t<T>& v, double scalar) noexcept
{
    return vec_measurement_rss_4d_t<T>{v.x / scalar, v.y / scalar, v.z / scalar, v.w / scalar};
}

template <pkr::units::is_pkr_unit_c T>
constexpr auto dot(const vec_measurement_rss_4d_t<T>& a, const vec_measurement_rss_4d_t<T>& b) noexcept
{
    return (a.x * b.x) + (a.y * b.y) + ((a.z * b.z) + (a.w * b.w));
}

}

namespace pkr::units
{

template <pkr::units::is_pkr_unit_c T>
class matrix_measurement_rss_4d_t
{
public:
    using value_type = pkr::units::measurement_rss_t<T>;
    using array_type = std::array<std::array<value_type, 4>, 4>;

    array_type data;

    constexpr matrix_measurement_rss_4d_t() = default;

    constexpr matrix_measurement_rss_4d_t(const array_type& arr)
        : data(arr)
    {
    }

    constexpr value_type& operator()(size_t row, size_t col)
    {
        return data[row][col];
    }

    constexpr const value_type& operator()(size_t row, size_t col) const
    {
        return data[row][col];
    }

    constexpr std::array<value_type, 4>& operator[](size_t row)
    {
        return data[row];
    }

    constexpr const std::array<value_type, 4>& operator[](size_t row) const
    {
        return data[row];
    }
};

template <pkr::units::is_pkr_unit_c T>
constexpr matrix_measurement_rss_4d_t<T> identity_4d()
{
    matrix_measurement_rss_4d_t<T> m{};
    for (size_t i = 0; i < 4; ++i)
    {
        m[i][i] = typename matrix_measurement_rss_4d_t<T>::value_type{1.0, 0.0};
    }
    return m;
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_4d_t<T> matrix_vector_multiply(const matrix_measurement_rss_4d_t<T>& m, const vec_measurement_rss_4d_t<T>& v) noexcept
{
    auto r0 = (m.data[0][0] * v.x) + (m.data[0][1] * v.y) + (m.data[0][2] * v.z) + (m.data[0][3] * v.w);
    auto r1 = (m.data[1][0] * v.x) + (m.data[1][1] * v.y) + (m.data[1][2] * v.z) + (m.data[1][3] * v.w);
    auto r2 = (m.data[2][0] * v.x) + (m.data[2][1] * v.y) + (m.data[2][2] * v.z) + (m.data[2][3] * v.w);
    auto r3 = (m.data[3][0] * v.x) + (m.data[3][1] * v.y) + (m.data[3][2] * v.z) + (m.data[3][3] * v.w);
    return vec_measurement_rss_4d_t<T>{r0, r1, r2, r3};
}

template <pkr::units::is_pkr_unit_c T>
constexpr vec_measurement_rss_4d_t<T> operator*(const matrix_measurement_rss_4d_t<T>& m, const vec_measurement_rss_4d_t<T>& v) noexcept
{
    return matrix_vector_multiply(m, v);
}

}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct cubic_meter_t final : public details::unit_t<T, std::ratio<1, 1>, volume_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, volume_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"cubic meter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"m\u00b3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"m\u00b3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"m\u00b3"};
};

template <is_unit_value_type_c T>
cubic_meter_t(T) -> cubic_meter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == volume_dimension)
cubic_meter_t(const U&) -> cubic_meter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct cubic_kilometer_t final : public details::unit_t<T, std::ratio<1000000000, 1>, volume_dimension>
{
    using _base = details::unit_t<T, std::ratio<1000000000, 1>, volume_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"cubic kilometer"};
    [[maybe_unused]] static constexpr std::string_view symbol{"km\u00b3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"km\u00b3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"km\u00b3"};
};

template <is_unit_value_type_c T>
cubic_kilometer_t(T) -> cubic_kilometer_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == volume_dimension)
cubic_kilometer_t(const U&) -> cubic_kilometer_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct cubic_centimeter_t final : public details::unit_t<T, std::ratio<1, 1000000>, volume_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, volume_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"cubic centimeter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"cm\u00b3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"cm\u00b3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"cm\u00b3"};
};

template <is_unit_value_type_c T>
cubic_centimeter_t(T) -> cubic_centimeter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == volume_dimension)
cubic_centimeter_t(const U&) -> cubic_centimeter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct cubic_millimeter_t final : public details::unit_t<T, std::ratio<1, 1000000000>, volume_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000000>, volume_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"cubic millimeter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mm\u00b3"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mm\u00b3"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mm\u00b3"};
};

template <is_unit_value_type_c T>
cubic_millimeter_t(T) -> cubic_millimeter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == volume_dimension)
cubic_millimeter_t(const U&) -> cubic_millimeter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct liter_t final : public details::unit_t<T, std::ratio<1, 1000>, volume_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000>, volume_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"liter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"L"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"L"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"L"};
};

template <is_unit_value_type_c T>
liter_t(T) -> liter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == volume_dimension)
liter_t(const U&) -> liter_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct milliliter_t final : public details::unit_t<T, std::ratio<1, 1000000>, volume_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1000000>, volume_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"milliliter"};
    [[maybe_unused]] static constexpr std::string_view symbol{"mL"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"mL"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"mL"};
};

template <is_unit_value_type_c T>
milliliter_t(T) -> milliliter_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == volume_dimension)
milliliter_t(const U&) -> milliliter_t<typename details::is_pkr_unit<U>::value_type>;
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct decibel_power_t final : public details::unit_t<T, std::ratio<1, 1>, scalar_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, scalar_dimension>;
    using _base::_base;
    [[maybe_unused]] static constexpr std::string_view name{"decibel_power"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dB"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dB"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dB"};
};

template <is_unit_value_type_c T>
decibel_power_t(T) -> decibel_power_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == scalar_dimension)
decibel_power_t(const U&) -> decibel_power_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct decibel_amplitude_t final : public details::unit_t<T, std::ratio<1, 1>, scalar_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, scalar_dimension>;
    using _base::_base;
    [[maybe_unused]] static constexpr std::string_view name{"decibel_amplitude"};
    [[maybe_unused]] static constexpr std::string_view symbol{"dB"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"dB"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"dB"};
};

template <is_unit_value_type_c T>
decibel_amplitude_t(T) -> decibel_amplitude_t<T>;
}

namespace std
{
template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::decibel_power_t<T>, CharT>
{
    std::formatter<double, CharT> value_formatter;

    template <typename ParseContext>
    constexpr auto parse(ParseContext& ctx)
    {
        return value_formatter.parse(ctx);
    }

    template <typename FormatContext>
    auto format(const pkr::units::decibel_power_t<T>& value, FormatContext& ctx) const
    {
        auto out = ctx.out();
        out = value_formatter.format(value.value(), ctx);
        *out++ = static_cast<CharT>(' ');
        if constexpr (std::is_same_v<CharT, char>)
        {
            return std::copy(pkr::units::decibel_power_t<T>::symbol.begin(), pkr::units::decibel_power_t<T>::symbol.end(), out);
        }
        else if constexpr (std::is_same_v<CharT, wchar_t>)
        {
            return std::copy(pkr::units::decibel_power_t<T>::w_symbol.begin(), pkr::units::decibel_power_t<T>::w_symbol.end(), out);
        }
        else if constexpr (std::is_same_v<CharT, char8_t>)
        {
            return std::copy(pkr::units::decibel_power_t<T>::u8_symbol.begin(), pkr::units::decibel_power_t<T>::u8_symbol.end(), out);
        }
        else
        {
            return std::copy(pkr::units::decibel_power_t<T>::symbol.begin(), pkr::units::decibel_power_t<T>::symbol.end(), out);
        }
    }
};

template <pkr::units::is_unit_value_type_c T, typename CharT>
struct formatter<pkr::units::decibel_amplitude_t<T>, CharT>
{
    std::formatter<double, CharT> value_formatter;

    template <typename ParseContext>
    constexpr auto parse(ParseContext& ctx)
    {
        return value_formatter.parse(ctx);
    }

    template <typename FormatContext>
    auto format(const pkr::units::decibel_amplitude_t<T>& value, FormatContext& ctx) const
    {
        auto out = ctx.out();
        out = value_formatter.format(value.value(), ctx);
        *out++ = static_cast<CharT>(' ');
        if constexpr (std::is_same_v<CharT, char>)
        {
            return std::copy(pkr::units::decibel_amplitude_t<T>::symbol.begin(), pkr::units::decibel_amplitude_t<T>::symbol.end(), out);
        }
        else if constexpr (std::is_same_v<CharT, wchar_t>)
        {
            return std::copy(pkr::units::decibel_amplitude_t<T>::w_symbol.begin(), pkr::units::decibel_amplitude_t<T>::w_symbol.end(), out);
        }
        else if constexpr (std::is_same_v<CharT, char8_t>)
        {
            return std::copy(pkr::units::decibel_amplitude_t<T>::u8_symbol.begin(), pkr::units::decibel_amplitude_t<T>::u8_symbol.end(), out);
        }
        else
        {
            return std::copy(pkr::units::decibel_amplitude_t<T>::symbol.begin(), pkr::units::decibel_amplitude_t<T>::symbol.end(), out);
        }
    }
};
}

namespace pkr::units
{

template <is_unit_value_type_c T>
struct ratio_t final : public details::unit_t<T, std::ratio<1, 1>, scalar_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 1>, scalar_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"ratio"};
    [[maybe_unused]] static constexpr std::string_view symbol{"ratio"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"ratio"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"ratio"};
};

template <is_unit_value_type_c T>
ratio_t(T) -> ratio_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == scalar_dimension)
ratio_t(const U&) -> ratio_t<typename details::is_pkr_unit<U>::value_type>;

template <is_unit_value_type_c T>
struct percentage_t final : public details::unit_t<T, std::ratio<1, 100>, scalar_dimension>
{
    using _base = details::unit_t<T, std::ratio<1, 100>, scalar_dimension>;
    using _base::_base;

    [[maybe_unused]] static constexpr std::string_view name{"percent"};
    [[maybe_unused]] static constexpr std::string_view symbol{"%"};
    [[maybe_unused]] static constexpr std::wstring_view w_symbol{L"%"};
    [[maybe_unused]] static constexpr std::u8string_view u8_symbol{u8"%"};
};

template <is_unit_value_type_c T>
percentage_t(T) -> percentage_t<T>;

template <is_pkr_unit_c U>
    requires(details::is_pkr_unit<U>::value_dimension == scalar_dimension)
percentage_t(const U&) -> percentage_t<typename details::is_pkr_unit<U>::value_type>;
}

namespace pkr::units
{
namespace details
{
template <typename T, typename = void>
struct is_dimensionless_unit : std::false_type
{
};

template <typename T>
struct is_dimensionless_unit<T, std::void_t<decltype(details::is_pkr_unit<T>::value_dimension)>>
    : std::bool_constant<(details::is_pkr_unit<T>::value_dimension == scalar_dimension)>
{
};

template <typename T>
inline constexpr bool is_dimensionless_unit_v = is_dimensionless_unit<T>::value;
}

template <typename target_unit_t, typename source_unit_t>
    requires std::is_same_v<target_unit_t, decibel_power_t<double>> && details::is_dimensionless_unit_v<source_unit_t>
inline decibel_power_t<double> unit_cast(const source_unit_t& source)
{
    auto canonical = details::unit_cast_impl<std::ratio<1, 1>>(source);
    double value = static_cast<double>(canonical.value());
    if (value <= 0.0)
    {
        throw std::invalid_argument("decibel_power conversion requires positive linear ratio");
    }
    return decibel_power_t<double>{10.0 * std::log10(value)};
}

template <typename target_unit_t, typename source_unit_t>
    requires std::is_same_v<target_unit_t, decibel_amplitude_t<double>> && details::is_dimensionless_unit_v<source_unit_t>
inline decibel_amplitude_t<double> unit_cast(const source_unit_t& source)
{
    auto canonical = details::unit_cast_impl<std::ratio<1, 1>>(source);
    double value = static_cast<double>(canonical.value());
    if (value <= 0.0)
    {
        throw std::invalid_argument("decibel_amplitude conversion requires positive linear ratio");
    }
    return decibel_amplitude_t<double>{20.0 * std::log10(value)};
}

template <pkr::units::is_unit_value_type_c SourceT, typename target_unit_t>
    requires details::is_dimensionless_unit_v<target_unit_t>
inline target_unit_t unit_cast(const decibel_power_t<SourceT>& source)
{
    double linear = std::pow(10.0, source.value() / 10.0);
    details::unit_t<double, std::ratio<1, 1>, scalar_dimension> base{linear};
    auto converted = details::unit_cast_impl<typename details::is_pkr_unit<target_unit_t>::ratio_type>(base);
    return target_unit_t{converted.value()};
}

template <pkr::units::is_unit_value_type_c SourceT, typename target_unit_t>
    requires details::is_dimensionless_unit_v<target_unit_t>
inline target_unit_t unit_cast(const decibel_amplitude_t<SourceT>& source)
{
    double linear = std::pow(10.0, source.value() / 20.0);
    details::unit_t<double, std::ratio<1, 1>, scalar_dimension> base{linear};
    auto converted = details::unit_cast_impl<typename details::is_pkr_unit<target_unit_t>::ratio_type>(base);
    return target_unit_t{converted.value()};
}
}

namespace pkr::units
{

template <is_pkr_unit_c T>
struct vec_3d_t<T>
{
    T x, y, z;

    vec_3d_t()
        : x{0}
        , y{0}
        , z{0}
    {
    }

    vec_3d_t(T x_value, T y_value, T z_value)
        : x{x_value}
        , y{y_value}
        , z{z_value}
    {
    }

    constexpr vec_3d_t& operator+=(const vec_3d_t& other) noexcept
    {
        x = x + other.x;
        y = y + other.y;
        z = z + other.z;
        return *this;
    }

    constexpr vec_3d_t& operator-=(const vec_3d_t& other) noexcept
    {
        x = x - other.x;
        y = y - other.y;
        z = z - other.z;
        return *this;
    }

    template <typename ScalarT>
        requires(scalar_value_c<ScalarT> || is_pkr_unit_c<ScalarT>)
    constexpr vec_3d_t& operator*=(const ScalarT& scalar) noexcept
    {
        x = x * scalar;
        y = y * scalar;
        z = z * scalar;
        return *this;
    }

    template <typename ScalarT>
        requires scalar_value_c<ScalarT>
    constexpr vec_3d_t& operator/=(const ScalarT& scalar) noexcept
    {
        x = x / scalar;
        y = y / scalar;
        z = z / scalar;
        return *this;
    }
};

template <is_pkr_unit_c T>
constexpr vec_3d_t<T> operator+(const vec_3d_t<T>& a, const vec_3d_t<T>& b) noexcept
{
    return vec_3d_t<T>{a.x + b.x, a.y + b.y, a.z + b.z};
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>
constexpr auto operator+(const vec_3d_t<T1>& a, const vec_3d_t<T2>& b) noexcept
{
    using ResultT = decltype(a.x + b.x);
    return vec_3d_t<ResultT>{a.x + b.x, a.y + b.y, a.z + b.z};
}

template <is_pkr_unit_c T>
constexpr vec_3d_t<T> operator-(const vec_3d_t<T>& a, const vec_3d_t<T>& b) noexcept
{
    return vec_3d_t<T>{a.x - b.x, a.y - b.y, a.z - b.z};
}

template <is_pkr_unit_c T>
constexpr vec_3d_t<T> operator*(double scalar, const vec_3d_t<T>& v) noexcept
{
    return vec_3d_t<T>{scalar * v.x, scalar * v.y, scalar * v.z};
}

template <is_pkr_unit_c T>
constexpr vec_3d_t<T> operator*(const vec_3d_t<T>& v, double scalar) noexcept
{
    return scalar * v;
}

template <is_pkr_unit_c T>
constexpr auto dot(const vec_3d_t<T>& a, const vec_3d_t<T>& b) noexcept
{
    return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
}

template <is_pkr_unit_c T>
constexpr vec_3d_t<T> cross(const vec_3d_t<T>& a, const vec_3d_t<T>& b) noexcept
{
    return vec_3d_t<T>{(a.y * b.z) - (a.z * b.y), (a.z * b.x) - (a.x * b.z), (a.x * b.y) - (a.y * b.x)};
}
}

namespace pkr::units
{

template <is_base_pkr_unit_c T>
class matrix_3d_units_t
{
public:
    using value_type = T;
    using array_type = std::array<std::array<T, 3>, 3>;
    array_type data;
    constexpr matrix_3d_units_t() = default;

    constexpr matrix_3d_units_t(const array_type& arr)
        : data(arr)
    {
    }

    constexpr matrix_3d_units_t(std::initializer_list<std::initializer_list<T>> list)
    {
        auto row_it = list.begin();
        for (size_t i = 0; i < 3 && row_it != list.end(); ++i, ++row_it)
        {
            auto col_it = row_it->begin();
            for (size_t j = 0; j < 3 && col_it != row_it->end(); ++j, ++col_it)
            {
                data[i][j] = *col_it;
            }
        }
    }

    constexpr T& operator()(size_t row, size_t col)
    {
        return data[row][col];
    }

    constexpr const T& operator()(size_t row, size_t col) const
    {
        return data[row][col];
    }

    constexpr std::array<T, 3>& operator[](size_t row)
    {
        return data[row];
    }

    constexpr const std::array<T, 3>& operator[](size_t row) const
    {
        return data[row];
    }
};

template <is_base_pkr_unit_c T>
constexpr matrix_3d_units_t<T> identity_3d()
{
    matrix_3d_units_t<T> m{};
    for (int i = 0; i < 3; ++i)
        m[i][i] = T{1};
    return m;
}

template <is_base_pkr_unit_c T>
constexpr vec_3d_t<T> matrix_vector_multiply(const matrix_3d_units_t<T>& m, const vec_3d_t<T>& v) noexcept
{
    return vec_3d_t<T>{
        (m.data[0][0] * v.x) + (m.data[0][1] * v.y) + (m.data[0][2] * v.z),
        (m.data[1][0] * v.x) + (m.data[1][1] * v.y) + (m.data[1][2] * v.z),
        (m.data[2][0] * v.x) + (m.data[2][1] * v.y) + (m.data[2][2] * v.z)};
}

template <is_base_pkr_unit_c T>
constexpr vec_3d_t<T> operator*(const matrix_3d_units_t<T>& m, const vec_3d_t<T>& v) noexcept
{
    return matrix_vector_multiply(m, v);
}
}

namespace pkr::units
{

template <is_base_pkr_unit_c T>
class matrix_4d_units_t
{
public:
    using value_type = T;
    using array_type = std::array<std::array<T, 4>, 4>;
    array_type data;
    constexpr matrix_4d_units_t() = default;

    constexpr matrix_4d_units_t(const array_type& arr)
        : data(arr)
    {
    }

    constexpr T& operator()(size_t row, size_t col)
    {
        return data[row][col];
    }

    constexpr const T& operator()(size_t row, size_t col) const
    {
        return data[row][col];
    }

    constexpr std::array<T, 4>& operator[](size_t row)
    {
        return data[row];
    }

    constexpr const std::array<T, 4>& operator[](size_t row) const
    {
        return data[row];
    }
};

template <is_base_pkr_unit_c T>
constexpr matrix_4d_units_t<T> identity_4d()
{
    matrix_4d_units_t<T> m{};
    for (int i = 0; i < 4; ++i)
        m[i][i] = T{1};
    return m;
}

template <is_base_pkr_unit_c T>
constexpr vec_4d_t<T> matrix_vector_multiply(const matrix_4d_units_t<T>& m, const vec_4d_t<T>& v) noexcept
{
    return vec_4d_t<T>{
        ((m.data[0][0] * v.x) + (m.data[0][1] * v.y)) + ((m.data[0][2] * v.z) + (m.data[0][3] * v.w)),
        ((m.data[1][0] * v.x) + (m.data[1][1] * v.y)) + ((m.data[1][2] * v.z) + (m.data[1][3] * v.w)),
        ((m.data[2][0] * v.x) + (m.data[2][1] * v.y)) + ((m.data[2][2] * v.z) + (m.data[2][3] * v.w)),
        ((m.data[3][0] * v.x) + (m.data[3][1] * v.y)) + ((m.data[3][2] * v.z) + (m.data[3][3] * v.w))};
}

template <is_base_pkr_unit_c T>
constexpr vec_4d_t<T> operator*(const matrix_4d_units_t<T>& m, const vec_4d_t<T>& v) noexcept
{
    return matrix_vector_multiply(m, v);
}
}

namespace pkr::units
{

template <is_pkr_unit_c T>
struct vec_4d_units_t
{
    T x, y, z, w;

    constexpr vec_4d_units_t()
        : x{0}
        , y{0}
        , z{0}
        , w{1}
    {
    }

    constexpr vec_4d_units_t(T x_value, T y_value, T z_value, T w_value = 1)
        : x{x_value}
        , y{y_value}
        , z{z_value}
        , w{w_value}
    {
    }

    template <typename U>
        requires(is_pkr_unit_c<U> && !std::is_same_v<U, T>)
    constexpr vec_4d_units_t(U x_value, U y_value, U z_value, U w_value = U{1})
        : x{T{x_value.value()}}
        , y{T{y_value.value()}}
        , z{T{z_value.value()}}
        , w{T{w_value.value()}}
    {
    }

    constexpr vec_4d_units_t& operator+=(const vec_4d_units_t& other) noexcept
    {
        x = x + other.x;
        y = y + other.y;
        z = z + other.z;
        w = w + other.w;
        return *this;
    }

    constexpr vec_4d_units_t& operator-=(const vec_4d_units_t& other) noexcept
    {
        x = x - other.x;
        y = y - other.y;
        z = z - other.z;
        w = w - other.w;
        return *this;
    }

    template <is_base_pkr_unit_c OtherT>
        requires same_dimensions_c<T, OtherT>
    constexpr vec_4d_units_t& operator+=(const vec_4d_units_t<OtherT>& other) noexcept
    {
        x = x + other.x;
        y = y + other.y;
        z = z + other.z;
        w = w + other.w;
        return *this;
    }

    template <is_base_pkr_unit_c OtherT>
        requires same_dimensions_c<T, OtherT>
    constexpr vec_4d_units_t& operator-=(const vec_4d_units_t<OtherT>& other) noexcept
    {
        x = x - other.x;
        y = y - other.y;
        z = z - other.z;
        w = w - other.w;
        return *this;
    }

    template <typename Factor>
        requires(scalar_value_c<Factor> || is_pkr_unit_c<Factor>)
    constexpr vec_4d_units_t& operator*=(const Factor& value) noexcept
    {
        x = x * value;
        y = y * value;
        z = z * value;
        w = w * value;
        return *this;
    }

    template <typename Factor>
        requires scalar_value_c<Factor>
    constexpr vec_4d_units_t& operator/=(const Factor& value) noexcept
    {
        x = x / value;
        y = y / value;
        z = z / value;
        w = w / value;
        return *this;
    }

    constexpr T magnitude() const noexcept
    {
        auto sum_of_squares = (x * x + y * y) + (z * z + w * w);

        auto scalar_value = sum_of_squares.value();
        using value_type = typename details::is_pkr_unit<T>::value_type;
        auto sqrt_value = static_cast<value_type>(std::sqrt(static_cast<double>(scalar_value)));
        return T{sqrt_value};
    }
};

template <is_pkr_unit_c T>
constexpr auto operator+(const vec_4d_units_t<T>& a, const vec_4d_units_t<T>& b) noexcept
{
    auto x_result = a.x + b.x;
    auto y_result = a.y + b.y;
    auto z_result = a.z + b.z;
    auto w_result = a.w + b.w;
    return vec_4d_units_t<decltype(x_result)>{x_result, y_result, z_result, w_result};
}

template <is_pkr_unit_c T1, is_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>
constexpr auto operator+(const vec_4d_units_t<T1>& a, const vec_4d_units_t<T2>& b) noexcept
{
    using ResultT = decltype(a.x + b.x);
    return vec_4d_units_t<ResultT>{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

template <is_pkr_unit_c T>
constexpr auto operator-(const vec_4d_units_t<T>& a, const vec_4d_units_t<T>& b) noexcept
{
    auto x_result = a.x - b.x;
    auto y_result = a.y - b.y;
    auto z_result = a.z - b.z;
    auto w_result = a.w - b.w;
    return vec_4d_units_t<decltype(x_result)>{x_result, y_result, z_result, w_result};
}

template <typename T, is_pkr_unit_c U>
    requires(scalar_value_c<T> || is_pkr_unit_c<T>)
constexpr auto operator*(const T& value, const vec_4d_units_t<U>& v) noexcept
{
    using ResultT = decltype(value * v.x);
    return vec_4d_units_t<ResultT>{value * v.x, value * v.y, value * v.z, value * v.w};
}

template <is_pkr_unit_c U, typename T>
    requires(scalar_value_c<T> || is_pkr_unit_c<T>)
constexpr auto operator*(const vec_4d_units_t<U>& v, const T& value) noexcept
{
    return value * v;
}

template <is_pkr_unit_c T>
constexpr auto dot(const vec_4d_units_t<T>& a, const vec_4d_units_t<T>& b) noexcept
{
    return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
}

template <is_pkr_unit_c U, typename T>
    requires(scalar_value_c<T> || is_pkr_unit_c<T>)
constexpr auto operator/(const vec_4d_units_t<U>& v, const T& value) noexcept
{
    using ResultT = decltype(v.x / value);
    return vec_4d_units_t<ResultT>{v.x / value, v.y / value, v.z / value, v.w / value};
}

template <typename T, is_pkr_unit_c U>
    requires(scalar_value_c<T> || is_pkr_unit_c<T>)
constexpr auto operator/(const T& value, const vec_4d_units_t<U>& v) noexcept
{
    using ResultT = decltype(value / v.x);
    return vec_4d_units_t<ResultT>{value / v.x, value / v.y, value / v.z, value / v.w};
}

template <is_pkr_unit_c T>
constexpr vec_4d_units_t<T> operator-(const vec_4d_units_t<T>& v) noexcept
{
    return vec_4d_units_t<T>{-v.x, -v.y, -v.z, -v.w};
}

template <is_pkr_unit_c T>
constexpr bool operator==(const vec_4d_units_t<T>& a, const vec_4d_units_t<T>& b) noexcept
{
    return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
}
}

namespace pkr::units
{

template <is_base_pkr_unit_c T>
struct vec_4d_t<T>
{
    T x, y, z, w;

    vec_4d_t()
        : x{0}
        , y{0}
        , z{0}
        , w{1}
    {
    }

    vec_4d_t(T x_value, T y_value, T z_value, T w_value = 1)
        : x{x_value}
        , y{y_value}
        , z{z_value}
        , w{w_value}
    {
    }

    constexpr vec_4d_t& operator+=(const vec_4d_t& other) noexcept
    {
        x = x + other.x;
        y = y + other.y;
        z = z + other.z;
        w = w + other.w;
        return *this;
    }

    constexpr vec_4d_t& operator-=(const vec_4d_t& other) noexcept
    {
        x = x - other.x;
        y = y - other.y;
        z = z - other.z;
        w = w - other.w;
        return *this;
    }

    template <scalar_value_c ScalarT>
    constexpr vec_4d_t& operator*=(const ScalarT& scalar) noexcept
    {
        x = x * scalar;
        y = y * scalar;
        z = z * scalar;
        w = w * scalar;
        return *this;
    }

    template <scalar_value_c ScalarT>
    constexpr vec_4d_t& operator/=(const ScalarT& scalar) noexcept
    {
        x = x / scalar;
        y = y / scalar;
        z = z / scalar;
        w = w / scalar;
        return *this;
    }

    constexpr vec_4d_t& operator*=(const typename T::value_type& scalar) noexcept
    {
        x = x * scalar;
        y = y * scalar;
        z = z * scalar;
        w = w * scalar;
        return *this;
    }

    constexpr vec_4d_t& operator/=(const typename T::value_type& scalar) noexcept
    {
        x = x / scalar;
        y = y / scalar;
        z = z / scalar;
        w = w / scalar;
        return *this;
    }
};

template <is_base_pkr_unit_c T>
constexpr vec_4d_t<T> operator+(const vec_4d_t<T>& a, const vec_4d_t<T>& b) noexcept
{
    return vec_4d_t<T>{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

template <is_base_pkr_unit_c T1, is_base_pkr_unit_c T2>
    requires same_dimensions_c<T1, T2>
constexpr auto operator+(const vec_4d_t<T1>& a, const vec_4d_t<T2>& b) noexcept
{
    using ResultT = decltype(a.x + b.x);
    return vec_4d_t<ResultT>{a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w};
}

template <is_base_pkr_unit_c T>
constexpr vec_4d_t<T> operator-(const vec_4d_t<T>& a, const vec_4d_t<T>& b) noexcept
{
    return vec_4d_t<T>{a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w};
}

template <scalar_value_c ScalarT, is_base_pkr_unit_c T>
constexpr auto operator*(const ScalarT& scalar, const vec_4d_t<T>& v) noexcept
{
    using ResultT = decltype(scalar * v.x);
    return vec_4d_t<ResultT>{scalar * v.x, scalar * v.y, scalar * v.z, scalar * v.w};
}

template <is_base_pkr_unit_c T, scalar_value_c ScalarT>
constexpr auto operator*(const vec_4d_t<T>& v, const ScalarT& scalar)
{
    return scalar * v;
}

template <is_base_pkr_unit_c T>
constexpr vec_4d_t<T> operator*(const typename T::value_type& scalar, const vec_4d_t<T>& v) noexcept
{
    return vec_4d_t<T>{scalar * v.x, scalar * v.y, scalar * v.z, scalar * v.w};
}

template <is_base_pkr_unit_c T>
constexpr vec_4d_t<T> operator*(const vec_4d_t<T>& v, const typename T::value_type& scalar) noexcept
{
    return scalar * v;
}

template <is_base_pkr_unit_c T>
constexpr vec_4d_t<T> operator/(const vec_4d_t<T>& v, const typename T::value_type& scalar) noexcept
{
    return vec_4d_t<T>{v.x / scalar, v.y / scalar, v.z / scalar, v.w / scalar};
}

template <is_base_pkr_unit_c T, scalar_value_c ScalarT>
constexpr auto operator/(const vec_4d_t<T>& v, const ScalarT& scalar) noexcept
{
    using ResultT = decltype(v.x / scalar);
    return vec_4d_t<ResultT>{v.x / scalar, v.y / scalar, v.z / scalar, v.w / scalar};
}

template <is_base_pkr_unit_c T>
constexpr auto dot(const vec_4d_t<T>& a, const vec_4d_t<T>& b) noexcept
{

    return (a.x * b.x + a.y * b.y) + (a.z * b.z + a.w * b.w);
}
}
namespace pkr::units
{

inline constexpr double KELVIN_OFFSET = 273.15;

template <typename T>
struct temperature_affine_traits
{
    static constexpr bool is_affine = false;
};

template <is_unit_value_type_c T>
struct temperature_affine_traits<celsius_t<T>>
{
    static constexpr bool is_affine = true;
    using value_type = T;

    static constexpr value_type to_kelvin(value_type value) noexcept
    {
        return value + static_cast<value_type>(KELVIN_OFFSET);
    }

    static constexpr value_type from_kelvin(value_type value) noexcept
    {
        return value - static_cast<value_type>(KELVIN_OFFSET);
    }
};

template <is_unit_value_type_c T>
struct temperature_affine_traits<fahrenheit_t<T>>
{
    static constexpr bool is_affine = true;
    using value_type = T;

    static constexpr value_type to_kelvin(value_type value) noexcept
    {
        return ((value - static_cast<value_type>(32.0)) * static_cast<value_type>(5.0) / static_cast<value_type>(9.0)) + static_cast<value_type>(KELVIN_OFFSET);
    }

    static constexpr value_type from_kelvin(value_type value) noexcept
    {
        return ((value - static_cast<value_type>(KELVIN_OFFSET)) * static_cast<value_type>(9.0) / static_cast<value_type>(5.0)) + static_cast<value_type>(32.0);
    }
};

template <typename T, typename = void>
struct is_temperature_pkr_unit : std::false_type
{
};

template <typename T>
struct is_temperature_pkr_unit<T, std::enable_if_t<is_pkr_unit_c<T>>> : std::bool_constant<(details::is_pkr_unit<T>::value_dimension == temperature_dimension)>
{
};

template <typename T>
inline constexpr bool is_temperature_like_v = temperature_affine_traits<T>::is_affine || is_temperature_pkr_unit<T>::value;

template <typename target_unit_t, typename source_unit_t>
    requires is_temperature_like_v<target_unit_t> && is_temperature_like_v<source_unit_t> &&
             (temperature_affine_traits<target_unit_t>::is_affine || temperature_affine_traits<source_unit_t>::is_affine)
constexpr target_unit_t unit_cast(const source_unit_t& source) noexcept
{
    double kelvin_value = 0.0;
    if constexpr (temperature_affine_traits<source_unit_t>::is_affine)
    {
        kelvin_value = temperature_affine_traits<source_unit_t>::to_kelvin(source.value());
    }
    else
    {
        auto kelvin_unit = details::unit_cast_impl<std::ratio<1, 1>>(source);
        kelvin_value = static_cast<double>(kelvin_unit.value());
    }
    if constexpr (temperature_affine_traits<target_unit_t>::is_affine)
    {
        return target_unit_t{temperature_affine_traits<target_unit_t>::from_kelvin(kelvin_value)};
    }
    else
    {
        using ratio_type = typename details::is_pkr_unit<target_unit_t>::ratio_type;
        using value_type = typename details::is_pkr_unit<target_unit_t>::value_type;
        details::unit_t<value_type, std::ratio<1, 1>, temperature_dimension> base_kelvin{static_cast<value_type>(kelvin_value)};
        auto converted = details::unit_cast_impl<ratio_type>(base_kelvin);
        return target_unit_t{converted.value()};
    }
}

template <typename T>
    requires is_temperature_like_v<T>
constexpr double to_kelvin_for_comparison(const T& temp) noexcept
{
    if constexpr (temperature_affine_traits<T>::is_affine)
    {
        return temperature_affine_traits<T>::to_kelvin(temp.value());
    }
    else
    {

        return static_cast<double>(temp.value());
    }
}

template <typename T1, typename T2>
    requires is_temperature_like_v<T1> && is_temperature_like_v<T2>
constexpr auto operator<=>(const T1& lhs, const T2& rhs) noexcept
{
    double lhs_kelvin = to_kelvin_for_comparison(lhs);
    double rhs_kelvin = to_kelvin_for_comparison(rhs);
    return lhs_kelvin <=> rhs_kelvin;
}

template <typename T1, typename T2>
    requires is_temperature_like_v<T1> && is_temperature_like_v<T2>
constexpr bool operator==(const T1& lhs, const T2& rhs) noexcept
{
    double lhs_kelvin = to_kelvin_for_comparison(lhs);
    double rhs_kelvin = to_kelvin_for_comparison(rhs);
    return lhs_kelvin == rhs_kelvin;
}
}

#endif // PKR_UNITS_CE_SINGLE_HEADER_H
