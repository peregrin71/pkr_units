# SI Units Assembly Optimization Analysis

## Overview

This document provides a detailed analysis of the assembly code generated by the SI Units library, demonstrating how compile-time optimizations eliminate runtime overhead for type-safe dimensional arithmetic.

**Key Finding**: When operands have identical ratios, the `if constexpr` optimization completely eliminates conversion instructions, resulting in identical assembly to plain floating-point arithmetic.

---

## Test Code: `assembly_comparison.cpp`

The test file compares SI unit arithmetic with plain floating-point arithmetic across multiple scenarios using actual runtime values (function parameters) to prevent compile-time constant folding.

### Test Functions

| Function | Input Type | Purpose |
|----------|-----------|---------|
| `plain_add()` | N/A | Baseline: plain double addition |
| `kilometer_add()` | N/A | SI units with matching ratios (compile-time) |
| `meter_add()` | N/A | SI units with matching ratios (compile-time) |
| `same_ratio_add(x, y)` | Runtime doubles | **OPTIMIZED PATH**: Both operands, same ratio |
| `mixed_ratio_add(x, y)` | Runtime doubles | **NON-OPTIMIZED PATH**: Different ratios |
| `kilometer_add_runtime(x, y)` | Runtime doubles | **OPTIMIZED PATH**: Both kilometers, same ratio |

---

## Assembly Output Analysis

### Section 1: Compile-Time Constant Cases

These functions use compile-time constants (no parameters), so the compiler evaluates them entirely at compile-time. This is a bonus optimization beyond `if constexpr`.

```asm
.LCPI0_0:
        .quad   0x409f400000000000              # Constant: 2000.0 (IEEE 754)
plain_add():
        movsd   xmm0, qword ptr [rip + .LCPI0_0]
        ret
```

**Analysis**:
- `movsd`: Move scalar double (loads 2000.0 into xmm0 register)
- `ret`: Return
- **Instruction count**: 2
- **What's happening**: 1000.0 + 1000.0 is completely folded at compile-time to constant 2000.0

---

```asm
.LCPI1_0:
        .quad   0x409f400000000000              # Same constant: 2000.0
kilometer_add():
        movsd   xmm0, qword ptr [rip + .LCPI1_0]
        ret
```

**Analysis**:
- **Identical to `plain_add()`**
- The compiler recognizes that `kilometer(1000.0) + kilometer(1000.0)` equals 2000.0 at compile-time
- The SI unit wrapper is completely optimized away
- **Instruction count**: 2 (same as baseline)
- **Overhead**: **0 instructions**

---

```asm
.LCPI2_0:
        .quad   0x409f400000000000              # Same constant: 2000.0
meter_add():
        movsd   xmm0, qword ptr [rip + .LCPI2_0]
        ret
```

**Analysis**:
- **Also identical**
- Demonstrates that the optimization works for any ratio (meter has ratio 1/1, kilometer has ratio 1000/1)
- **Instruction count**: 2
- **Overhead**: **0 instructions**

---

### Section 2: Runtime Input - Same Ratio Cases (OPTIMIZED PATH)

These functions use runtime parameters so the compiler cannot perform compile-time constant folding. However, the `if constexpr` optimization still eliminates conversion overhead.

#### Optimized Case 1: Same-Ratio Addition

```asm
same_ratio_add(double, double):
        addsd   xmm0, xmm1
        ret
```

**Analysis**:
- `addsd`: Add scalar double (xmm0 += xmm1)
- `ret`: Return
- **Instruction count**: 2
- **Input**: Both operands are `meter` (both have ratio `<1,1>`)
- **The `if constexpr` optimization**:
  ```cpp
  if constexpr (std::is_same_v<ratio<1,1>, ratio<1,1>>) {
      return val1 + val2;  // ← This branch is taken
  } else {
      // This entire else block is COMPILED AWAY at compile-time
      type_t canonical1 = val1 * (ratio_t1::num / ratio_t1::den);
      type_t canonical2 = val2 * (ratio_t2::num / ratio_t2::den);
      return canonical1 + canonical2;
  }
  ```
- **Why**: At compile-time, the compiler knows `std::is_same_v<ratio<1,1>, ratio<1,1>>` is `true`, so it discards the `else` branch entirely
- **Result**: Single addition instruction, no conversion overhead

---

#### Optimized Case 2: Same-Ratio Kilometer Addition

```asm
kilometer_add_runtime(double, double):
        addsd   xmm0, xmm1
        ret
```

**Analysis**:
- **Identical to `same_ratio_add()`**
- **Input**: Both operands are `kilometer` (both have ratio `<1000,1>`)
- **The `if constexpr` optimization**:
  ```cpp
  if constexpr (std::is_same_v<ratio<1000,1>, ratio<1000,1>>) {
      return val1 + val2;  // ← This branch is taken
  } else {
      // COMPILED AWAY - never executed
  }
  ```
- **Key insight**: The compiler recognizes at compile-time that both ratios are identical, so it takes the "same ratio" branch even though the ratio is not 1/1
- **Instruction count**: 2
- **Overhead**: **0 additional instructions** despite using non-standard ratios

---

### Section 3: Runtime Input - Different Ratio Case (NON-OPTIMIZED PATH)

This function uses operands with different ratios. The `if constexpr` optimization takes the `else` branch, requiring conversion instructions.

```asm
.LCPI5_0:
        .quad   0x408f400000000000              # Constant: 1000.0 (conversion factor)

mixed_ratio_add(double, double):
        mulsd   xmm1, qword ptr [rip + .LCPI5_0]    # xmm1 *= 1000.0
        addsd   xmm0, xmm1                          # xmm0 += xmm1
        ret
```

**Analysis**:
- **Input**: `meter(m_val) + kilometer(km_val)`
- **Ratios**: meter has ratio `<1,1>`, kilometer has ratio `<1000,1>`
- **The `if constexpr` optimization**:
  ```cpp
  if constexpr (std::is_same_v<ratio<1,1>, ratio<1000,1>>) {
      // NOT taken - ratios differ
      return val1 + val2;
  } else {
      // ← This branch is taken
      type_t canonical1 = val1 * (1 / 1);        // xmm0 (meter value, unchanged)
      type_t canonical2 = val2 * (1000 / 1);    // xmm1 *= 1000.0 ← This instruction!
      return canonical1 + canonical2;
  }
  ```
- **Instructions**:
  1. `mulsd xmm1, qword ptr [rip + .LCPI5_0]` - Multiply kilometer value by 1000 (convert to meters)
  2. `addsd xmm0, xmm1` - Add converted values
  3. `ret` - Return
- **Instruction count**: 3
- **Overhead vs same-ratio**: **+1 instruction** (the `mulsd`)
- **Why the overhead is necessary**: Different ratios cannot be added directly; they must be converted to a common base (canonical) unit first

---

## Optimization Summary Table

| Function | Ratios | Path | Instructions | `addsd`? | `mulsd`? | Notes |
|----------|--------|------|--------------|----------|----------|-------|
| `plain_add()` | N/A | Baseline | 2 | ✗ | ✗ | Constant folded |
| `kilometer_add()` | 1000:1 + 1000:1 | Const folded | 2 | ✗ | ✗ | Optimized + folded |
| `meter_add()` | 1:1 + 1:1 | Const folded | 2 | ✗ | ✗ | Optimized + folded |
| `same_ratio_add(x, y)` | 1:1 + 1:1 | Same-ratio | 2 | ✓ | ✗ | **OPTIMIZED** |
| `kilometer_add_runtime(x, y)` | 1000:1 + 1000:1 | Same-ratio | 2 | ✓ | ✗ | **OPTIMIZED** |
| `mixed_ratio_add(x, y)` | 1:1 + 1000:1 | Different-ratio | 3 | ✓ | ✓ | Conversion required |

---

## Key Insights

### 1. **Zero Overhead for Same-Ratio Operations**

When both operands have identical ratios, the `if constexpr` optimization produces assembly identical to plain floating-point arithmetic:

```
Plain addition:          SI addition (same ratio):
movsd xmm0, [constant]  addsd xmm0, xmm1
ret                      ret
```

**Impact**: Users can write type-safe dimensional arithmetic without performance penalty when working with compatible units.

---

### 2. **Minimal Overhead for Different-Ratio Operations**

When operands have different ratios, a single additional instruction is required:

```
Same-ratio:             Different-ratio:
addsd xmm0, xmm1        mulsd xmm1, [conversion]
ret                     addsd xmm0, xmm1
                        ret
```

The `mulsd` converts the second operand to the canonical ratio before addition.

**Impact**: The performance cost of type safety is predictable and minimal (one extra floating-point multiply).

---

### 3. **Ratio Detection Happens at Compile-Time**

The `if constexpr` statement is resolved by the compiler **before** code generation:

```cpp
if constexpr (std::is_same_v<ratio_t1, ratio_t2>)
```

- When ratios are identical: The `else` branch is discarded entirely
- When ratios differ: The `else` branch is compiled, and the `if` branch is discarded
- **No runtime branching overhead**: The decision is made at compile-time, not at runtime

---

### 4. **Works for Any Ratio**

The optimization is not limited to canonical ratio `<1,1>`. It works equally well for:
- `kilometer` with ratio `<1000,1>`
- `millimeter` with ratio `<1,1000>`
- Custom units with any ratio

All that matters is whether the ratios are identical at compile-time.

---

## How the Optimization Works: Step-by-Step

### Input Code
```cpp
si::meter m1(500.0);
si::meter m2(1000.0);
auto result = m1 + m2;  // Same ratio: <1,1> + <1,1>
```

### Compilation Process

1. **Template Instantiation**: `operator+(const meter& lhs, const meter& rhs)`
   - Calls `add_optimized<double, ratio<1,1>, ratio<1,1>>(500.0, 1000.0)`

2. **`if constexpr` Evaluation**: Compile-time type comparison
   ```cpp
   if constexpr (std::is_same_v<ratio<1,1>, ratio<1,1>>)  // TRUE at compile-time
   ```

3. **Dead Code Elimination**: Compiler discards the `else` branch
   ```cpp
   // KEPT
   if constexpr (true) {
       return val1 + val2;  // Only this line is kept
   }
   
   // DISCARDED entirely
   else {
       // ... all conversion code removed ...
   }
   ```

4. **Code Generation**: Compiler emits only necessary instructions
   ```asm
   addsd   xmm0, xmm1
   ret
   ```

### For Different Ratios
```cpp
si::meter m(500.0);
si::kilometer km(1.0);
auto result = m + km;  // Different ratio: <1,1> + <1000,1>
```

1. **Template Instantiation**: Calls `add_optimized<double, ratio<1,1>, ratio<1000,1>>(500.0, 1.0)`

2. **`if constexpr` Evaluation**: Compile-time type comparison
   ```cpp
   if constexpr (std::is_same_v<ratio<1,1>, ratio<1000,1>>)  // FALSE at compile-time
   ```

3. **Code Selection**: Compiler keeps only the `else` branch
   ```cpp
   // DISCARDED
   if constexpr (false) { ... }
   
   // KEPT
   else {
       type_t canonical1 = val1 * (1 / 1);        // meter: no conversion
       type_t canonical2 = val2 * (1000 / 1);    // kilometer: multiply by 1000
       return canonical1 + canonical2;
   }
   ```

4. **Code Generation**: Compiler emits conversion + addition
   ```asm
   mulsd   xmm1, [1000.0]  # Convert kilometer to meters
   addsd   xmm0, xmm1      # Add in canonical units
   ret
   ```

---

## Performance Implications

### Best Case: Same-Ratio Operations

```cpp
kilometer(1.5) + kilometer(2.5)  // 1 instruction: addsd
```

- **Cost**: Identical to `double` addition
- **Complexity**: O(1) with minimal constant overhead

---

### Good Case: Different-Ratio Operations

```cpp
meter(500.0) + kilometer(1.0)  // 3 instructions: mulsd + addsd + ret
```

- **Cost**: One additional floating-point multiply
- **Complexity**: Still O(1) with predictable overhead
- **Benefit**: Type safety and dimensional correctness

---

### Theoretical Cost: Runtime Branching (NOT USED)

If we used runtime `if` instead of `if constexpr`:

```cpp
if (std::is_same_v<ratio_t1, ratio_t2>) {  // Runtime branch prediction
    return val1 + val2;
} else {
    // ...
}
```

- **Cost**: Branch misprediction penalty (~10-20 cycles)
- **Benefit**: None (the condition is always the same for a given type pair)
- **Why we don't use it**: `if constexpr` eliminates this waste

---

## Conclusion

The SI Units library achieves **zero-cost abstraction** for dimensional arithmetic through:

1. **Compile-time type information**: Ratios are known at compile-time
2. **`if constexpr` optimization**: Conditional code path selection happens before code generation
3. **Dead code elimination**: Unused branches are never emitted
4. **Inline-friendly design**: Simple arithmetic functions are inlined aggressively

The result is type-safe, dimension-checked arithmetic that generates assembly as efficient as hand-written floating-point code.

---

## References

- [C++17 `if constexpr`](https://en.cppreference.com/w/cpp/language/if)
- [std::ratio](https://en.cppreference.com/w/cpp/numeric/ratio)
- [x86-64 FPU Instructions](https://en.wikipedia.org/wiki/X87)
  - `addsd`: Add scalar double-precision floating-point value
  - `mulsd`: Multiply scalar double-precision floating-point value
- [Godbolt Compiler Explorer](https://godbolt.org)
